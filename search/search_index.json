{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CausalIQ Core","text":""},{"location":"#welcome","title":"Welcome","text":"<p>Welcome to the documentation for the CausalIQ Core \u2014 part of the CausalIQ ecosystem for intelligent causal discovery. </p> <p>CausalIQ Core provides functionality required by several CausalIQ projects. It is not envisaged that it will be used or called directly itself, nor can it be directly used in CausalIQ Workflows.</p>"},{"location":"#overview","title":"Overview","text":"<p>CausalIQ Core provides the following common functionality required by several user-facing CausalIQ packages in the following areas:</p> <ul> <li>graph: support for general graphs, PDAGs and CPDAGs used in causal discovery;</li> <li>bn: support for Bayesian Networks (BNs);</li> <li>io: filesystem io and format conversion, particularly relating to standard formats for graphs (.graphml, .dsc etc) and BNs (.xdsl)</li> <li>utils: utility enums, functions and classes, relating to random numbers, mathematical functions, path handling etc.</li> </ul> <p>This site provides detailed documentation, including: development roadmap, architectural vision, design notes, and API reference for contributors. Since this is not a \"user-facing\" capability a user guide is not provided.</p>"},{"location":"#quickstart-installation","title":"Quickstart &amp; Installation","text":"<p>For a quickstart guide and installation instructions, see the README on GitHub.</p>"},{"location":"#documentation-contents","title":"Documentation Contents","text":"<ul> <li>Development Roadmap: roadmap of upcoming features</li> <li>Architecture: overall architecture and design notes</li> <li>API Reference: complete reference for Python code</li> <li>Development Guidelines: CausalIQ guidelines for developers</li> <li>Changelog</li> <li>License</li> </ul>"},{"location":"#support-community","title":"Support &amp; Community","text":"<ul> <li>GitHub Issues: Report bugs or request features.</li> <li>GitHub Discussions: Ask questions and join the community.</li> </ul> <p>Tip: Use the navigation sidebar to explore the documentation. For the latest code and releases, visit the causaliq-core GitHub repository.</p> <p>Supported Python Versions: 3.9, 3.10, 3.11, 3.12 Default Python Version: 3.11</p>"},{"location":"roadmap/","title":"CausalIQ Repo Template - Development Roadmap","text":"<p>Last updated: December 13, 2025  </p> <p>This project roadmap fits into the overall ecosystem roadmap</p>"},{"location":"roadmap/#under-development","title":"\ud83d\udea7 Under Development","text":"<ul> <li>none</li> </ul>"},{"location":"roadmap/#previous-releases","title":"\u2705 Previous Releases","text":"<ul> <li> <p>0.1 Foundation [November 2025]: Initial package creation and support for shared utility capabilities (mathematical, random numbers and enums etc.)</p> </li> <li> <p>0.2 Graphs [November 2025]: Graph classes representing SDG (general graph), PDAGs and DAGs, and support for Tetrad and Bayesys graph file formats.</p> </li> <li> <p>0.3 Bayesian Networks [December 2025]: BN class and classes for local probability distributions, and support for DSC and XDSL BN file formats.</p> </li> </ul> <p>See Git commit history for detailed implementation progress</p>"},{"location":"roadmap/#upcoming-implementation","title":"\ud83d\udee3\ufe0f Upcoming Implementation","text":"<ul> <li>\ud83d\udee3\ufe0f 0.4 GraphML [December 2025]: Support for GraphML format</li> </ul>"},{"location":"testing/","title":"Test Execution Guide","text":""},{"location":"testing/#pytest-markers","title":"Pytest Markers","text":"<p>This project uses pytest markers to categorize tests:</p> <ul> <li><code>unit</code>: Fast unit tests with no external dependencies</li> <li><code>functional</code>: Tests that interact with CLI or use mocked dependencies  </li> <li><code>integration</code>: Tests with real external dependencies</li> <li><code>slow</code>: Tests that take significant time (system resource access, etc.)</li> </ul>"},{"location":"testing/#running-tests","title":"Running Tests","text":""},{"location":"testing/#fast-development-workflow","title":"Fast Development Workflow","text":"<p>Skip slow tests for quick feedback during development: <pre><code>pytest -m \"not slow\"\n</code></pre></p>"},{"location":"testing/#full-test-suite","title":"Full Test Suite","text":"<p>Run all tests including slow ones: <pre><code>pytest\n</code></pre></p>"},{"location":"testing/#specific-categories","title":"Specific Categories","text":"<p>Run only specific test categories: <pre><code>pytest -m \"unit\"           # Only unit tests\npytest -m \"functional\"     # Only functional tests  \npytest -m \"slow\"          # Only slow tests\npytest -m \"unit or functional and not slow\"  # Complex combinations\n</code></pre></p>"},{"location":"testing/#coverage-without-slow-tests","title":"Coverage Without Slow Tests","text":"<pre><code>pytest --cov=causaliq_core -m \"not slow\"\n</code></pre>"},{"location":"testing/#environment-tests","title":"Environment Tests","text":"<p>The <code>tests/functional/test_environment.py</code> tests are marked as <code>slow</code> because they: - Access real system resources (CPU info, memory stats) - Read/write to filesystem cache - Take longer to execute</p> <p>These tests are important for validating cross-platform behavior but can be skipped during rapid development cycles.</p>"},{"location":"api/bn/","title":"Bayesian Networks Module","text":"<p>The Bayesian Networks module provides comprehensive functionality for working with probabilistic graphical models. It includes classes for representing Bayesian Networks, conditional node distributions, and various I/O formats.</p>"},{"location":"api/bn/#overview","title":"Overview","text":"<p>The <code>causaliq_core.bn</code> module consists of several key components:</p> <ul> <li>Core Classes: Main BN and BNFit classes for network representation</li> <li>Distributions: Conditional node distribution implementations</li> <li>I/O Operations: Reading and writing BNs in various formats</li> </ul>"},{"location":"api/bn/#main-classes","title":"Main Classes","text":""},{"location":"api/bn/#bn","title":"BN","text":"<p>The main Bayesian Network class that combines a DAG structure with conditional probability distributions.</p>"},{"location":"api/bn/#bnfit","title":"BNFit","text":"<p>A fitted Bayesian Network with learned parameters from data.</p>"},{"location":"api/bn/#distribution-types","title":"Distribution Types","text":""},{"location":"api/bn/#cpt-conditional-probability-table","title":"CPT (Conditional Probability Table)","text":"<p>Discrete conditional probability distributions for categorical variables.</p>"},{"location":"api/bn/#lingauss-linear-gaussian","title":"LinGauss (Linear Gaussian)","text":"<p>Continuous conditional distributions for normally distributed variables.</p>"},{"location":"api/bn/#io-formats","title":"I/O Formats","text":""},{"location":"api/bn/#dsc-format","title":"DSC Format","text":"<p>Reading and writing Bayesian Networks in DSC format.</p>"},{"location":"api/bn/#xdsl-format","title":"XDSL Format","text":"<p>Reading and writing Bayesian Networks in GeNIe XDSL format.</p>"},{"location":"api/bn/#key-features","title":"Key Features","text":"<ul> <li>Probabilistic Inference: Compute marginal and conditional probabilities</li> <li>Parameter Learning: Fit network parameters from data</li> <li>Multiple Formats: Support for DSC and XDSL file formats  </li> <li>Flexible Distributions: Both discrete (CPT) and continuous (LinGauss) distributions</li> <li>Graph Integration: Built on the causaliq_core.graph DAG structure</li> </ul>"},{"location":"api/bn/#example-usage","title":"Example Usage","text":"<pre><code>from causaliq_core.bn import BN, CPT\nfrom causaliq_core.graph import DAG\n\n# Create a simple DAG\ndag = DAG(['A', 'B'], [('A', 'B')])\n\n# Define conditional distributions\ncnd_specs = {\n    'A': CPT(values=['T', 'F'], table=[0.3, 0.7]),\n    'B': CPT(values=['T', 'F'], table=[0.9, 0.1, 0.2, 0.8], parents=['A'])\n}\n\n# Create Bayesian Network\nbn = BN(dag, cnd_specs)\n\n# Compute marginals\nmarginals = bn.marginals(['A', 'B'])\n</code></pre>"},{"location":"api/bn/#module-structure","title":"Module Structure","text":""},{"location":"api/bn/#causaliq_core.bn","title":"bn","text":"<p>Bayesian Networks module for CausalIQ Core.</p> <p>This module provides classes and utilities for working with Bayesian Networks, including conditional node distributions and their implementations.</p> <p>Modules:</p> <ul> <li> <code>bn</code>           \u2013            </li> <li> <code>bnfit</code>           \u2013            </li> <li> <code>dist</code>           \u2013            <p>Distribution classes for Bayesian Network nodes.</p> </li> <li> <code>io</code>           \u2013            <p>I/O module for Bayesian Network file formats.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>BN</code>           \u2013            <p>Base class for Bayesian Networks.</p> </li> <li> <code>BNFit</code>           \u2013            <p>Interface for Bayesian Network parameter estimation and data access.</p> </li> <li> <code>CPT</code>           \u2013            <p>Base class for conditional probability tables.</p> </li> <li> <code>LinGauss</code>           \u2013            <p>Conditional Linear Gaussian Distribution.</p> </li> <li> <code>NodeValueCombinations</code>           \u2013            <p>Iterable over all combinations of node values</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BN","title":"BN","text":"<pre><code>BN(dag: DAG, cnd_specs: Dict[str, Any], estimated_pmfs: Dict[str, Any] = {})\n</code></pre> <p>Base class for Bayesian Networks.</p> <p>Bayesian Networks have a DAG and an associated probability distribution defined by CPTs.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>dag</code>           \u2013            <p>BN's DAG.</p> </li> <li> <code>cnds</code>           \u2013            <p>Conditional distributions for each node {node: CND}.</p> </li> <li> <code>free_params</code>           \u2013            <p>Total number of free parameters in BN.</p> </li> <li> <code>estimated_pmfs</code>           \u2013            <p>Number of estimated pmfs for each node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have invalid types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid values.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Compare another BN with this one.</p> </li> <li> <code>fit</code>             \u2013              <p>Alternative instantiation of BN using data to implicitly define the</p> </li> <li> <code>generate_cases</code>             \u2013              <p>Generate specified number of random data cases for this BN.</p> </li> <li> <code>global_distribution</code>             \u2013              <p>Generate the global probability distribution for the BN.</p> </li> <li> <code>lnprob_case</code>             \u2013              <p>Return log of probability of set of node values (case) occuring.</p> </li> <li> <code>marginal_distribution</code>             \u2013              <p>Generate a marginal probability distribution for a specified node</p> </li> <li> <code>marginals</code>             \u2013              <p>Return marginal distribution for specified nodes.</p> </li> <li> <code>rename</code>             \u2013              <p>Rename nodes in place according to name map.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BN(dag)","title":"<code>dag</code>","text":"(<code>DAG</code>)           \u2013            <p>DAG for the Bayesian Network.</p>"},{"location":"api/bn/#causaliq_core.bn.BN(cnd_specs)","title":"<code>cnd_specs</code>","text":"(<code>Dict[str, Any]</code>)           \u2013            <p>Specification of each conditional node distribution.</p>"},{"location":"api/bn/#causaliq_core.bn.BN(estimated_pmfs)","title":"<code>estimated_pmfs</code>","text":"(<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Number of PMFs that had to be estimated for each node.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Compare another BN with this one.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True, if other BN is same as this one.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BN.__eq__(other)","title":"<code>other</code>","text":"(<code>object</code>)           \u2013            <p>The other BN to compare with this one.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.fit","title":"fit  <code>classmethod</code>","text":"<pre><code>fit(dag: DAG, data: BNFit) -&gt; BN\n</code></pre> <p>Alternative instantiation of BN using data to implicitly define the conditional probability data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BN</code>           \u2013            <p>A new BN instance fitted to the data.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have invalid types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid values.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BN.fit(dag)","title":"<code>dag</code>","text":"(<code>DAG</code>)           \u2013            <p>DAG for the Bayesian Network.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.fit(data)","title":"<code>data</code>","text":"(<code>BNFit</code>)           \u2013            <p>Data to fit CPTs to.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.generate_cases","title":"generate_cases","text":"<pre><code>generate_cases(\n    n: int, outfile: Optional[str] = None, pseudo: bool = True\n) -&gt; DataFrame\n</code></pre> <p>Generate specified number of random data cases for this BN.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Random data cases.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments not of correct type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If invalid number of rows requested.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If outfile in nonexistent folder.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BN.generate_cases(n)","title":"<code>n</code>","text":"(<code>int</code>)           \u2013            <p>Number of cases to generate.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.generate_cases(outfile)","title":"<code>outfile</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Name of file to write instance to.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.generate_cases(pseudo)","title":"<code>pseudo</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If pseudo-random (i.e. repeatable cases) to be produced, otherwise truly random.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.global_distribution","title":"global_distribution","text":"<pre><code>global_distribution() -&gt; DataFrame\n</code></pre> <p>Generate the global probability distribution for the BN.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Global distribution in descending probability (and then by</p> </li> <li> <code>DataFrame</code>           \u2013            <p>ascending values).</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BN.lnprob_case","title":"lnprob_case","text":"<pre><code>lnprob_case(case_values: Dict[str, Any], base: Union[int, str] = 10) -&gt; Optional[float]\n</code></pre> <p>Return log of probability of set of node values (case) occuring.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[float]</code>           \u2013            <p>Log of probability of case occuring, or None if case has zero</p> </li> <li> <code>Optional[float]</code>           \u2013            <p>probability.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid values.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BN.lnprob_case(case_values)","title":"<code>case_values</code>","text":"(<code>Dict[str, Any]</code>)           \u2013            <p>Value for each node {node: value}.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.lnprob_case(base)","title":"<code>base</code>","text":"(<code>Union[int, str]</code>, default:                   <code>10</code> )           \u2013            <p>Logarithm base to use - 2, 10 or 'e'.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.marginal_distribution","title":"marginal_distribution","text":"<pre><code>marginal_distribution(node: str, parents: Optional[List[str]] = None) -&gt; DataFrame\n</code></pre> <p>Generate a marginal probability distribution for a specified node and its parents in same format returned by Panda crosstab function.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Marginal distribution with parental value combos as columns,</p> </li> <li> <code>DataFrame</code>           \u2013            <p>and node values as rows.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BN.marginal_distribution(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node for which distribution required.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.marginal_distribution(parents)","title":"<code>parents</code>","text":"(<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Parents of node.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.marginals","title":"marginals","text":"<pre><code>marginals(nodes: List[str]) -&gt; DataFrame\n</code></pre> <p>Return marginal distribution for specified nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Marginal distribution in same format returned by Pandas</p> </li> <li> <code>DataFrame</code>           \u2013            <p>crosstab function.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have bad type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments contain bad values.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BN.marginals(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes for which marginal distribution required.</p>"},{"location":"api/bn/#causaliq_core.bn.BN.rename","title":"rename","text":"<pre><code>rename(name_map: Dict[str, str]) -&gt; None\n</code></pre> <p>Rename nodes in place according to name map.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values e.g. unknown node names.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BN.rename(name_map)","title":"<code>name_map</code>","text":"(<code>Dict[str, str]</code>)           \u2013            <p>Name mapping {name: new name}.</p>"},{"location":"api/bn/#causaliq_core.bn.BNFit","title":"BNFit","text":"<p>Interface for Bayesian Network parameter estimation and data access.</p> <p>This interface provides the essential methods required for fitting conditional probability tables (CPT) and linear Gaussian models in Bayesian Networks, as well as data access methods for the BN class.</p> <p>Implementing classes should provide: - A constructor that accepts df=DataFrame parameter for BN compatibility - All abstract methods defined below - Properties for data access (.nodes, .sample, .node_types)</p> <p>Methods:</p> <ul> <li> <code>marginals</code>             \u2013              <p>Return marginal counts for a node and its parents.</p> </li> <li> <code>values</code>             \u2013              <p>Return the (float) values for specified nodes.</p> </li> <li> <code>write</code>             \u2013              <p>Write data to file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>Total sample size.</p> </li> <li> <code>node_types</code>               (<code>Dict[str, str]</code>)           \u2013            <p>Node type mapping for each variable.</p> </li> <li> <code>node_values</code>               (<code>Dict[str, Dict]</code>)           \u2013            <p>Node value counts for categorical variables.</p> </li> <li> <code>nodes</code>               (<code>Tuple[str, ...]</code>)           \u2013            <p>Column names in the dataset.</p> </li> <li> <code>sample</code>               (<code>Any</code>)           \u2013            <p>Access to underlying data sample.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BNFit.N","title":"N  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<pre><code>N: int\n</code></pre> <p>Total sample size.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Current sample size being used.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BNFit.node_types","title":"node_types  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>node_types: Dict[str, str]\n</code></pre> <p>Node type mapping for each variable.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dictionary mapping node names to their types.</p> </li> <li> <code>Format</code> (              <code>Dict[str, str]</code> )          \u2013            <p>{node: 'category' | 'continuous'}</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BNFit.node_values","title":"node_values  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<pre><code>node_values: Dict[str, Dict]\n</code></pre> <p>Node value counts for categorical variables.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Dict]</code>           \u2013            <p>Values and their counts of categorical nodes in sample.</p> </li> <li> <code>Format</code> (              <code>Dict[str, Dict]</code> )          \u2013            <p>{node1: {val1: count1, val2: count2, ...}, ...}</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BNFit.nodes","title":"nodes  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>nodes: Tuple[str, ...]\n</code></pre> <p>Column names in the dataset.</p> <p>Returns:</p> <ul> <li> <code>Tuple[str, ...]</code>           \u2013            <p>Tuple of node names (column names) in the dataset.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BNFit.sample","title":"sample  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>sample: Any\n</code></pre> <p>Access to underlying data sample.</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The underlying DataFrame or data structure for direct access.</p> </li> <li> <code>Any</code>           \u2013            <p>Used for operations like .unique() on columns.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BNFit.marginals","title":"marginals  <code>abstractmethod</code>","text":"<pre><code>marginals(node: str, parents: Dict, values_reqd: bool = False) -&gt; Tuple\n</code></pre> <p>Return marginal counts for a node and its parents.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple</code>           \u2013            <p>Tuple of counts, and optionally, values:</p> </li> <li> <code>Tuple</code>           \u2013            <ul> <li>ndarray counts: 2D array, rows=child, cols=parents</li> </ul> </li> <li> <code>Tuple</code>           \u2013            <ul> <li>int maxcol: Maximum number of parental values</li> </ul> </li> <li> <code>Tuple</code>           \u2013            <ul> <li>tuple rowval: Child values for each row</li> </ul> </li> <li> <code>Tuple</code>           \u2013            <ul> <li>tuple colval: Parent combo (dict) for each col</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>For bad argument types.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BNFit.marginals(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node for which marginals required.</p>"},{"location":"api/bn/#causaliq_core.bn.BNFit.marginals(parents)","title":"<code>parents</code>","text":"(<code>Dict</code>)           \u2013            <p>Dictionary {node: parents} for non-orphan nodes.</p>"},{"location":"api/bn/#causaliq_core.bn.BNFit.marginals(values_reqd)","title":"<code>values_reqd</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether parent and child values required.</p>"},{"location":"api/bn/#causaliq_core.bn.BNFit.values","title":"values  <code>abstractmethod</code>","text":"<pre><code>values(nodes: Tuple[str, ...]) -&gt; ndarray\n</code></pre> <p>Return the (float) values for specified nodes.</p> <p>Suitable for passing into e.g. linear regression fitting.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Numpy array of values, each column for a node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad argument type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If bad argument value.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BNFit.values(nodes)","title":"<code>nodes</code>","text":"(<code>Tuple[str, ...]</code>)           \u2013            <p>Nodes for which data required.</p>"},{"location":"api/bn/#causaliq_core.bn.BNFit.write","title":"write  <code>abstractmethod</code>","text":"<pre><code>write(filename: str) -&gt; None\n</code></pre> <p>Write data to file.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If filename is not a string.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If output directory doesn't exist.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.BNFit.write(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>Path to output file.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT","title":"CPT","text":"<pre><code>CPT(\n    pmfs: Union[Dict[str, float], List[Tuple[Dict[str, str], Dict[str, float]]]],\n    estimated: int = 0,\n)\n</code></pre> <p>Base class for conditional probability tables.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>cpt</code>           \u2013            <p>Internal representation of the CPT. {node_values: prob} for parentless node, otherwise {parental_values as frozenset: {node_values: prob}}.</p> </li> <li> <code>estimated</code>           \u2013            <p>Number of PMFs that were estimated.</p> </li> <li> <code>values</code>           \u2013            <p>Values which node can take.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid or conflicting values.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Return whether two CPTs are the same allowing for probability</p> </li> <li> <code>__str__</code>             \u2013              <p>Human-friendly description of the contents of the CPT.</p> </li> <li> <code>cdist</code>             \u2013              <p>Return conditional probabilities of node values for specified</p> </li> <li> <code>fit</code>             \u2013              <p>Constructs a CPT (Conditional Probability Table) from data.</p> </li> <li> <code>node_values</code>             \u2013              <p>Return node values (states) of node CPT relates to.</p> </li> <li> <code>param_ratios</code>             \u2013              <p>Returns distribution of parameter ratios across all parental</p> </li> <li> <code>parents</code>             \u2013              <p>Return parents of node CPT relates to.</p> </li> <li> <code>random_value</code>             \u2013              <p>Generate a random value for a node given the value of its parents.</p> </li> <li> <code>to_spec</code>             \u2013              <p>Returns external specification format of CPT,</p> </li> <li> <code>validate_cnds</code>             \u2013              <p>Checks that all CNDs in graph are consistent with one another</p> </li> <li> <code>validate_parents</code>             \u2013              <p>Checks every CPT's parents and parental values are consistent</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.CPT(pmfs)","title":"<code>pmfs</code>","text":"(<code>Union[Dict[str, float], List[Tuple[Dict[str, str], Dict[str, float]]]]</code>)           \u2013            <p>A pmf of {value: prob} for parentless nodes OR list of tuples ({parent: value}, {value: prob}).</p>"},{"location":"api/bn/#causaliq_core.bn.CPT(estimated)","title":"<code>estimated</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>How many PMFs were estimated.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether two CPTs are the same allowing for probability rounding errors</p> <p>:param other: CPT to compared to self :type other: CPT</p> <p>:returns: whether CPTs are PRACTICALLY the same :rtype: bool</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Human-friendly description of the contents of the CPT.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the CPT contents.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.CPT.cdist","title":"cdist","text":"<pre><code>cdist(parental_values: Optional[Dict[str, str]] = None) -&gt; Dict[str, float]\n</code></pre> <p>Return conditional probabilities of node values for specified parental values.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If args are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If args have invalid or conflicting values.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.CPT.cdist(parental_values)","title":"<code>parental_values</code>","text":"(<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>Parental values for which pmf required</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.fit","title":"fit  <code>classmethod</code>","text":"<pre><code>fit(\n    node: str,\n    parents: Optional[Tuple[str, ...]],\n    data: Union[BNFit, Any],\n    autocomplete: bool = True,\n) -&gt; Tuple[Tuple[type, Dict[str, Any]], Optional[int]]\n</code></pre> <p>Constructs a CPT (Conditional Probability Table) from data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple[type, Dict[str, Any]]</code>           \u2013            <p>Tuple of (cnd_spec, estimated_pmfs) where</p> </li> <li> <code>Optional[int]</code>           \u2013            <p>cnd_spec is (CPT class, cpt_spec for CPT())</p> </li> <li> <code>Tuple[Tuple[type, Dict[str, Any]], Optional[int]]</code>           \u2013            <p>estimated_pmfs is int, # estimated pmfs.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.CPT.fit(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node that CPT applies to.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.fit(parents)","title":"<code>parents</code>","text":"(<code>Optional[Tuple[str, ...]]</code>)           \u2013            <p>Parents of node.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.fit(data)","title":"<code>data</code>","text":"(<code>Union[BNFit, Any]</code>)           \u2013            <p>Data to fit CPT to.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.fit(autocomplete)","title":"<code>autocomplete</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to ensure CPT data contains entries for</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.node_values","title":"node_values","text":"<pre><code>node_values() -&gt; List[str]\n</code></pre> <p>Return node values (states) of node CPT relates to.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>Node values in alphabetical order.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.CPT.param_ratios","title":"param_ratios","text":"<pre><code>param_ratios() -&gt; None\n</code></pre> <p>Returns distribution of parameter ratios across all parental values for each combination of possible node values.</p> <p>:returns dict: {(node value pair): (param ratios across parents)</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.parents","title":"parents","text":"<pre><code>parents() -&gt; List[str]\n</code></pre> <p>Return parents of node CPT relates to.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>Parent node names in alphabetical order.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.CPT.random_value","title":"random_value","text":"<pre><code>random_value(pvs: Optional[Dict[str, str]]) -&gt; str\n</code></pre> <p>Generate a random value for a node given the value of its parents.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Random value for node.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.CPT.random_value(pvs)","title":"<code>pvs</code>","text":"(<code>Optional[Dict[str, str]]</code>)           \u2013            <p>Parental values, {parent1: value1, ...}.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.to_spec","title":"to_spec","text":"<pre><code>to_spec(name_map: Dict[str, str]) -&gt; Dict[str, Any]\n</code></pre> <p>Returns external specification format of CPT, renaming nodes according to a name map.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>CPT specification with renamed nodes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If bad arg value, e.g. coeff keys not in map.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.CPT.to_spec(name_map)","title":"<code>name_map</code>","text":"(<code>Dict[str, str]</code>)           \u2013            <p>Map of node names {old: new}.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.validate_cnds","title":"validate_cnds  <code>classmethod</code>","text":"<pre><code>validate_cnds(\n    nodes: List[str], cnds: Dict[str, CND], parents: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Checks that all CNDs in graph are consistent with one another and with graph structure.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If invalid types used in arguments.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If any inconsistent values found.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.CPT.validate_cnds(nodes)","title":"<code>nodes</code>","text":"(<code>list</code>)           \u2013            <p>BN nodes.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.validate_cnds(cnds)","title":"<code>cnds</code>","text":"(<code>dict</code>)           \u2013            <p>Set of CNDs for the BN, {node: cnd}.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.validate_cnds(parents)","title":"<code>parents</code>","text":"(<code>dict</code>)           \u2013            <p>Parents of non-orphan nodes, {node: parents}.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.validate_parents","title":"validate_parents","text":"<pre><code>validate_parents(\n    node: str, parents: Dict[str, List[str]], node_values: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Checks every CPT's parents and parental values are consistent with other relevant CPTs and the DAG structure.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If parent mismatch or missing parental</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.CPT.validate_parents(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Name of node.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.validate_parents(parents)","title":"<code>parents</code>","text":"(<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of all nodes {node: parents}.</p>"},{"location":"api/bn/#causaliq_core.bn.CPT.validate_parents(node_values)","title":"<code>node_values</code>","text":"(<code>Dict[str, List[str]]</code>)           \u2013            <p>Values of each cat. node {node: values}.</p>"},{"location":"api/bn/#causaliq_core.bn.LinGauss","title":"LinGauss","text":"<pre><code>LinGauss(lg: Dict[str, Any])\n</code></pre> <p>Conditional Linear Gaussian Distribution.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>coeffs</code>           \u2013            <p>Linear coefficient of parents {parent: coeff}.</p> </li> <li> <code>mean</code>           \u2013            <p>Mean of Gaussian noise (aka intercept, mu).</p> </li> <li> <code>sd</code>           \u2013            <p>S.D. of Gaussian noise (aka sigma).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If called with bad arg types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If called with bad arg values.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Return whether two CNDs are the same allowing for probability</p> </li> <li> <code>__str__</code>             \u2013              <p>Human-friendly formula description of the Linear Gaussian.</p> </li> <li> <code>cdist</code>             \u2013              <p>Return conditional distribution for specified parental values.</p> </li> <li> <code>fit</code>             \u2013              <p>Fit a Linear Gaussian to data.</p> </li> <li> <code>parents</code>             \u2013              <p>Return parents of node CND relates to.</p> </li> <li> <code>random_value</code>             \u2013              <p>Generate a random value for a node given the value of its parents.</p> </li> <li> <code>to_spec</code>             \u2013              <p>Returns external specification format of LinGauss,</p> </li> <li> <code>validate_parents</code>             \u2013              <p>Check LinGauss coeff keys consistent with parents in DAG.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.LinGauss(lg)","title":"<code>lg</code>","text":"(<code>Dict[str, Any]</code>)           \u2013            <p>Specification of Linear Gaussian in following form: {'coeffs': {node: coeff}, 'mean': mean, 'sd': sd}.</p>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether two CNDs are the same allowing for probability rounding errors</p> <p>:param CND other: CND to compared to self</p> <p>:returns bool: whether LinGauss objects are the same up to 10 sf</p>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Human-friendly formula description of the Linear Gaussian.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the Linear Gaussian formula.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.cdist","title":"cdist","text":"<pre><code>cdist(parental_values: Optional[Dict[str, float]] = None) -&gt; Tuple[float, float]\n</code></pre> <p>Return conditional distribution for specified parental values.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float]</code>           \u2013            <p>Tuple of (mean, sd) of child Gaussian distribution.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If args are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If args have invalid or conflicting values.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.cdist(parental_values)","title":"<code>parental_values</code>","text":"(<code>Optional[Dict[str, float]]</code>, default:                   <code>None</code> )           \u2013            <p>Parental values for which dist. required</p>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.fit","title":"fit  <code>classmethod</code>","text":"<pre><code>fit(\n    node: str,\n    parents: Optional[Tuple[str, ...]],\n    data: Union[Pandas, BNFit],\n    autocomplete: bool = True,\n) -&gt; Tuple[Tuple[type, Dict[str, Any]], Optional[int]]\n</code></pre> <p>Fit a Linear Gaussian to data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple[Tuple[type, Dict[str, Any]], Optional[int]]</code>           \u2013            <p>Tuple of (lg_spec, None) where lg is (LinGauss class, lg_spec).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.fit(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node that Linear Gaussian applies to.</p>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.fit(parents)","title":"<code>parents</code>","text":"(<code>Optional[Tuple[str, ...]]</code>)           \u2013            <p>Parents of node.</p>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.fit(data)","title":"<code>data</code>","text":"(<code>Union[Pandas, BNFit]</code>)           \u2013            <p>Data to fit Linear Gaussian to.</p>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.fit(autocomplete)","title":"<code>autocomplete</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not used for Linear Gaussian.</p>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.parents","title":"parents","text":"<pre><code>parents() -&gt; List[str]\n</code></pre> <p>Return parents of node CND relates to.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>Parent node names in alphabetical order.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.random_value","title":"random_value","text":"<pre><code>random_value(pvs: Optional[Dict[str, float]]) -&gt; float\n</code></pre> <p>Generate a random value for a node given the value of its parents.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Random value for node.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.random_value(pvs)","title":"<code>pvs</code>","text":"(<code>Optional[Dict[str, float]]</code>)           \u2013            <p>Parental values, {parent1: value1, ...}.</p>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.to_spec","title":"to_spec","text":"<pre><code>to_spec(name_map: Dict[str, str]) -&gt; Dict[str, Any]\n</code></pre> <p>Returns external specification format of LinGauss, renaming nodes according to a name map.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>LinGauss specification with renamed nodes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If bad arg value, e.g. coeff keys not in map.</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.to_spec(name_map)","title":"<code>name_map</code>","text":"(<code>Dict[str, str]</code>)           \u2013            <p>Map of node names {old: new}.</p>"},{"location":"api/bn/#causaliq_core.bn.LinGauss.validate_parents","title":"validate_parents","text":"<pre><code>validate_parents(\n    node: str, parents: Dict[str, List[str]], node_values: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Check LinGauss coeff keys consistent with parents in DAG.</p> <p>:param str node: name of node :param dict parents: parents of all nodes defined in DAG :param dict node_values: values of each cat. node [UNUSED]</p>"},{"location":"api/bn/#causaliq_core.bn.NodeValueCombinations","title":"NodeValueCombinations","text":"<pre><code>NodeValueCombinations(node_values: Dict[str, List[str]], sort: bool = True)\n</code></pre> <p>Iterable over all combinations of node values</p> <p>:param dict node_values: allowed values for each node {node: [values]} :param bool sort: whether to sort node names and values into                   alphabetic order</p> <p>Methods:</p> <ul> <li> <code>__iter__</code>             \u2013              <p>Returns the initialised iterator</p> </li> <li> <code>__next__</code>             \u2013              <p>Generate the next node value combination</p> </li> </ul>"},{"location":"api/bn/#causaliq_core.bn.NodeValueCombinations.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; NodeValueCombinations\n</code></pre> <p>Returns the initialised iterator</p> <p>:returns NodeValueCombinations: the iterator</p>"},{"location":"api/bn/#causaliq_core.bn.NodeValueCombinations.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; Dict[str, str]\n</code></pre> <p>Generate the next node value combination</p> <p>:raises StopIteration: when all combinations have been returned</p> <p>:returns dict: next node value combination {node: value}</p>"},{"location":"api/bn_bn/","title":"BN Class","text":"<p>The <code>BN</code> class is the main class for representing Bayesian Networks in CausalIQ Core. It combines a directed acyclic graph (DAG) structure with conditional probability distributions to create a complete probabilistic model.</p>"},{"location":"api/bn_bn/#overview","title":"Overview","text":"<p>A Bayesian Network consists of:</p> <ul> <li>A DAG structure defining the conditional independence relationships</li> <li>Conditional Node Distributions (CNDs) for each node specifying local probability distributions</li> <li>Parameters that can be learned from data or specified manually</li> </ul>"},{"location":"api/bn_bn/#key-features","title":"Key Features","text":"<ul> <li>Probabilistic Inference: Compute marginal and conditional probabilities</li> <li>Parameter Learning: Fit distributions from data using the <code>fit()</code> method</li> <li>Multiple Distribution Types: Support for both discrete (CPT) and continuous (LinGauss) distributions</li> <li>Caching: Efficient computation with cached marginals</li> <li>Serialization: Save and load networks in multiple formats</li> </ul>"},{"location":"api/bn_bn/#class-methods","title":"Class Methods","text":"<p>The BN class provides several key methods:</p> <ul> <li>Construction: Initialize from DAG and conditional distribution specifications</li> <li>Inference: Compute marginals and conditional probabilities</li> <li>Learning: Fit parameters from data</li> <li>Validation: Check network consistency and parameter validity</li> </ul>"},{"location":"api/bn_bn/#example-usage","title":"Example Usage","text":"<pre><code>from causaliq_core.bn import BN, CPT\nfrom causaliq_core.graph import DAG\n\n# Create DAG structure\ndag = DAG(['Weather', 'Sprinkler', 'Grass'], \n          [('Weather', 'Sprinkler'), ('Weather', 'Grass'), ('Sprinkler', 'Grass')])\n\n# Define conditional distributions  \ncnd_specs = {\n    'Weather': CPT(values=['Sunny', 'Rainy'], table=[0.7, 0.3]),\n    'Sprinkler': CPT(values=['On', 'Off'], \n                     table=[0.1, 0.9, 0.8, 0.2], \n                     parents=['Weather']),\n    'Grass': CPT(values=['Wet', 'Dry'],\n                 table=[0.95, 0.05, 0.8, 0.2, 0.9, 0.1, 0.05, 0.95],\n                 parents=['Weather', 'Sprinkler'])\n}\n\n# Create Bayesian Network\nbn = BN(dag, cnd_specs)\n\n# Compute marginal probabilities\nmarginals = bn.marginals(['Weather', 'Grass'])\nprint(marginals)\n\n# Compute conditional probability\nconditional = bn.conditional(['Grass'], ['Weather'], 'Rainy')\nprint(conditional)\n</code></pre>"},{"location":"api/bn_bn/#api-reference","title":"API Reference","text":""},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN","title":"BN","text":"<pre><code>BN(dag: DAG, cnd_specs: Dict[str, Any], estimated_pmfs: Dict[str, Any] = {})\n</code></pre> <p>Base class for Bayesian Networks.</p> <p>Bayesian Networks have a DAG and an associated probability distribution defined by CPTs.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>dag</code>           \u2013            <p>BN's DAG.</p> </li> <li> <code>cnds</code>           \u2013            <p>Conditional distributions for each node {node: CND}.</p> </li> <li> <code>free_params</code>           \u2013            <p>Total number of free parameters in BN.</p> </li> <li> <code>estimated_pmfs</code>           \u2013            <p>Number of estimated pmfs for each node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have invalid types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid values.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Compare another BN with this one.</p> </li> <li> <code>fit</code>             \u2013              <p>Alternative instantiation of BN using data to implicitly define the</p> </li> <li> <code>generate_cases</code>             \u2013              <p>Generate specified number of random data cases for this BN.</p> </li> <li> <code>global_distribution</code>             \u2013              <p>Generate the global probability distribution for the BN.</p> </li> <li> <code>lnprob_case</code>             \u2013              <p>Return log of probability of set of node values (case) occuring.</p> </li> <li> <code>marginal_distribution</code>             \u2013              <p>Generate a marginal probability distribution for a specified node</p> </li> <li> <code>marginals</code>             \u2013              <p>Return marginal distribution for specified nodes.</p> </li> <li> <code>rename</code>             \u2013              <p>Rename nodes in place according to name map.</p> </li> </ul>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN(dag)","title":"<code>dag</code>","text":"(<code>DAG</code>)           \u2013            <p>DAG for the Bayesian Network.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN(cnd_specs)","title":"<code>cnd_specs</code>","text":"(<code>Dict[str, Any]</code>)           \u2013            <p>Specification of each conditional node distribution.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN(estimated_pmfs)","title":"<code>estimated_pmfs</code>","text":"(<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Number of PMFs that had to be estimated for each node.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Compare another BN with this one.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True, if other BN is same as this one.</p> </li> </ul>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.__eq__(other)","title":"<code>other</code>","text":"(<code>object</code>)           \u2013            <p>The other BN to compare with this one.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.fit","title":"fit  <code>classmethod</code>","text":"<pre><code>fit(dag: DAG, data: BNFit) -&gt; BN\n</code></pre> <p>Alternative instantiation of BN using data to implicitly define the conditional probability data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BN</code>           \u2013            <p>A new BN instance fitted to the data.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have invalid types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid values.</p> </li> </ul>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.fit(dag)","title":"<code>dag</code>","text":"(<code>DAG</code>)           \u2013            <p>DAG for the Bayesian Network.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.fit(data)","title":"<code>data</code>","text":"(<code>BNFit</code>)           \u2013            <p>Data to fit CPTs to.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.generate_cases","title":"generate_cases","text":"<pre><code>generate_cases(\n    n: int, outfile: Optional[str] = None, pseudo: bool = True\n) -&gt; DataFrame\n</code></pre> <p>Generate specified number of random data cases for this BN.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Random data cases.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments not of correct type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If invalid number of rows requested.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If outfile in nonexistent folder.</p> </li> </ul>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.generate_cases(n)","title":"<code>n</code>","text":"(<code>int</code>)           \u2013            <p>Number of cases to generate.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.generate_cases(outfile)","title":"<code>outfile</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Name of file to write instance to.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.generate_cases(pseudo)","title":"<code>pseudo</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If pseudo-random (i.e. repeatable cases) to be produced, otherwise truly random.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.global_distribution","title":"global_distribution","text":"<pre><code>global_distribution() -&gt; DataFrame\n</code></pre> <p>Generate the global probability distribution for the BN.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Global distribution in descending probability (and then by</p> </li> <li> <code>DataFrame</code>           \u2013            <p>ascending values).</p> </li> </ul>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.lnprob_case","title":"lnprob_case","text":"<pre><code>lnprob_case(case_values: Dict[str, Any], base: Union[int, str] = 10) -&gt; Optional[float]\n</code></pre> <p>Return log of probability of set of node values (case) occuring.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[float]</code>           \u2013            <p>Log of probability of case occuring, or None if case has zero</p> </li> <li> <code>Optional[float]</code>           \u2013            <p>probability.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid values.</p> </li> </ul>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.lnprob_case(case_values)","title":"<code>case_values</code>","text":"(<code>Dict[str, Any]</code>)           \u2013            <p>Value for each node {node: value}.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.lnprob_case(base)","title":"<code>base</code>","text":"(<code>Union[int, str]</code>, default:                   <code>10</code> )           \u2013            <p>Logarithm base to use - 2, 10 or 'e'.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.marginal_distribution","title":"marginal_distribution","text":"<pre><code>marginal_distribution(node: str, parents: Optional[List[str]] = None) -&gt; DataFrame\n</code></pre> <p>Generate a marginal probability distribution for a specified node and its parents in same format returned by Panda crosstab function.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Marginal distribution with parental value combos as columns,</p> </li> <li> <code>DataFrame</code>           \u2013            <p>and node values as rows.</p> </li> </ul>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.marginal_distribution(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node for which distribution required.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.marginal_distribution(parents)","title":"<code>parents</code>","text":"(<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Parents of node.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.marginals","title":"marginals","text":"<pre><code>marginals(nodes: List[str]) -&gt; DataFrame\n</code></pre> <p>Return marginal distribution for specified nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Marginal distribution in same format returned by Pandas</p> </li> <li> <code>DataFrame</code>           \u2013            <p>crosstab function.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have bad type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments contain bad values.</p> </li> </ul>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.marginals(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes for which marginal distribution required.</p>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.rename","title":"rename","text":"<pre><code>rename(name_map: Dict[str, str]) -&gt; None\n</code></pre> <p>Rename nodes in place according to name map.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values e.g. unknown node names.</p> </li> </ul>"},{"location":"api/bn_bn/#causaliq_core.bn.bn.BN.rename(name_map)","title":"<code>name_map</code>","text":"(<code>Dict[str, str]</code>)           \u2013            <p>Name mapping {name: new name}.</p>"},{"location":"api/bn_bnfit/","title":"BNFit Class","text":"<p>The <code>BNFit</code> class represents a fitted Bayesian Network with parameters learned from data. It provides convenient access to the learned conditional distributions and enables evaluation of the fitted model.</p>"},{"location":"api/bn_bnfit/#overview","title":"Overview","text":"<p>A <code>BNFit</code> object is typically created as a result of parameter learning using the <code>BN.fit()</code> method. It contains:</p> <ul> <li>The original DAG structure from the parent BN</li> <li>Learned conditional distributions with parameters fitted to data  </li> <li>Metadata about the fitting process (e.g., number of estimated PMFs)</li> </ul>"},{"location":"api/bn_bnfit/#key-features","title":"Key Features","text":"<ul> <li>Access to Fitted Parameters: Direct access to learned conditional distributions</li> <li>Model Evaluation: Methods for assessing fit quality and making predictions</li> <li>Serialization: Save and load fitted models</li> <li>Integration: Works seamlessly with the broader BN ecosystem</li> </ul>"},{"location":"api/bn_bnfit/#usage-patterns","title":"Usage Patterns","text":"<p>The <code>BNFit</code> class is primarily used for:</p> <ul> <li>Model Inspection: Examining learned parameters and distributions</li> <li>Prediction: Making probabilistic predictions on new data</li> <li>Model Persistence: Saving fitted models for later use</li> <li>Model Comparison: Comparing different fitted models</li> </ul>"},{"location":"api/bn_bnfit/#example-usage","title":"Example Usage","text":"<pre><code>from causaliq_core.bn import BN, CPT\nfrom causaliq_core.graph import DAG\nimport pandas as pd\n\n# Create a BN structure\ndag = DAG(['A', 'B', 'C'], [('A', 'B'), ('B', 'C')])\ncnd_specs = {\n    'A': CPT(values=['T', 'F']),\n    'B': CPT(values=['T', 'F'], parents=['A']),  \n    'C': CPT(values=['T', 'F'], parents=['B'])\n}\n\nbn = BN(dag, cnd_specs)\n\n# Prepare training data\ndata = pd.DataFrame({\n    'A': ['T', 'F', 'T', 'F', 'T'],\n    'B': ['T', 'F', 'T', 'T', 'F'], \n    'C': ['T', 'F', 'T', 'T', 'F']\n})\n\n# Fit the model\nfitted_bn = BN.fit(bn.dag, data)\n\n# Access fitted distributions\nprint(\"Fitted CPT for node B:\")\nprint(fitted_bn.cnds['B'])\n\n# Examine model structure\nprint(f\"Number of free parameters: {fitted_bn.free_params}\")\nprint(f\"Nodes: {list(fitted_bn.cnds.keys())}\")\n</code></pre>"},{"location":"api/bn_bnfit/#relationship-to-bn-class","title":"Relationship to BN Class","text":"<p>The <code>BNFit</code> class is closely related to the <code>BN</code> class:</p> <ul> <li>BN: Represents a network structure with specified or unspecified parameters</li> <li>BNFit: Represents a network with parameters learned from data</li> <li>Conversion: BNFit objects can be used wherever BN objects are expected</li> </ul>"},{"location":"api/bn_bnfit/#api-reference","title":"API Reference","text":""},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit","title":"BNFit","text":"<p>Interface for Bayesian Network parameter estimation and data access.</p> <p>This interface provides the essential methods required for fitting conditional probability tables (CPT) and linear Gaussian models in Bayesian Networks, as well as data access methods for the BN class.</p> <p>Implementing classes should provide: - A constructor that accepts df=DataFrame parameter for BN compatibility - All abstract methods defined below - Properties for data access (.nodes, .sample, .node_types)</p> <p>Methods:</p> <ul> <li> <code>marginals</code>             \u2013              <p>Return marginal counts for a node and its parents.</p> </li> <li> <code>values</code>             \u2013              <p>Return the (float) values for specified nodes.</p> </li> <li> <code>write</code>             \u2013              <p>Write data to file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>Total sample size.</p> </li> <li> <code>node_types</code>               (<code>Dict[str, str]</code>)           \u2013            <p>Node type mapping for each variable.</p> </li> <li> <code>node_values</code>               (<code>Dict[str, Dict]</code>)           \u2013            <p>Node value counts for categorical variables.</p> </li> <li> <code>nodes</code>               (<code>Tuple[str, ...]</code>)           \u2013            <p>Column names in the dataset.</p> </li> <li> <code>sample</code>               (<code>Any</code>)           \u2013            <p>Access to underlying data sample.</p> </li> </ul>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.N","title":"N  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<pre><code>N: int\n</code></pre> <p>Total sample size.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Current sample size being used.</p> </li> </ul>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.node_types","title":"node_types  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>node_types: Dict[str, str]\n</code></pre> <p>Node type mapping for each variable.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dictionary mapping node names to their types.</p> </li> <li> <code>Format</code> (              <code>Dict[str, str]</code> )          \u2013            <p>{node: 'category' | 'continuous'}</p> </li> </ul>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.node_values","title":"node_values  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<pre><code>node_values: Dict[str, Dict]\n</code></pre> <p>Node value counts for categorical variables.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Dict]</code>           \u2013            <p>Values and their counts of categorical nodes in sample.</p> </li> <li> <code>Format</code> (              <code>Dict[str, Dict]</code> )          \u2013            <p>{node1: {val1: count1, val2: count2, ...}, ...}</p> </li> </ul>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.nodes","title":"nodes  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>nodes: Tuple[str, ...]\n</code></pre> <p>Column names in the dataset.</p> <p>Returns:</p> <ul> <li> <code>Tuple[str, ...]</code>           \u2013            <p>Tuple of node names (column names) in the dataset.</p> </li> </ul>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.sample","title":"sample  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>sample: Any\n</code></pre> <p>Access to underlying data sample.</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The underlying DataFrame or data structure for direct access.</p> </li> <li> <code>Any</code>           \u2013            <p>Used for operations like .unique() on columns.</p> </li> </ul>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.marginals","title":"marginals  <code>abstractmethod</code>","text":"<pre><code>marginals(node: str, parents: Dict, values_reqd: bool = False) -&gt; Tuple\n</code></pre> <p>Return marginal counts for a node and its parents.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple</code>           \u2013            <p>Tuple of counts, and optionally, values:</p> </li> <li> <code>Tuple</code>           \u2013            <ul> <li>ndarray counts: 2D array, rows=child, cols=parents</li> </ul> </li> <li> <code>Tuple</code>           \u2013            <ul> <li>int maxcol: Maximum number of parental values</li> </ul> </li> <li> <code>Tuple</code>           \u2013            <ul> <li>tuple rowval: Child values for each row</li> </ul> </li> <li> <code>Tuple</code>           \u2013            <ul> <li>tuple colval: Parent combo (dict) for each col</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>For bad argument types.</p> </li> </ul>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.marginals(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node for which marginals required.</p>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.marginals(parents)","title":"<code>parents</code>","text":"(<code>Dict</code>)           \u2013            <p>Dictionary {node: parents} for non-orphan nodes.</p>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.marginals(values_reqd)","title":"<code>values_reqd</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether parent and child values required.</p>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.values","title":"values  <code>abstractmethod</code>","text":"<pre><code>values(nodes: Tuple[str, ...]) -&gt; ndarray\n</code></pre> <p>Return the (float) values for specified nodes.</p> <p>Suitable for passing into e.g. linear regression fitting.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Numpy array of values, each column for a node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad argument type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If bad argument value.</p> </li> </ul>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.values(nodes)","title":"<code>nodes</code>","text":"(<code>Tuple[str, ...]</code>)           \u2013            <p>Nodes for which data required.</p>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.write","title":"write  <code>abstractmethod</code>","text":"<pre><code>write(filename: str) -&gt; None\n</code></pre> <p>Write data to file.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If filename is not a string.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If output directory doesn't exist.</p> </li> </ul>"},{"location":"api/bn_bnfit/#causaliq_core.bn.bnfit.BNFit.write(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>Path to output file.</p>"},{"location":"api/bn_dist/","title":"Distribution Classes","text":"<p>The distribution module provides conditional node distribution (CND) classes for representing local probability distributions in Bayesian Networks. These classes define how each node's values depend on its parents in the network.</p>"},{"location":"api/bn_dist/#overview","title":"Overview","text":"<p>The distribution classes implement different types of conditional probability distributions:</p> <ul> <li>CPT: Discrete conditional probability tables for categorical variables</li> <li>LinGauss: Linear Gaussian distributions for continuous variables  </li> <li>CND: Abstract base class defining the common interface</li> </ul>"},{"location":"api/bn_dist/#distribution-types","title":"Distribution Types","text":""},{"location":"api/bn_dist/#conditional-probability-tables-cpt","title":"Conditional Probability Tables (CPT)","text":"<p>Used for discrete/categorical variables. Stores probability tables that map parent value combinations to child value probabilities.</p> <p>Key Features:</p> <ul> <li>Support for multiple discrete parent variables</li> <li>Efficient storage and lookup of probability values</li> <li>Automatic normalization and validation</li> <li>Missing data handling</li> </ul>"},{"location":"api/bn_dist/#linear-gaussian-lingauss","title":"Linear Gaussian (LinGauss)","text":"<p>Used for continuous variables that follow normal distributions with linear dependencies on parents.</p> <p>Key Features:</p> <ul> <li>Linear regression relationships with parent variables</li> <li>Support for both continuous and discrete parent variables</li> <li>Gaussian noise modeling</li> <li>Parameter estimation from data</li> </ul>"},{"location":"api/bn_dist/#base-class-cnd","title":"Base Class (CND)","text":"<p>Abstract base class that defines the common interface for all conditional node distributions.</p> <p>Key Features:</p> <ul> <li>Common methods for probability computation</li> <li>Standardized parameter access</li> <li>Consistent serialization interface</li> <li>Type checking and validation</li> </ul>"},{"location":"api/bn_dist/#common-operations","title":"Common Operations","text":"<p>All distribution classes support common operations:</p> <ul> <li>Probability Evaluation: Computing P(child | parents)</li> <li>Sampling: Generating samples from the distribution</li> <li>Parameter Access: Getting and setting distribution parameters</li> <li>Validation: Checking parameter consistency</li> </ul>"},{"location":"api/bn_dist/#example-usage","title":"Example Usage","text":"<pre><code>from causaliq_core.bn.dist import CPT, LinGauss\n\n# Create discrete distribution (CPT)\nweather_dist = CPT(\n    values=['Sunny', 'Rainy'], \n    table=[0.7, 0.3]  # P(Weather=Sunny)=0.7, P(Weather=Rainy)=0.3\n)\n\n# Create conditional discrete distribution\nsprinkler_dist = CPT(\n    values=['On', 'Off'],\n    table=[0.1, 0.9, 0.8, 0.2],  # Depends on Weather\n    parents=['Weather']\n)\n\n# Create continuous distribution\ntemperature_dist = LinGauss(\n    mean=20.0,      # Base temperature\n    sd=2.0,         # Standard deviation  \n    coeffs={},      # No parent dependencies in this example\n    parents=[]\n)\n</code></pre>"},{"location":"api/bn_dist/#distribution-selection","title":"Distribution Selection","text":"<p>Choose the appropriate distribution type based on your variable characteristics:</p> <ul> <li>Use CPT for categorical/discrete variables (e.g., weather conditions, disease status)</li> <li>Use LinGauss for continuous variables with linear relationships (e.g., temperature, measurements)</li> </ul>"},{"location":"api/bn_dist/#api-reference","title":"API Reference","text":""},{"location":"api/bn_dist/#causaliq_core.bn.dist","title":"dist","text":"<p>Distribution classes for Bayesian Network nodes.</p> <p>This module contains conditional node distribution (CND) implementations including the abstract base class and concrete implementations like Linear Gaussian distributions and Conditional Probability Tables.</p> <p>Modules:</p> <ul> <li> <code>cnd</code>           \u2013            </li> <li> <code>cpt</code>           \u2013            </li> <li> <code>lingauss</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>CND</code>           \u2013            <p>Conditional Node Distribution for a node conditional on parental values.</p> </li> <li> <code>CPT</code>           \u2013            <p>Base class for conditional probability tables.</p> </li> <li> <code>LinGauss</code>           \u2013            <p>Conditional Linear Gaussian Distribution.</p> </li> <li> <code>NodeValueCombinations</code>           \u2013            <p>Iterable over all combinations of node values</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND","title":"CND","text":"<pre><code>CND()\n</code></pre> <p>Conditional Node Distribution for a node conditional on parental values.</p> <p>Concrete subclasses support specific kinds of distributions, for example, CPT (multinomial), LinearGaussian etc.</p> <p>Attributes:</p> <ul> <li> <code>has_parents</code>               (<code>bool</code>)           \u2013            <p>Whether CND is for a node with parents.</p> </li> <li> <code>free_params</code>               (<code>int</code>)           \u2013            <p>Number of free params in CND.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Return whether two CNDs are the same allowing for</p> </li> <li> <code>__str__</code>             \u2013              <p>Human-friendly description of the contents of the CND.</p> </li> <li> <code>cdist</code>             \u2013              <p>Return conditional distribution for specified parental values.</p> </li> <li> <code>fit</code>             \u2013              <p>Constructs a CND (Conditional Node Distribution) from data.</p> </li> <li> <code>parents</code>             \u2013              <p>Return parents of node CND relates to.</p> </li> <li> <code>random_value</code>             \u2013              <p>Generate a random value for a node given the value of its parents.</p> </li> <li> <code>to_spec</code>             \u2013              <p>Returns external specification format of CND,</p> </li> <li> <code>validate_cnds</code>             \u2013              <p>Checks that all CNDs in graph are consistent with one another</p> </li> <li> <code>validate_parents</code>             \u2013              <p>Checks every CND's parents and (categorical) parental values</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.__eq__","title":"__eq__  <code>abstractmethod</code>","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether two CNDs are the same allowing for probability rounding errors.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>Whether CPTs are PRACTICALLY the same.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.__eq__(other)","title":"<code>other</code>","text":"(<code>CND</code>)           \u2013            <p>CND to compared to self.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.__str__","title":"__str__  <code>abstractmethod</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Human-friendly description of the contents of the CND.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.cdist","title":"cdist  <code>abstractmethod</code>","text":"<pre><code>cdist(parental_values: Optional[Dict[str, Any]] = None) -&gt; Any\n</code></pre> <p>Return conditional distribution for specified parental values.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If args are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If args have invalid or conflicting values.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.cdist(parental_values)","title":"<code>parental_values</code>","text":"(<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Parental values for which dist. required for non-orphans.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.fit","title":"fit  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>fit(\n    node: str, parents: Optional[Tuple[str, ...]], data: Any, autocomplete: bool = True\n) -&gt; Tuple[Tuple[type, Dict[str, Any]], Optional[int]]\n</code></pre> <p>Constructs a CND (Conditional Node Distribution) from data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>Tuple[Tuple[type, Dict[str, Any]], Optional[int]]</code> )          \u2013            <p>(cnd_spec, estimated_pmfs) where cnd_spec is (CPT class, cpt_spec for CPT()) estimated_pmfs int/None - only for CPTs.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.fit(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node that CND applies to.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.fit(parents)","title":"<code>parents</code>","text":"(<code>tuple</code>)           \u2013            <p>Parents of node.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.fit(data)","title":"<code>data</code>","text":"(<code>Data</code>)           \u2013            <p>Data to fit CND to.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.fit(autocomplete)","title":"<code>autocomplete</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether complete CPT tables.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.parents","title":"parents  <code>abstractmethod</code>","text":"<pre><code>parents() -&gt; List[str]\n</code></pre> <p>Return parents of node CND relates to.</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>List[str]</code> )          \u2013            <p>Parent node names in alphabetical order.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.random_value","title":"random_value  <code>abstractmethod</code>","text":"<pre><code>random_value(pvs: Optional[Dict[str, Any]]) -&gt; Union[str, float]\n</code></pre> <p>Generate a random value for a node given the value of its parents.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union[str, float]</code>           \u2013            <p>str or float: Random value for node.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.random_value(pvs)","title":"<code>pvs</code>","text":"(<code>dict</code>)           \u2013            <p>Parental values, {parent1: value1, ...}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.to_spec","title":"to_spec  <code>abstractmethod</code>","text":"<pre><code>to_spec(name_map: Dict[str, str]) -&gt; Dict[str, Any]\n</code></pre> <p>Returns external specification format of CND, renaming nodes according to a name map.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>Dict[str, Any]</code> )          \u2013            <p>CND specification with renamed nodes.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.to_spec(name_map)","title":"<code>name_map</code>","text":"(<code>dict</code>)           \u2013            <p>Map of node names {old: new}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.validate_cnds","title":"validate_cnds  <code>classmethod</code>","text":"<pre><code>validate_cnds(\n    nodes: List[str], cnds: Dict[str, CND], parents: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Checks that all CNDs in graph are consistent with one another and with graph structure.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If invalid types used in arguments.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If any inconsistent values found.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.validate_cnds(nodes)","title":"<code>nodes</code>","text":"(<code>list</code>)           \u2013            <p>BN nodes.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.validate_cnds(cnds)","title":"<code>cnds</code>","text":"(<code>dict</code>)           \u2013            <p>Set of CNDs for the BN, {node: cnd}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.validate_cnds(parents)","title":"<code>parents</code>","text":"(<code>dict</code>)           \u2013            <p>Parents of non-orphan nodes, {node: parents}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.validate_parents","title":"validate_parents  <code>abstractmethod</code>","text":"<pre><code>validate_parents(\n    node: str, parents: Dict[str, List[str]], node_values: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Checks every CND's parents and (categorical) parental values are consistent.</p> <p>Validates consistency with the other relevant CNDs and the DAG structure.</p> <p>Parameters:</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.validate_parents(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Name of node.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.validate_parents(parents)","title":"<code>parents</code>","text":"(<code>dict</code>)           \u2013            <p>Parents of all nodes {node: parents}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CND.validate_parents(node_values)","title":"<code>node_values</code>","text":"(<code>dict</code>)           \u2013            <p>Values of each cat. node {node: values}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT","title":"CPT","text":"<pre><code>CPT(\n    pmfs: Union[Dict[str, float], List[Tuple[Dict[str, str], Dict[str, float]]]],\n    estimated: int = 0,\n)\n</code></pre> <p>Base class for conditional probability tables.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>cpt</code>           \u2013            <p>Internal representation of the CPT. {node_values: prob} for parentless node, otherwise {parental_values as frozenset: {node_values: prob}}.</p> </li> <li> <code>estimated</code>           \u2013            <p>Number of PMFs that were estimated.</p> </li> <li> <code>values</code>           \u2013            <p>Values which node can take.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid or conflicting values.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Return whether two CPTs are the same allowing for probability</p> </li> <li> <code>__str__</code>             \u2013              <p>Human-friendly description of the contents of the CPT.</p> </li> <li> <code>cdist</code>             \u2013              <p>Return conditional probabilities of node values for specified</p> </li> <li> <code>fit</code>             \u2013              <p>Constructs a CPT (Conditional Probability Table) from data.</p> </li> <li> <code>node_values</code>             \u2013              <p>Return node values (states) of node CPT relates to.</p> </li> <li> <code>param_ratios</code>             \u2013              <p>Returns distribution of parameter ratios across all parental</p> </li> <li> <code>parents</code>             \u2013              <p>Return parents of node CPT relates to.</p> </li> <li> <code>random_value</code>             \u2013              <p>Generate a random value for a node given the value of its parents.</p> </li> <li> <code>to_spec</code>             \u2013              <p>Returns external specification format of CPT,</p> </li> <li> <code>validate_cnds</code>             \u2013              <p>Checks that all CNDs in graph are consistent with one another</p> </li> <li> <code>validate_parents</code>             \u2013              <p>Checks every CPT's parents and parental values are consistent</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT(pmfs)","title":"<code>pmfs</code>","text":"(<code>Union[Dict[str, float], List[Tuple[Dict[str, str], Dict[str, float]]]]</code>)           \u2013            <p>A pmf of {value: prob} for parentless nodes OR list of tuples ({parent: value}, {value: prob}).</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT(estimated)","title":"<code>estimated</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>How many PMFs were estimated.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether two CPTs are the same allowing for probability rounding errors</p> <p>:param other: CPT to compared to self :type other: CPT</p> <p>:returns: whether CPTs are PRACTICALLY the same :rtype: bool</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Human-friendly description of the contents of the CPT.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the CPT contents.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.cdist","title":"cdist","text":"<pre><code>cdist(parental_values: Optional[Dict[str, str]] = None) -&gt; Dict[str, float]\n</code></pre> <p>Return conditional probabilities of node values for specified parental values.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If args are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If args have invalid or conflicting values.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.cdist(parental_values)","title":"<code>parental_values</code>","text":"(<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>Parental values for which pmf required</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.fit","title":"fit  <code>classmethod</code>","text":"<pre><code>fit(\n    node: str,\n    parents: Optional[Tuple[str, ...]],\n    data: Union[BNFit, Any],\n    autocomplete: bool = True,\n) -&gt; Tuple[Tuple[type, Dict[str, Any]], Optional[int]]\n</code></pre> <p>Constructs a CPT (Conditional Probability Table) from data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple[type, Dict[str, Any]]</code>           \u2013            <p>Tuple of (cnd_spec, estimated_pmfs) where</p> </li> <li> <code>Optional[int]</code>           \u2013            <p>cnd_spec is (CPT class, cpt_spec for CPT())</p> </li> <li> <code>Tuple[Tuple[type, Dict[str, Any]], Optional[int]]</code>           \u2013            <p>estimated_pmfs is int, # estimated pmfs.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.fit(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node that CPT applies to.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.fit(parents)","title":"<code>parents</code>","text":"(<code>Optional[Tuple[str, ...]]</code>)           \u2013            <p>Parents of node.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.fit(data)","title":"<code>data</code>","text":"(<code>Union[BNFit, Any]</code>)           \u2013            <p>Data to fit CPT to.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.fit(autocomplete)","title":"<code>autocomplete</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to ensure CPT data contains entries for</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.node_values","title":"node_values","text":"<pre><code>node_values() -&gt; List[str]\n</code></pre> <p>Return node values (states) of node CPT relates to.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>Node values in alphabetical order.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.param_ratios","title":"param_ratios","text":"<pre><code>param_ratios() -&gt; None\n</code></pre> <p>Returns distribution of parameter ratios across all parental values for each combination of possible node values.</p> <p>:returns dict: {(node value pair): (param ratios across parents)</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.parents","title":"parents","text":"<pre><code>parents() -&gt; List[str]\n</code></pre> <p>Return parents of node CPT relates to.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>Parent node names in alphabetical order.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.random_value","title":"random_value","text":"<pre><code>random_value(pvs: Optional[Dict[str, str]]) -&gt; str\n</code></pre> <p>Generate a random value for a node given the value of its parents.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Random value for node.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.random_value(pvs)","title":"<code>pvs</code>","text":"(<code>Optional[Dict[str, str]]</code>)           \u2013            <p>Parental values, {parent1: value1, ...}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.to_spec","title":"to_spec","text":"<pre><code>to_spec(name_map: Dict[str, str]) -&gt; Dict[str, Any]\n</code></pre> <p>Returns external specification format of CPT, renaming nodes according to a name map.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>CPT specification with renamed nodes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If bad arg value, e.g. coeff keys not in map.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.to_spec(name_map)","title":"<code>name_map</code>","text":"(<code>Dict[str, str]</code>)           \u2013            <p>Map of node names {old: new}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.validate_cnds","title":"validate_cnds  <code>classmethod</code>","text":"<pre><code>validate_cnds(\n    nodes: List[str], cnds: Dict[str, CND], parents: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Checks that all CNDs in graph are consistent with one another and with graph structure.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If invalid types used in arguments.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If any inconsistent values found.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.validate_cnds(nodes)","title":"<code>nodes</code>","text":"(<code>list</code>)           \u2013            <p>BN nodes.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.validate_cnds(cnds)","title":"<code>cnds</code>","text":"(<code>dict</code>)           \u2013            <p>Set of CNDs for the BN, {node: cnd}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.validate_cnds(parents)","title":"<code>parents</code>","text":"(<code>dict</code>)           \u2013            <p>Parents of non-orphan nodes, {node: parents}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.validate_parents","title":"validate_parents","text":"<pre><code>validate_parents(\n    node: str, parents: Dict[str, List[str]], node_values: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Checks every CPT's parents and parental values are consistent with other relevant CPTs and the DAG structure.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If parent mismatch or missing parental</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.validate_parents(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Name of node.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.validate_parents(parents)","title":"<code>parents</code>","text":"(<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of all nodes {node: parents}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.CPT.validate_parents(node_values)","title":"<code>node_values</code>","text":"(<code>Dict[str, List[str]]</code>)           \u2013            <p>Values of each cat. node {node: values}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss","title":"LinGauss","text":"<pre><code>LinGauss(lg: Dict[str, Any])\n</code></pre> <p>Conditional Linear Gaussian Distribution.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>coeffs</code>           \u2013            <p>Linear coefficient of parents {parent: coeff}.</p> </li> <li> <code>mean</code>           \u2013            <p>Mean of Gaussian noise (aka intercept, mu).</p> </li> <li> <code>sd</code>           \u2013            <p>S.D. of Gaussian noise (aka sigma).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If called with bad arg types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If called with bad arg values.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Return whether two CNDs are the same allowing for probability</p> </li> <li> <code>__str__</code>             \u2013              <p>Human-friendly formula description of the Linear Gaussian.</p> </li> <li> <code>cdist</code>             \u2013              <p>Return conditional distribution for specified parental values.</p> </li> <li> <code>fit</code>             \u2013              <p>Fit a Linear Gaussian to data.</p> </li> <li> <code>parents</code>             \u2013              <p>Return parents of node CND relates to.</p> </li> <li> <code>random_value</code>             \u2013              <p>Generate a random value for a node given the value of its parents.</p> </li> <li> <code>to_spec</code>             \u2013              <p>Returns external specification format of LinGauss,</p> </li> <li> <code>validate_parents</code>             \u2013              <p>Check LinGauss coeff keys consistent with parents in DAG.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss(lg)","title":"<code>lg</code>","text":"(<code>Dict[str, Any]</code>)           \u2013            <p>Specification of Linear Gaussian in following form: {'coeffs': {node: coeff}, 'mean': mean, 'sd': sd}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether two CNDs are the same allowing for probability rounding errors</p> <p>:param CND other: CND to compared to self</p> <p>:returns bool: whether LinGauss objects are the same up to 10 sf</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Human-friendly formula description of the Linear Gaussian.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the Linear Gaussian formula.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.cdist","title":"cdist","text":"<pre><code>cdist(parental_values: Optional[Dict[str, float]] = None) -&gt; Tuple[float, float]\n</code></pre> <p>Return conditional distribution for specified parental values.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float]</code>           \u2013            <p>Tuple of (mean, sd) of child Gaussian distribution.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If args are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If args have invalid or conflicting values.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.cdist(parental_values)","title":"<code>parental_values</code>","text":"(<code>Optional[Dict[str, float]]</code>, default:                   <code>None</code> )           \u2013            <p>Parental values for which dist. required</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.fit","title":"fit  <code>classmethod</code>","text":"<pre><code>fit(\n    node: str,\n    parents: Optional[Tuple[str, ...]],\n    data: Union[Pandas, BNFit],\n    autocomplete: bool = True,\n) -&gt; Tuple[Tuple[type, Dict[str, Any]], Optional[int]]\n</code></pre> <p>Fit a Linear Gaussian to data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple[Tuple[type, Dict[str, Any]], Optional[int]]</code>           \u2013            <p>Tuple of (lg_spec, None) where lg is (LinGauss class, lg_spec).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.fit(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node that Linear Gaussian applies to.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.fit(parents)","title":"<code>parents</code>","text":"(<code>Optional[Tuple[str, ...]]</code>)           \u2013            <p>Parents of node.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.fit(data)","title":"<code>data</code>","text":"(<code>Union[Pandas, BNFit]</code>)           \u2013            <p>Data to fit Linear Gaussian to.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.fit(autocomplete)","title":"<code>autocomplete</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not used for Linear Gaussian.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.parents","title":"parents","text":"<pre><code>parents() -&gt; List[str]\n</code></pre> <p>Return parents of node CND relates to.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>Parent node names in alphabetical order.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.random_value","title":"random_value","text":"<pre><code>random_value(pvs: Optional[Dict[str, float]]) -&gt; float\n</code></pre> <p>Generate a random value for a node given the value of its parents.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Random value for node.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.random_value(pvs)","title":"<code>pvs</code>","text":"(<code>Optional[Dict[str, float]]</code>)           \u2013            <p>Parental values, {parent1: value1, ...}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.to_spec","title":"to_spec","text":"<pre><code>to_spec(name_map: Dict[str, str]) -&gt; Dict[str, Any]\n</code></pre> <p>Returns external specification format of LinGauss, renaming nodes according to a name map.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>LinGauss specification with renamed nodes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If bad arg value, e.g. coeff keys not in map.</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.to_spec(name_map)","title":"<code>name_map</code>","text":"(<code>Dict[str, str]</code>)           \u2013            <p>Map of node names {old: new}.</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.LinGauss.validate_parents","title":"validate_parents","text":"<pre><code>validate_parents(\n    node: str, parents: Dict[str, List[str]], node_values: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Check LinGauss coeff keys consistent with parents in DAG.</p> <p>:param str node: name of node :param dict parents: parents of all nodes defined in DAG :param dict node_values: values of each cat. node [UNUSED]</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.NodeValueCombinations","title":"NodeValueCombinations","text":"<pre><code>NodeValueCombinations(node_values: Dict[str, List[str]], sort: bool = True)\n</code></pre> <p>Iterable over all combinations of node values</p> <p>:param dict node_values: allowed values for each node {node: [values]} :param bool sort: whether to sort node names and values into                   alphabetic order</p> <p>Methods:</p> <ul> <li> <code>__iter__</code>             \u2013              <p>Returns the initialised iterator</p> </li> <li> <code>__next__</code>             \u2013              <p>Generate the next node value combination</p> </li> </ul>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.NodeValueCombinations.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; NodeValueCombinations\n</code></pre> <p>Returns the initialised iterator</p> <p>:returns NodeValueCombinations: the iterator</p>"},{"location":"api/bn_dist/#causaliq_core.bn.dist.NodeValueCombinations.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; Dict[str, str]\n</code></pre> <p>Generate the next node value combination</p> <p>:raises StopIteration: when all combinations have been returned</p> <p>:returns dict: next node value combination {node: value}</p>"},{"location":"api/bn_dist_cnd/","title":"CND (Conditional Node Distribution) Base Class","text":"<p>The <code>CND</code> class is the abstract base class for all conditional node distributions in Bayesian Networks. It defines the common interface and functionality that all distribution types must implement.</p>"},{"location":"api/bn_dist_cnd/#overview","title":"Overview","text":"<p>The <code>CND</code> class establishes a consistent interface for:</p> <ul> <li>Probability Computation: Methods for evaluating probabilities and densities</li> <li>Parameter Access: Standardized ways to get and set distribution parameters  </li> <li>Validation: Common validation and consistency checking</li> <li>Serialization: Uniform methods for saving and loading distributions</li> <li>Type System: Ensures all distributions work consistently within BNs</li> </ul>"},{"location":"api/bn_dist_cnd/#abstract-interface","title":"Abstract Interface","text":"<p>All concrete distribution classes (CPT, LinGauss) must implement the CND interface:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass CND(ABC):\n    @abstractmethod\n    def prob(self, value, parents_values=None):\n        \"\"\"Compute probability/density for given value and parent values.\"\"\"\n        pass\n\n    @abstractmethod  \n    def sample(self, parents_values=None):\n        \"\"\"Generate a sample from the distribution.\"\"\"\n        pass\n\n    @abstractmethod\n    def validate(self):\n        \"\"\"Check distribution parameters for consistency.\"\"\"\n        pass\n</code></pre>"},{"location":"api/bn_dist_cnd/#common-attributes","title":"Common Attributes","text":"<p>All CND instances provide:</p> <ul> <li><code>parents</code>: List of parent variable names</li> <li><code>node_type</code>: Type of distribution ('discrete' or 'continuous')  </li> <li><code>param_count</code>: Number of free parameters in the distribution</li> </ul>"},{"location":"api/bn_dist_cnd/#usage-patterns","title":"Usage Patterns","text":"<p>The CND base class is typically used for:</p> <ul> <li>Type Checking: Ensuring objects are valid distributions</li> <li>Polymorphism: Writing code that works with any distribution type</li> <li>Interface Definition: Understanding what methods distributions provide</li> <li>Extension: Creating new distribution types</li> </ul>"},{"location":"api/bn_dist_cnd/#example-usage","title":"Example Usage","text":"<pre><code>from causaliq_core.bn.dist import CPT, LinGauss, CND\n\n# Create different distribution types\ndiscrete_dist = CPT(values=['A', 'B'], table=[0.3, 0.7])\ncontinuous_dist = LinGauss(mean=0.0, sd=1.0, coeffs={}, parents=[])\n\n# Both implement the CND interface\ndistributions = [discrete_dist, continuous_dist]\n\nfor dist in distributions:\n    assert isinstance(dist, CND)  # Type checking\n\n    # Common interface methods\n    sample = dist.sample()  # Generate sample\n    dist.validate()         # Check consistency\n\n    print(f\"Distribution type: {dist.node_type}\")\n    print(f\"Parameter count: {dist.param_count}\")\n    print(f\"Sample: {sample}\")\n</code></pre>"},{"location":"api/bn_dist_cnd/#implementing-custom-distributions","title":"Implementing Custom Distributions","text":"<p>To create a new distribution type, inherit from CND and implement the abstract methods:</p> <pre><code>from causaliq_core.bn.dist.cnd import CND\nimport random\n\nclass BernoulliDistribution(CND):\n    \"\"\"Custom Bernoulli distribution example.\"\"\"\n\n    def __init__(self, p=0.5, parents=None):\n        self.p = p\n        self.parents = parents or []\n        self.node_type = 'discrete'\n\n    def prob(self, value, parents_values=None):\n        \"\"\"Compute probability for Bernoulli distribution.\"\"\"\n        if value == 1:\n            return self.p\n        elif value == 0:\n            return 1 - self.p\n        else:\n            return 0.0\n\n    def sample(self, parents_values=None):\n        \"\"\"Generate Bernoulli sample.\"\"\"\n        return 1 if random.random() &lt; self.p else 0\n\n    def validate(self):\n        \"\"\"Check parameter validity.\"\"\"\n        if not 0 &lt;= self.p &lt;= 1:\n            raise ValueError(\"Bernoulli parameter must be in [0,1]\")\n\n    @property\n    def param_count(self):\n        return 1  # One free parameter (p)\n\n# Use custom distribution\ncustom_dist = BernoulliDistribution(p=0.3)\nassert isinstance(custom_dist, CND)\nsample = custom_dist.sample()\n</code></pre>"},{"location":"api/bn_dist_cnd/#validation-framework","title":"Validation Framework","text":"<p>The CND base class provides a validation framework that:</p> <ul> <li>Parameter Checking: Ensures parameters are in valid ranges</li> <li>Consistency Validation: Checks internal consistency of distributions</li> <li>Parent Validation: Verifies parent relationships are valid</li> <li>Error Reporting: Provides clear error messages for invalid configurations</li> </ul>"},{"location":"api/bn_dist_cnd/#integration-with-bn-class","title":"Integration with BN Class","text":"<p>The CND interface ensures that:</p> <ul> <li>Any CND subclass can be used in a BN</li> <li>Probabilistic inference works consistently across distribution types</li> <li>Parameter learning follows the same patterns</li> <li>Serialization and I/O operations are uniform</li> </ul>"},{"location":"api/bn_dist_cnd/#api-reference","title":"API Reference","text":""},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd","title":"cnd","text":"<p>Classes:</p> <ul> <li> <code>CND</code>           \u2013            <p>Conditional Node Distribution for a node conditional on parental values.</p> </li> </ul>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND","title":"CND","text":"<pre><code>CND()\n</code></pre> <p>Conditional Node Distribution for a node conditional on parental values.</p> <p>Concrete subclasses support specific kinds of distributions, for example, CPT (multinomial), LinearGaussian etc.</p> <p>Attributes:</p> <ul> <li> <code>has_parents</code>               (<code>bool</code>)           \u2013            <p>Whether CND is for a node with parents.</p> </li> <li> <code>free_params</code>               (<code>int</code>)           \u2013            <p>Number of free params in CND.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Return whether two CNDs are the same allowing for</p> </li> <li> <code>__str__</code>             \u2013              <p>Human-friendly description of the contents of the CND.</p> </li> <li> <code>cdist</code>             \u2013              <p>Return conditional distribution for specified parental values.</p> </li> <li> <code>fit</code>             \u2013              <p>Constructs a CND (Conditional Node Distribution) from data.</p> </li> <li> <code>parents</code>             \u2013              <p>Return parents of node CND relates to.</p> </li> <li> <code>random_value</code>             \u2013              <p>Generate a random value for a node given the value of its parents.</p> </li> <li> <code>to_spec</code>             \u2013              <p>Returns external specification format of CND,</p> </li> <li> <code>validate_cnds</code>             \u2013              <p>Checks that all CNDs in graph are consistent with one another</p> </li> <li> <code>validate_parents</code>             \u2013              <p>Checks every CND's parents and (categorical) parental values</p> </li> </ul>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.__eq__","title":"__eq__  <code>abstractmethod</code>","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether two CNDs are the same allowing for probability rounding errors.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>Whether CPTs are PRACTICALLY the same.</p> </li> </ul>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.__eq__(other)","title":"<code>other</code>","text":"(<code>CND</code>)           \u2013            <p>CND to compared to self.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.__str__","title":"__str__  <code>abstractmethod</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Human-friendly description of the contents of the CND.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.cdist","title":"cdist  <code>abstractmethod</code>","text":"<pre><code>cdist(parental_values: Optional[Dict[str, Any]] = None) -&gt; Any\n</code></pre> <p>Return conditional distribution for specified parental values.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If args are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If args have invalid or conflicting values.</p> </li> </ul>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.cdist(parental_values)","title":"<code>parental_values</code>","text":"(<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Parental values for which dist. required for non-orphans.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.fit","title":"fit  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>fit(\n    node: str, parents: Optional[Tuple[str, ...]], data: Any, autocomplete: bool = True\n) -&gt; Tuple[Tuple[type, Dict[str, Any]], Optional[int]]\n</code></pre> <p>Constructs a CND (Conditional Node Distribution) from data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>Tuple[Tuple[type, Dict[str, Any]], Optional[int]]</code> )          \u2013            <p>(cnd_spec, estimated_pmfs) where cnd_spec is (CPT class, cpt_spec for CPT()) estimated_pmfs int/None - only for CPTs.</p> </li> </ul>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.fit(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node that CND applies to.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.fit(parents)","title":"<code>parents</code>","text":"(<code>tuple</code>)           \u2013            <p>Parents of node.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.fit(data)","title":"<code>data</code>","text":"(<code>Data</code>)           \u2013            <p>Data to fit CND to.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.fit(autocomplete)","title":"<code>autocomplete</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether complete CPT tables.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.parents","title":"parents  <code>abstractmethod</code>","text":"<pre><code>parents() -&gt; List[str]\n</code></pre> <p>Return parents of node CND relates to.</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>List[str]</code> )          \u2013            <p>Parent node names in alphabetical order.</p> </li> </ul>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.random_value","title":"random_value  <code>abstractmethod</code>","text":"<pre><code>random_value(pvs: Optional[Dict[str, Any]]) -&gt; Union[str, float]\n</code></pre> <p>Generate a random value for a node given the value of its parents.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union[str, float]</code>           \u2013            <p>str or float: Random value for node.</p> </li> </ul>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.random_value(pvs)","title":"<code>pvs</code>","text":"(<code>dict</code>)           \u2013            <p>Parental values, {parent1: value1, ...}.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.to_spec","title":"to_spec  <code>abstractmethod</code>","text":"<pre><code>to_spec(name_map: Dict[str, str]) -&gt; Dict[str, Any]\n</code></pre> <p>Returns external specification format of CND, renaming nodes according to a name map.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>Dict[str, Any]</code> )          \u2013            <p>CND specification with renamed nodes.</p> </li> </ul>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.to_spec(name_map)","title":"<code>name_map</code>","text":"(<code>dict</code>)           \u2013            <p>Map of node names {old: new}.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.validate_cnds","title":"validate_cnds  <code>classmethod</code>","text":"<pre><code>validate_cnds(\n    nodes: List[str], cnds: Dict[str, CND], parents: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Checks that all CNDs in graph are consistent with one another and with graph structure.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If invalid types used in arguments.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If any inconsistent values found.</p> </li> </ul>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.validate_cnds(nodes)","title":"<code>nodes</code>","text":"(<code>list</code>)           \u2013            <p>BN nodes.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.validate_cnds(cnds)","title":"<code>cnds</code>","text":"(<code>dict</code>)           \u2013            <p>Set of CNDs for the BN, {node: cnd}.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.validate_cnds(parents)","title":"<code>parents</code>","text":"(<code>dict</code>)           \u2013            <p>Parents of non-orphan nodes, {node: parents}.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.validate_parents","title":"validate_parents  <code>abstractmethod</code>","text":"<pre><code>validate_parents(\n    node: str, parents: Dict[str, List[str]], node_values: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Checks every CND's parents and (categorical) parental values are consistent.</p> <p>Validates consistency with the other relevant CNDs and the DAG structure.</p> <p>Parameters:</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.validate_parents(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Name of node.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.validate_parents(parents)","title":"<code>parents</code>","text":"(<code>dict</code>)           \u2013            <p>Parents of all nodes {node: parents}.</p>"},{"location":"api/bn_dist_cnd/#causaliq_core.bn.dist.cnd.CND.validate_parents(node_values)","title":"<code>node_values</code>","text":"(<code>dict</code>)           \u2013            <p>Values of each cat. node {node: values}.</p>"},{"location":"api/bn_dist_cpt/","title":"CPT (Conditional Probability Table)","text":"<p>The <code>CPT</code> class represents conditional probability tables for discrete/categorical variables in Bayesian Networks. It stores and manages probability distributions that map parent value combinations to child variable probabilities.</p>"},{"location":"api/bn_dist_cpt/#overview","title":"Overview","text":"<p>A Conditional Probability Table (CPT) defines the local probability distribution for a discrete node given its parent values. It consists of:</p> <ul> <li>Values: The possible states/categories for this variable</li> <li>Table: Probability values organized by parent combinations</li> <li>Parents: Names of parent variables (if any)</li> <li>Normalization: Ensures probabilities sum to 1 for each parent combination</li> </ul>"},{"location":"api/bn_dist_cpt/#key-features","title":"Key Features","text":"<ul> <li>Flexible Parent Support: Handle any number of discrete parent variables</li> <li>Efficient Storage: Compact representation of probability tables</li> <li>Automatic Validation: Ensures probability constraints are satisfied</li> <li>Missing Data Handling: Robust handling of incomplete data during learning</li> <li>Fast Lookup: Optimized probability queries</li> </ul>"},{"location":"api/bn_dist_cpt/#table-organization","title":"Table Organization","text":"<p>For a node with parents, the probability table is organized as:</p> <ul> <li>Rows: Each parent value combination</li> <li>Columns: Each possible value of the child variable  </li> <li>Entries: P(child=value | parents=combination)</li> </ul>"},{"location":"api/bn_dist_cpt/#example-usage","title":"Example Usage","text":"<pre><code>from causaliq_core.bn.dist import CPT\n\n# Simple unconditional distribution\nweather = CPT(\n    values=['Sunny', 'Rainy'],\n    table=[0.8, 0.2]  # P(Sunny)=0.8, P(Rainy)=0.2\n)\n\n# Conditional distribution with one parent\nsprinkler = CPT(\n    values=['On', 'Off'], \n    parents=['Weather'],\n    table=[\n        0.1, 0.9,  # P(Sprinkler | Weather=Sunny) = [0.1, 0.9] \n        0.7, 0.3   # P(Sprinkler | Weather=Rainy) = [0.7, 0.3]\n    ]\n)\n\n# Conditional distribution with multiple parents\ngrass = CPT(\n    values=['Wet', 'Dry'],\n    parents=['Weather', 'Sprinkler'], \n    table=[\n        # Weather=Sunny, Sprinkler=On:  P(Wet)=0.9, P(Dry)=0.1\n        # Weather=Sunny, Sprinkler=Off: P(Wet)=0.2, P(Dry)=0.8  \n        # Weather=Rainy, Sprinkler=On:  P(Wet)=0.95, P(Dry)=0.05\n        # Weather=Rainy, Sprinkler=Off: P(Wet)=0.8, P(Dry)=0.2\n        0.9, 0.1, 0.2, 0.8, 0.95, 0.05, 0.8, 0.2\n    ]\n)\n\n# Access probabilities\nprob = sprinkler.prob('On', parents_values={'Weather': 'Rainy'})\nprint(f\"P(Sprinkler=On | Weather=Rainy) = {prob}\")\n</code></pre>"},{"location":"api/bn_dist_cpt/#data-learning","title":"Data Learning","text":"<p>CPTs can learn parameters from data:</p> <pre><code>import pandas as pd\nfrom causaliq_core.bn.dist import CPT\n\n# Training data\ndata = pd.DataFrame({\n    'Weather': ['Sunny', 'Rainy', 'Sunny', 'Rainy', 'Sunny'],\n    'Sprinkler': ['Off', 'On', 'On', 'Off', 'Off']\n})\n\n# Learn CPT from data\nlearned_cpt = CPT.from_data(\n    variable='Sprinkler',\n    parents=['Weather'], \n    data=data,\n    values=['On', 'Off']\n)\n</code></pre>"},{"location":"api/bn_dist_cpt/#nodevaluecombinations-utility","title":"NodeValueCombinations Utility","text":"<p>The module also provides the <code>NodeValueCombinations</code> utility class for handling parent value combinations:</p> <pre><code>from causaliq_core.bn.dist import NodeValueCombinations\n\n# Create combinations for multiple parents\nnvc = NodeValueCombinations(['Weather', 'Season'], \n                          [['Sunny', 'Rainy'], ['Summer', 'Winter']])\n\n# Get all combinations\ncombinations = nvc.combinations()\n# Result: [('Sunny', 'Summer'), ('Sunny', 'Winter'), \n#          ('Rainy', 'Summer'), ('Rainy', 'Winter')]\n</code></pre>"},{"location":"api/bn_dist_cpt/#api-reference","title":"API Reference","text":""},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt","title":"cpt","text":"<p>Classes:</p> <ul> <li> <code>CPT</code>           \u2013            <p>Base class for conditional probability tables.</p> </li> <li> <code>NodeValueCombinations</code>           \u2013            <p>Iterable over all combinations of node values</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT","title":"CPT","text":"<pre><code>CPT(\n    pmfs: Union[Dict[str, float], List[Tuple[Dict[str, str], Dict[str, float]]]],\n    estimated: int = 0,\n)\n</code></pre> <p>Base class for conditional probability tables.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>cpt</code>           \u2013            <p>Internal representation of the CPT. {node_values: prob} for parentless node, otherwise {parental_values as frozenset: {node_values: prob}}.</p> </li> <li> <code>estimated</code>           \u2013            <p>Number of PMFs that were estimated.</p> </li> <li> <code>values</code>           \u2013            <p>Values which node can take.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid or conflicting values.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Return whether two CPTs are the same allowing for probability</p> </li> <li> <code>__str__</code>             \u2013              <p>Human-friendly description of the contents of the CPT.</p> </li> <li> <code>cdist</code>             \u2013              <p>Return conditional probabilities of node values for specified</p> </li> <li> <code>fit</code>             \u2013              <p>Constructs a CPT (Conditional Probability Table) from data.</p> </li> <li> <code>node_values</code>             \u2013              <p>Return node values (states) of node CPT relates to.</p> </li> <li> <code>param_ratios</code>             \u2013              <p>Returns distribution of parameter ratios across all parental</p> </li> <li> <code>parents</code>             \u2013              <p>Return parents of node CPT relates to.</p> </li> <li> <code>random_value</code>             \u2013              <p>Generate a random value for a node given the value of its parents.</p> </li> <li> <code>to_spec</code>             \u2013              <p>Returns external specification format of CPT,</p> </li> <li> <code>validate_cnds</code>             \u2013              <p>Checks that all CNDs in graph are consistent with one another</p> </li> <li> <code>validate_parents</code>             \u2013              <p>Checks every CPT's parents and parental values are consistent</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT(pmfs)","title":"<code>pmfs</code>","text":"(<code>Union[Dict[str, float], List[Tuple[Dict[str, str], Dict[str, float]]]]</code>)           \u2013            <p>A pmf of {value: prob} for parentless nodes OR list of tuples ({parent: value}, {value: prob}).</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT(estimated)","title":"<code>estimated</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>How many PMFs were estimated.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether two CPTs are the same allowing for probability rounding errors</p> <p>:param other: CPT to compared to self :type other: CPT</p> <p>:returns: whether CPTs are PRACTICALLY the same :rtype: bool</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Human-friendly description of the contents of the CPT.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the CPT contents.</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.cdist","title":"cdist","text":"<pre><code>cdist(parental_values: Optional[Dict[str, str]] = None) -&gt; Dict[str, float]\n</code></pre> <p>Return conditional probabilities of node values for specified parental values.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If args are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If args have invalid or conflicting values.</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.cdist(parental_values)","title":"<code>parental_values</code>","text":"(<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>Parental values for which pmf required</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.fit","title":"fit  <code>classmethod</code>","text":"<pre><code>fit(\n    node: str,\n    parents: Optional[Tuple[str, ...]],\n    data: Union[BNFit, Any],\n    autocomplete: bool = True,\n) -&gt; Tuple[Tuple[type, Dict[str, Any]], Optional[int]]\n</code></pre> <p>Constructs a CPT (Conditional Probability Table) from data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple[type, Dict[str, Any]]</code>           \u2013            <p>Tuple of (cnd_spec, estimated_pmfs) where</p> </li> <li> <code>Optional[int]</code>           \u2013            <p>cnd_spec is (CPT class, cpt_spec for CPT())</p> </li> <li> <code>Tuple[Tuple[type, Dict[str, Any]], Optional[int]]</code>           \u2013            <p>estimated_pmfs is int, # estimated pmfs.</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.fit(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node that CPT applies to.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.fit(parents)","title":"<code>parents</code>","text":"(<code>Optional[Tuple[str, ...]]</code>)           \u2013            <p>Parents of node.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.fit(data)","title":"<code>data</code>","text":"(<code>Union[BNFit, Any]</code>)           \u2013            <p>Data to fit CPT to.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.fit(autocomplete)","title":"<code>autocomplete</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to ensure CPT data contains entries for</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.node_values","title":"node_values","text":"<pre><code>node_values() -&gt; List[str]\n</code></pre> <p>Return node values (states) of node CPT relates to.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>Node values in alphabetical order.</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.param_ratios","title":"param_ratios","text":"<pre><code>param_ratios() -&gt; None\n</code></pre> <p>Returns distribution of parameter ratios across all parental values for each combination of possible node values.</p> <p>:returns dict: {(node value pair): (param ratios across parents)</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.parents","title":"parents","text":"<pre><code>parents() -&gt; List[str]\n</code></pre> <p>Return parents of node CPT relates to.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>Parent node names in alphabetical order.</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.random_value","title":"random_value","text":"<pre><code>random_value(pvs: Optional[Dict[str, str]]) -&gt; str\n</code></pre> <p>Generate a random value for a node given the value of its parents.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Random value for node.</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.random_value(pvs)","title":"<code>pvs</code>","text":"(<code>Optional[Dict[str, str]]</code>)           \u2013            <p>Parental values, {parent1: value1, ...}.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.to_spec","title":"to_spec","text":"<pre><code>to_spec(name_map: Dict[str, str]) -&gt; Dict[str, Any]\n</code></pre> <p>Returns external specification format of CPT, renaming nodes according to a name map.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>CPT specification with renamed nodes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If bad arg value, e.g. coeff keys not in map.</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.to_spec(name_map)","title":"<code>name_map</code>","text":"(<code>Dict[str, str]</code>)           \u2013            <p>Map of node names {old: new}.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.validate_cnds","title":"validate_cnds  <code>classmethod</code>","text":"<pre><code>validate_cnds(\n    nodes: List[str], cnds: Dict[str, CND], parents: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Checks that all CNDs in graph are consistent with one another and with graph structure.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If invalid types used in arguments.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If any inconsistent values found.</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.validate_cnds(nodes)","title":"<code>nodes</code>","text":"(<code>list</code>)           \u2013            <p>BN nodes.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.validate_cnds(cnds)","title":"<code>cnds</code>","text":"(<code>dict</code>)           \u2013            <p>Set of CNDs for the BN, {node: cnd}.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.validate_cnds(parents)","title":"<code>parents</code>","text":"(<code>dict</code>)           \u2013            <p>Parents of non-orphan nodes, {node: parents}.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.validate_parents","title":"validate_parents","text":"<pre><code>validate_parents(\n    node: str, parents: Dict[str, List[str]], node_values: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Checks every CPT's parents and parental values are consistent with other relevant CPTs and the DAG structure.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If parent mismatch or missing parental</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.validate_parents(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Name of node.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.validate_parents(parents)","title":"<code>parents</code>","text":"(<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of all nodes {node: parents}.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.CPT.validate_parents(node_values)","title":"<code>node_values</code>","text":"(<code>Dict[str, List[str]]</code>)           \u2013            <p>Values of each cat. node {node: values}.</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.NodeValueCombinations","title":"NodeValueCombinations","text":"<pre><code>NodeValueCombinations(node_values: Dict[str, List[str]], sort: bool = True)\n</code></pre> <p>Iterable over all combinations of node values</p> <p>:param dict node_values: allowed values for each node {node: [values]} :param bool sort: whether to sort node names and values into                   alphabetic order</p> <p>Methods:</p> <ul> <li> <code>__iter__</code>             \u2013              <p>Returns the initialised iterator</p> </li> <li> <code>__next__</code>             \u2013              <p>Generate the next node value combination</p> </li> </ul>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.NodeValueCombinations.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; NodeValueCombinations\n</code></pre> <p>Returns the initialised iterator</p> <p>:returns NodeValueCombinations: the iterator</p>"},{"location":"api/bn_dist_cpt/#causaliq_core.bn.dist.cpt.NodeValueCombinations.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; Dict[str, str]\n</code></pre> <p>Generate the next node value combination</p> <p>:raises StopIteration: when all combinations have been returned</p> <p>:returns dict: next node value combination {node: value}</p>"},{"location":"api/bn_dist_lingauss/","title":"LinGauss (Linear Gaussian Distribution)","text":"<p>The <code>LinGauss</code> class represents Linear Gaussian distributions for continuous variables in Bayesian Networks. It models variables that follow normal distributions with linear dependencies on their parent variables.</p>"},{"location":"api/bn_dist_lingauss/#overview","title":"Overview","text":"<p>A Linear Gaussian distribution models a continuous variable as:</p> <pre><code>X = \u03bc + \u03a3 \u03b2\u1d62 * Parent\u1d62 + \u03b5\n</code></pre> <p>Where:</p> <ul> <li>\u03bc (mean): Base mean value when all parents are zero</li> <li>\u03b2\u1d62 (coefficients): Linear coefficients for each parent variable</li> <li>\u03c3 (sd): Standard deviation of the Gaussian noise term \u03b5</li> <li>\u03b5: Zero-mean Gaussian noise with variance \u03c3\u00b2</li> </ul>"},{"location":"api/bn_dist_lingauss/#key-features","title":"Key Features","text":"<ul> <li>Linear Relationships: Models linear dependencies on parent variables</li> <li>Mixed Parents: Support for both continuous and discrete parent variables</li> <li>Parameter Learning: Efficient estimation from data using regression</li> <li>Probabilistic Inference: Exact inference for Gaussian networks</li> <li>Robust Estimation: Handles missing data and numerical stability</li> </ul>"},{"location":"api/bn_dist_lingauss/#model-specification","title":"Model Specification","text":"<p>The distribution is fully specified by:</p> <ul> <li>Mean (\u03bc): Baseline value of the variable</li> <li>Standard Deviation (\u03c3): Noise level/uncertainty  </li> <li>Coefficients: Linear weights for each parent variable</li> <li>Parents: Names of parent variables in the network</li> </ul>"},{"location":"api/bn_dist_lingauss/#example-usage","title":"Example Usage","text":"<pre><code>from causaliq_core.bn.dist import LinGauss\n\n# Simple unconditional Gaussian\ntemperature = LinGauss(\n    mean=20.0,    # 20\u00b0C baseline\n    sd=3.0,       # 3\u00b0C standard deviation\n    coeffs={},    # No parents\n    parents=[]\n)\n\n# Linear dependency on one continuous parent\noutdoor_temp = LinGauss(\n    mean=15.0,        # Base indoor temperature  \n    sd=2.0,           # Noise level\n    coeffs={'OutdoorTemp': 0.7},  # 0.7 * OutdoorTemp\n    parents=['OutdoorTemp']\n)\n\n# Multiple parent dependencies\nroom_temp = LinGauss(\n    mean=18.0,\n    sd=1.5, \n    coeffs={\n        'OutdoorTemp': 0.4,    # Outdoor influence\n        'HeatingLevel': 2.0    # Heating system effect\n    },\n    parents=['OutdoorTemp', 'HeatingLevel']\n)\n\n# Sample from distribution\nsample = room_temp.sample({'OutdoorTemp': 10.0, 'HeatingLevel': 5.0})\nprint(f\"Room temperature sample: {sample:.1f}\u00b0C\")\n\n# Compute probability density\ndensity = room_temp.pdf(22.0, {'OutdoorTemp': 15.0, 'HeatingLevel': 3.0})\nprint(f\"PDF at 22\u00b0C: {density:.4f}\")\n</code></pre>"},{"location":"api/bn_dist_lingauss/#learning-from-data","title":"Learning from Data","text":"<p>LinGauss distributions can learn parameters from data using linear regression:</p> <pre><code>import pandas as pd\nfrom causaliq_core.bn.dist import LinGauss\n\n# Training data\ndata = pd.DataFrame({\n    'OutdoorTemp': [10, 15, 20, 25, 30],\n    'HeatingLevel': [8, 6, 4, 2, 0], \n    'IndoorTemp': [18, 19, 21, 23, 24]\n})\n\n# Learn distribution from data\nlearned_dist = LinGauss.from_data(\n    variable='IndoorTemp',\n    parents=['OutdoorTemp', 'HeatingLevel'],\n    data=data\n)\n\nprint(f\"Learned mean: {learned_dist.mean}\")\nprint(f\"Learned coefficients: {learned_dist.coeffs}\")\nprint(f\"Learned standard deviation: {learned_dist.sd}\")\n</code></pre>"},{"location":"api/bn_dist_lingauss/#discrete-parents","title":"Discrete Parents","text":"<p>LinGauss can also handle discrete parent variables by treating them as indicator variables:</p> <pre><code># Distribution with discrete parent\nenergy_usage = LinGauss(\n    mean=100.0,      # Base energy usage\n    sd=10.0,\n    coeffs={\n        'Season': 20.0,     # Extra usage in winter\n        'OutdoorTemp': -2.0  # Decrease with higher temp\n    },\n    parents=['Season', 'OutdoorTemp']  # Season is discrete, OutdoorTemp continuous\n)\n\n# Season would be encoded as 0 (Summer) or 1 (Winter)\nusage = energy_usage.sample({'Season': 1, 'OutdoorTemp': 5.0})  # Winter, 5\u00b0C\n</code></pre>"},{"location":"api/bn_dist_lingauss/#inference-properties","title":"Inference Properties","text":"<p>Linear Gaussian networks have special properties:</p> <ul> <li>Exact Inference: Marginal and conditional distributions remain Gaussian</li> <li>Efficient Computation: No approximation needed for probabilistic queries</li> <li>Analytical Solutions: Closed-form expressions for most operations</li> <li>Numerical Stability: Well-conditioned linear algebra operations</li> </ul>"},{"location":"api/bn_dist_lingauss/#api-reference","title":"API Reference","text":""},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss","title":"lingauss","text":"<p>Classes:</p> <ul> <li> <code>LinGauss</code>           \u2013            <p>Conditional Linear Gaussian Distribution.</p> </li> </ul>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss","title":"LinGauss","text":"<pre><code>LinGauss(lg: Dict[str, Any])\n</code></pre> <p>Conditional Linear Gaussian Distribution.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>coeffs</code>           \u2013            <p>Linear coefficient of parents {parent: coeff}.</p> </li> <li> <code>mean</code>           \u2013            <p>Mean of Gaussian noise (aka intercept, mu).</p> </li> <li> <code>sd</code>           \u2013            <p>S.D. of Gaussian noise (aka sigma).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If called with bad arg types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If called with bad arg values.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Return whether two CNDs are the same allowing for probability</p> </li> <li> <code>__str__</code>             \u2013              <p>Human-friendly formula description of the Linear Gaussian.</p> </li> <li> <code>cdist</code>             \u2013              <p>Return conditional distribution for specified parental values.</p> </li> <li> <code>fit</code>             \u2013              <p>Fit a Linear Gaussian to data.</p> </li> <li> <code>parents</code>             \u2013              <p>Return parents of node CND relates to.</p> </li> <li> <code>random_value</code>             \u2013              <p>Generate a random value for a node given the value of its parents.</p> </li> <li> <code>to_spec</code>             \u2013              <p>Returns external specification format of LinGauss,</p> </li> <li> <code>validate_parents</code>             \u2013              <p>Check LinGauss coeff keys consistent with parents in DAG.</p> </li> </ul>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss(lg)","title":"<code>lg</code>","text":"(<code>Dict[str, Any]</code>)           \u2013            <p>Specification of Linear Gaussian in following form: {'coeffs': {node: coeff}, 'mean': mean, 'sd': sd}.</p>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether two CNDs are the same allowing for probability rounding errors</p> <p>:param CND other: CND to compared to self</p> <p>:returns bool: whether LinGauss objects are the same up to 10 sf</p>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Human-friendly formula description of the Linear Gaussian.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the Linear Gaussian formula.</p> </li> </ul>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.cdist","title":"cdist","text":"<pre><code>cdist(parental_values: Optional[Dict[str, float]] = None) -&gt; Tuple[float, float]\n</code></pre> <p>Return conditional distribution for specified parental values.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float]</code>           \u2013            <p>Tuple of (mean, sd) of child Gaussian distribution.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If args are of wrong type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If args have invalid or conflicting values.</p> </li> </ul>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.cdist(parental_values)","title":"<code>parental_values</code>","text":"(<code>Optional[Dict[str, float]]</code>, default:                   <code>None</code> )           \u2013            <p>Parental values for which dist. required</p>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.fit","title":"fit  <code>classmethod</code>","text":"<pre><code>fit(\n    node: str,\n    parents: Optional[Tuple[str, ...]],\n    data: Union[Pandas, BNFit],\n    autocomplete: bool = True,\n) -&gt; Tuple[Tuple[type, Dict[str, Any]], Optional[int]]\n</code></pre> <p>Fit a Linear Gaussian to data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple[Tuple[type, Dict[str, Any]], Optional[int]]</code>           \u2013            <p>Tuple of (lg_spec, None) where lg is (LinGauss class, lg_spec).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values.</p> </li> </ul>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.fit(node)","title":"<code>node</code>","text":"(<code>str</code>)           \u2013            <p>Node that Linear Gaussian applies to.</p>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.fit(parents)","title":"<code>parents</code>","text":"(<code>Optional[Tuple[str, ...]]</code>)           \u2013            <p>Parents of node.</p>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.fit(data)","title":"<code>data</code>","text":"(<code>Union[Pandas, BNFit]</code>)           \u2013            <p>Data to fit Linear Gaussian to.</p>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.fit(autocomplete)","title":"<code>autocomplete</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not used for Linear Gaussian.</p>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.parents","title":"parents","text":"<pre><code>parents() -&gt; List[str]\n</code></pre> <p>Return parents of node CND relates to.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>Parent node names in alphabetical order.</p> </li> </ul>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.random_value","title":"random_value","text":"<pre><code>random_value(pvs: Optional[Dict[str, float]]) -&gt; float\n</code></pre> <p>Generate a random value for a node given the value of its parents.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Random value for node.</p> </li> </ul>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.random_value(pvs)","title":"<code>pvs</code>","text":"(<code>Optional[Dict[str, float]]</code>)           \u2013            <p>Parental values, {parent1: value1, ...}.</p>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.to_spec","title":"to_spec","text":"<pre><code>to_spec(name_map: Dict[str, str]) -&gt; Dict[str, Any]\n</code></pre> <p>Returns external specification format of LinGauss, renaming nodes according to a name map.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>LinGauss specification with renamed nodes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If bad arg value, e.g. coeff keys not in map.</p> </li> </ul>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.to_spec(name_map)","title":"<code>name_map</code>","text":"(<code>Dict[str, str]</code>)           \u2013            <p>Map of node names {old: new}.</p>"},{"location":"api/bn_dist_lingauss/#causaliq_core.bn.dist.lingauss.LinGauss.validate_parents","title":"validate_parents","text":"<pre><code>validate_parents(\n    node: str, parents: Dict[str, List[str]], node_values: Dict[str, List[str]]\n) -&gt; None\n</code></pre> <p>Check LinGauss coeff keys consistent with parents in DAG.</p> <p>:param str node: name of node :param dict parents: parents of all nodes defined in DAG :param dict node_values: values of each cat. node [UNUSED]</p>"},{"location":"api/bn_io/","title":"Bayesian Network I/O","text":"<p>The I/O module provides functionality for reading and writing Bayesian Networks in various standard formats. This enables interoperability with other tools and persistence of network models.</p>"},{"location":"api/bn_io/#overview","title":"Overview","text":"<p>The <code>causaliq_core.bn.io</code> module supports multiple file formats commonly used for Bayesian Networks:</p> <ul> <li>DSC Format: CausalIQ's native format for network specification</li> <li>XDSL Format: GeNIe/SMILE's XML-based format for complete networks</li> <li>Common Interface: Unified functions for format-agnostic I/O operations</li> </ul>"},{"location":"api/bn_io/#supported-formats","title":"Supported Formats","text":""},{"location":"api/bn_io/#dsc-format","title":"DSC Format","text":"<p>A text-based format for specifying Bayesian Network structures and parameters.</p> <p>Features:</p> <ul> <li>Human-readable network specification</li> <li>Support for both discrete and continuous distributions  </li> <li>Compact representation of network structure</li> <li>Easy manual editing and version control</li> </ul>"},{"location":"api/bn_io/#xdsl-format","title":"XDSL Format","text":"<p>An XML-based format used by GeNIe and SMILE software.</p> <p>Features:</p> <ul> <li>Complete network serialization including visual layout</li> <li>Industry-standard format for tool interoperability</li> <li>Support for complex network metadata</li> <li>Preservation of all network properties</li> </ul>"},{"location":"api/bn_io/#main-functions","title":"Main Functions","text":"<p>The module provides convenient top-level functions:</p> <pre><code>from causaliq_core.bn.io import read_bn, write_bn\n\n# Read BN from file (format auto-detected)\nbn = read_bn('network.dsc')     # DSC format\nbn = read_bn('network.xdsl')    # XDSL format\n\n# Write BN to file (format determined by extension)  \nwrite_bn(bn, 'output.dsc')      # Save as DSC\nwrite_bn(bn, 'output.xdsl')     # Save as XDSL\n</code></pre>"},{"location":"api/bn_io/#format-detection","title":"Format Detection","text":"<p>The I/O system automatically detects formats based on:</p> <ul> <li>File Extension: <code>.dsc</code> for DSC format, <code>.xdsl</code> for XDSL format</li> <li>Content Analysis: Inspection of file headers and structure</li> <li>Explicit Specification: Manual format specification when needed</li> </ul>"},{"location":"api/bn_io/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/bn_io/#loading-networks","title":"Loading Networks","text":"<pre><code>from causaliq_core.bn.io import read_bn\n\n# Load from different formats\ndsc_network = read_bn('models/weather.dsc')\nxdsl_network = read_bn('models/medical.xdsl') \n\n# Verify loaded network\nprint(f\"Nodes: {list(dsc_network.dag.nodes)}\")\nprint(f\"Edges: {list(dsc_network.dag.edges)}\")\n</code></pre>"},{"location":"api/bn_io/#saving-networks","title":"Saving Networks","text":"<pre><code>from causaliq_core.bn.io import write_bn\nfrom causaliq_core.bn import BN\n\n# Create or modify network\n# ... bn creation code ...\n\n# Save in different formats\nwrite_bn(bn, 'output/final_model.dsc')     # DSC format\nwrite_bn(bn, 'output/final_model.xdsl')    # XDSL format\n\n# Backup with timestamp\nimport datetime\ntimestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')\nwrite_bn(bn, f'backups/model_{timestamp}.dsc')\n</code></pre>"},{"location":"api/bn_io/#format-conversion","title":"Format Conversion","text":"<pre><code>from causaliq_core.bn.io import read_bn, write_bn\n\n# Convert between formats\nbn = read_bn('input.dsc')       # Read DSC\nwrite_bn(bn, 'output.xdsl')     # Write XDSL\n\n# Batch conversion\nimport glob\nfor dsc_file in glob.glob('*.dsc'):\n    bn = read_bn(dsc_file)\n    xdsl_file = dsc_file.replace('.dsc', '.xdsl')\n    write_bn(bn, xdsl_file)\n</code></pre>"},{"location":"api/bn_io/#error-handling","title":"Error Handling","text":"<p>The I/O system provides robust error handling:</p> <ul> <li>Format Validation: Checks for valid file formats and structure</li> <li>Parse Errors: Clear messages for syntax and content errors</li> <li>Missing Files: Helpful error messages for file access issues</li> <li>Recovery: Graceful handling of partial or corrupted files</li> </ul>"},{"location":"api/bn_io/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Lazy Loading: Large networks are loaded efficiently</li> <li>Memory Management: Minimal memory footprint during I/O operations</li> <li>Streaming: Support for large files that don't fit in memory</li> <li>Caching: Intelligent caching of frequently accessed networks</li> </ul>"},{"location":"api/bn_io/#api-reference","title":"API Reference","text":""},{"location":"api/bn_io/#causaliq_core.bn.io","title":"io","text":"<p>I/O module for Bayesian Network file formats.</p> <p>Modules:</p> <ul> <li> <code>common</code>           \u2013            </li> <li> <code>dsc</code>           \u2013            </li> <li> <code>xdsl</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>read_bn</code>             \u2013              <p>Read a Bayesian Network from a file, automatically detecting format.</p> </li> <li> <code>write_bn</code>             \u2013              <p>Write BN to a DSC or XDSL format file.</p> </li> </ul>"},{"location":"api/bn_io/#causaliq_core.bn.io.read_bn","title":"read_bn","text":"<pre><code>read_bn(path: str, correct: bool = False) -&gt; BN\n</code></pre> <p>Read a Bayesian Network from a file, automatically detecting format.</p> <p>Supports: - .dsc files (DSC format) - .xdsl files (XDSL format)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BN</code>           \u2013            <p>Bayesian Network specified in file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If path is not a string.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If path suffix is not \"dsc\" or \"xdsl\".</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If file does not exist.</p> </li> <li> <code>FileFormatError</code>             \u2013            <p>If file contents not valid.</p> </li> </ul>"},{"location":"api/bn_io/#causaliq_core.bn.io.read_bn(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Path to DSC/XDSL file.</p>"},{"location":"api/bn_io/#causaliq_core.bn.io.read_bn(correct)","title":"<code>correct</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to correct probabilities that do not sum to 1 (XDSL files only).</p>"},{"location":"api/bn_io/#causaliq_core.bn.io.write_bn","title":"write_bn","text":"<pre><code>write_bn(bn: BN, path: str) -&gt; None\n</code></pre> <p>Write BN to a DSC or XDSL format file.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If suffix not \".dsc\" or \".xdsl\".</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If file location nonexistent.</p> </li> </ul>"},{"location":"api/bn_io/#causaliq_core.bn.io.write_bn(bn)","title":"<code>bn</code>","text":"(<code>BN</code>)           \u2013            <p>Bayesian Network to write.</p>"},{"location":"api/bn_io/#causaliq_core.bn.io.write_bn(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Path to file.</p>"},{"location":"api/bn_io_common/","title":"Common I/O Interface","text":"<p>The common I/O interface provides unified functions for reading and writing Bayesian Networks regardless of file format. These functions automatically detect formats and route to the appropriate format-specific handlers.</p>"},{"location":"api/bn_io_common/#overview","title":"Overview","text":"<p>The common interface simplifies BN I/O by providing:</p> <ul> <li>Format Auto-Detection: Automatically determines file format from extension and content</li> <li>Unified API: Same functions work with all supported formats</li> <li>Error Handling: Consistent error reporting across formats</li> <li>Format Conversion: Easy conversion between different formats</li> </ul>"},{"location":"api/bn_io_common/#main-functions","title":"Main Functions","text":""},{"location":"api/bn_io_common/#read_bn","title":"read_bn()","text":"<p>The primary function for loading Bayesian Networks from files:</p> <pre><code>from causaliq_core.bn.io import read_bn\n\n# Auto-detect format from extension\nbn_dsc = read_bn('network.dsc')     # DSC format\nbn_xdsl = read_bn('network.xdsl')   # XDSL format\n\n# Explicit format specification (optional)\nbn = read_bn('network.txt', format='dsc')\n</code></pre>"},{"location":"api/bn_io_common/#write_bn","title":"write_bn()","text":"<p>The primary function for saving Bayesian Networks to files:</p> <pre><code>from causaliq_core.bn.io import write_bn\n\n# Auto-detect format from extension\nwrite_bn(bn, 'output.dsc')      # Saves as DSC\nwrite_bn(bn, 'output.xdsl')     # Saves as XDSL\n\n# Explicit format specification (optional)\nwrite_bn(bn, 'output.txt', format='dsc')\n</code></pre>"},{"location":"api/bn_io_common/#format-detection","title":"Format Detection","text":"<p>The system determines file format using:</p>"},{"location":"api/bn_io_common/#extension-based-detection","title":"Extension-Based Detection","text":"<ul> <li><code>.dsc</code> \u2192 DSC format</li> <li><code>.xdsl</code> \u2192 XDSL format</li> <li>Unknown extensions \u2192 Content-based detection</li> </ul>"},{"location":"api/bn_io_common/#content-based-detection","title":"Content-Based Detection","text":"<p>For files without clear extensions:</p> <pre><code># System examines file content\nbn = read_bn('network')  # No extension\n\n# Looks for:\n# - XML headers \u2192 XDSL format  \n# - DSC syntax \u2192 DSC format\n# - Fallback to default format\n</code></pre>"},{"location":"api/bn_io_common/#error-handling","title":"Error Handling","text":"<p>The common interface provides consistent error handling:</p> <pre><code>from causaliq_core.bn.io import read_bn, write_bn\nfrom causaliq_core.bn.io.common import FileFormatError\n\ntry:\n    bn = read_bn('nonexistent.dsc')\nexcept FileNotFoundError:\n    print(\"File not found\")\n\ntry:\n    bn = read_bn('invalid.dsc')  \nexcept FileFormatError as e:\n    print(f\"Format error: {e}\")\n\ntry:\n    write_bn(invalid_bn, 'output.dsc')\nexcept ValueError as e:\n    print(f\"Invalid network: {e}\")\n</code></pre>"},{"location":"api/bn_io_common/#usage-examples","title":"Usage Examples","text":""},{"location":"api/bn_io_common/#basic-file-operations","title":"Basic File Operations","text":"<pre><code>from causaliq_core.bn.io import read_bn, write_bn\n\n# Load network\noriginal_bn = read_bn('input/network.dsc')\n\n# Perform analysis or modifications\n# ... network operations ...\n\n# Save results\nwrite_bn(modified_bn, 'output/result.dsc')\n</code></pre>"},{"location":"api/bn_io_common/#format-conversion","title":"Format Conversion","text":"<pre><code>from causaliq_core.bn.io import read_bn, write_bn\n\n# Convert DSC to XDSL\nbn = read_bn('network.dsc')\nwrite_bn(bn, 'network.xdsl')\n\n# Convert XDSL to DSC\nbn = read_bn('genie_network.xdsl') \nwrite_bn(bn, 'causaliq_network.dsc')\n\n# Batch conversion\nimport glob\nfor dsc_file in glob.glob('*.dsc'):\n    bn = read_bn(dsc_file)\n    xdsl_file = dsc_file.replace('.dsc', '.xdsl')\n    write_bn(bn, xdsl_file)\n</code></pre>"},{"location":"api/bn_io_common/#robust-file-handling","title":"Robust File Handling","text":"<pre><code>from pathlib import Path\nfrom causaliq_core.bn.io import read_bn, write_bn\n\ndef safe_load_bn(filename):\n    \"\"\"Safely load BN with error handling.\"\"\"\n    try:\n        path = Path(filename)\n        if not path.exists():\n            raise FileNotFoundError(f\"Network file not found: {filename}\")\n\n        bn = read_bn(filename)\n        print(f\"Successfully loaded network with {len(bn.dag.nodes)} nodes\")\n        return bn\n\n    except Exception as e:\n        print(f\"Error loading {filename}: {e}\")\n        return None\n\ndef safe_save_bn(bn, filename, backup=True):\n    \"\"\"Safely save BN with optional backup.\"\"\"\n    try:\n        path = Path(filename)\n\n        # Create backup if file exists\n        if backup and path.exists():\n            backup_path = path.with_suffix(path.suffix + '.backup')\n            path.rename(backup_path)\n\n        write_bn(bn, filename)\n        print(f\"Successfully saved network to {filename}\")\n\n    except Exception as e:\n        print(f\"Error saving {filename}: {e}\")\n</code></pre>"},{"location":"api/bn_io_common/#format-specific-options","title":"Format-Specific Options","text":"<p>While the common interface handles most cases, format-specific options are available:</p> <pre><code>from causaliq_core.bn.io.dsc import read_dsc, write_dsc\nfrom causaliq_core.bn.io.xdsl import read_xdsl, write_xdsl\n\n# DSC-specific options\nbn = read_dsc('network.dsc', strict_validation=True)\nwrite_dsc(bn, 'output.dsc', include_comments=True)\n\n# XDSL-specific options  \nbn = read_xdsl('network.xdsl', preserve_layout=True)\nwrite_xdsl(bn, 'output.xdsl', genie_compatible=True)\n</code></pre>"},{"location":"api/bn_io_common/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Large Files: Streaming support for very large networks</li> <li>Memory Usage: Efficient parsing without loading entire file into memory</li> <li>Validation: Optional validation can be disabled for faster loading</li> <li>Caching: Intelligent caching for frequently accessed files</li> </ul>"},{"location":"api/bn_io_common/#file-path-handling","title":"File Path Handling","text":"<p>The interface supports various path formats:</p> <pre><code>from pathlib import Path\n\n# String paths\nbn = read_bn('data/network.dsc')\n\n# Path objects\npath = Path('data') / 'network.dsc'\nbn = read_bn(path)\n\n# Absolute paths\nbn = read_bn('/full/path/to/network.dsc')\n\n# Relative paths\nbn = read_bn('../networks/model.xdsl')\n</code></pre>"},{"location":"api/bn_io_common/#integration-examples","title":"Integration Examples","text":""},{"location":"api/bn_io_common/#with-data-pipelines","title":"With Data Pipelines","text":"<pre><code>def process_network_batch(input_dir, output_dir):\n    \"\"\"Process multiple networks.\"\"\"\n    input_path = Path(input_dir)\n    output_path = Path(output_dir)\n    output_path.mkdir(exist_ok=True)\n\n    for network_file in input_path.glob('*.dsc'):\n        bn = read_bn(network_file)\n\n        # Process network (fit parameters, analyze, etc.)\n        processed_bn = process_network(bn)\n\n        # Save result\n        output_file = output_path / network_file.name\n        write_bn(processed_bn, output_file)\n</code></pre>"},{"location":"api/bn_io_common/#with-configuration-management","title":"With Configuration Management","text":"<pre><code>import yaml\nfrom causaliq_core.bn.io import read_bn\n\ndef load_network_config(config_file):\n    \"\"\"Load network based on configuration.\"\"\"\n    with open(config_file) as f:\n        config = yaml.safe_load(f)\n\n    network_file = config['network']['file']\n    bn = read_bn(network_file)\n\n    return bn, config\n</code></pre>"},{"location":"api/bn_io_common/#api-reference","title":"API Reference","text":""},{"location":"api/bn_io_common/#causaliq_core.bn.io.common","title":"common","text":"<p>Functions:</p> <ul> <li> <code>read_bn</code>             \u2013              <p>Read a Bayesian Network from a file, automatically detecting format.</p> </li> <li> <code>write_bn</code>             \u2013              <p>Write BN to a DSC or XDSL format file.</p> </li> </ul>"},{"location":"api/bn_io_common/#causaliq_core.bn.io.common.read_bn","title":"read_bn","text":"<pre><code>read_bn(path: str, correct: bool = False) -&gt; BN\n</code></pre> <p>Read a Bayesian Network from a file, automatically detecting format.</p> <p>Supports: - .dsc files (DSC format) - .xdsl files (XDSL format)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BN</code>           \u2013            <p>Bayesian Network specified in file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If path is not a string.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If path suffix is not \"dsc\" or \"xdsl\".</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If file does not exist.</p> </li> <li> <code>FileFormatError</code>             \u2013            <p>If file contents not valid.</p> </li> </ul>"},{"location":"api/bn_io_common/#causaliq_core.bn.io.common.read_bn(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Path to DSC/XDSL file.</p>"},{"location":"api/bn_io_common/#causaliq_core.bn.io.common.read_bn(correct)","title":"<code>correct</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to correct probabilities that do not sum to 1 (XDSL files only).</p>"},{"location":"api/bn_io_common/#causaliq_core.bn.io.common.write_bn","title":"write_bn","text":"<pre><code>write_bn(bn: BN, path: str) -&gt; None\n</code></pre> <p>Write BN to a DSC or XDSL format file.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If suffix not \".dsc\" or \".xdsl\".</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If file location nonexistent.</p> </li> </ul>"},{"location":"api/bn_io_common/#causaliq_core.bn.io.common.write_bn(bn)","title":"<code>bn</code>","text":"(<code>BN</code>)           \u2013            <p>Bayesian Network to write.</p>"},{"location":"api/bn_io_common/#causaliq_core.bn.io.common.write_bn(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Path to file.</p>"},{"location":"api/bn_io_dsc/","title":"DSC Format I/O","text":"<p>The DSC format is CausalIQ's text-based format for specifying Bayesian Network structures and parameters. It provides a human-readable way to define networks that can be easily edited, version controlled, and shared.</p>"},{"location":"api/bn_io_dsc/#overview","title":"Overview","text":"<p>DSC (Directed Structure Configuration) files contain:</p> <ul> <li>Network Structure: Node definitions and parent-child relationships</li> <li>Distribution Specifications: Parameters for conditional distributions</li> <li>Metadata: Additional information about the network</li> <li>Comments: Documentation and annotations</li> </ul>"},{"location":"api/bn_io_dsc/#file-format-structure","title":"File Format Structure","text":"<p>A DSC file typically contains sections for:</p> <pre><code># Network structure\nnodes: A, B, C\nedges: A -&gt; B, A -&gt; C, B -&gt; C\n\n# Distribution parameters  \nnode A {\n    type: discrete\n    values: true, false\n    table: 0.3, 0.7\n}\n\nnode B {\n    type: discrete\n    values: on, off\n    parents: A\n    table: 0.9, 0.1, 0.2, 0.8\n}\n</code></pre>"},{"location":"api/bn_io_dsc/#key-features","title":"Key Features","text":"<ul> <li>Human Readable: Plain text format that's easy to understand</li> <li>Version Control Friendly: Text format works well with Git and other VCS</li> <li>Compact: Efficient representation without XML verbosity</li> <li>Extensible: Support for custom metadata and annotations</li> <li>Cross-Platform: Works on all operating systems</li> </ul>"},{"location":"api/bn_io_dsc/#reading-dsc-files","title":"Reading DSC Files","text":"<pre><code>from causaliq_core.bn.io import read_bn\n\n# Read DSC file\nbn = read_bn('network.dsc')\n\n# Access loaded network properties\nprint(f\"Nodes: {list(bn.dag.nodes)}\")\nprint(f\"Edges: {list(bn.dag.edges)}\")\n\n# Access distributions\nfor node_name, cnd in bn.cnds.items():\n    print(f\"Node {node_name}: {type(cnd).__name__}\")\n</code></pre>"},{"location":"api/bn_io_dsc/#writing-dsc-files","title":"Writing DSC Files","text":"<pre><code>from causaliq_core.bn.io import write_bn\nfrom causaliq_core.bn import BN, CPT\nfrom causaliq_core.graph import DAG\n\n# Create a simple network\ndag = DAG(['Rain', 'Sprinkler', 'Grass'], \n          [('Rain', 'Sprinkler'), ('Rain', 'Grass'), ('Sprinkler', 'Grass')])\n\ncnd_specs = {\n    'Rain': CPT(values=['Yes', 'No'], table=[0.2, 0.8]),\n    'Sprinkler': CPT(values=['On', 'Off'], \n                     table=[0.01, 0.99, 0.4, 0.6], \n                     parents=['Rain']),\n    'Grass': CPT(values=['Wet', 'Dry'],\n                 table=[0.95, 0.05, 0.8, 0.2, 0.9, 0.1, 0.0, 1.0],\n                 parents=['Rain', 'Sprinkler'])\n}\n\nbn = BN(dag, cnd_specs)\n\n# Write to DSC file\nwrite_bn(bn, 'lawn_sprinkler.dsc')\n</code></pre>"},{"location":"api/bn_io_dsc/#dsc-syntax-examples","title":"DSC Syntax Examples","text":""},{"location":"api/bn_io_dsc/#simple-discrete-node","title":"Simple Discrete Node","text":"<pre><code>node Weather {\n    type: discrete\n    values: Sunny, Rainy\n    table: 0.8, 0.2\n}\n</code></pre>"},{"location":"api/bn_io_dsc/#conditional-discrete-node","title":"Conditional Discrete Node","text":"<pre><code>node Sprinkler {\n    type: discrete\n    values: On, Off\n    parents: Weather\n    table: 0.1, 0.9,    # P(Sprinkler | Weather=Sunny)\n           0.7, 0.3     # P(Sprinkler | Weather=Rainy)\n}\n</code></pre>"},{"location":"api/bn_io_dsc/#continuous-node-linear-gaussian","title":"Continuous Node (Linear Gaussian)","text":"<pre><code>node Temperature {\n    type: continuous\n    parents: Season, Location\n    mean: 20.0\n    sd: 3.5\n    coeffs: Season=5.0, Location=-2.0\n}\n</code></pre>"},{"location":"api/bn_io_dsc/#network-structure","title":"Network Structure","text":"<pre><code># Define all nodes\nnodes: Weather, Sprinkler, Rain, Grass\n\n# Define relationships  \nedges: Weather -&gt; Sprinkler,\n       Weather -&gt; Rain,\n       Sprinkler -&gt; Grass,\n       Rain -&gt; Grass\n\n# Optional metadata\ntitle: Lawn Watering Network\ndescription: Models grass wetness based on weather and sprinkler\nversion: 1.2\n</code></pre>"},{"location":"api/bn_io_dsc/#error-handling","title":"Error Handling","text":"<p>The DSC parser provides detailed error messages for common issues:</p> <ul> <li>Syntax Errors: Line numbers and descriptions for invalid syntax</li> <li>Missing Definitions: Clear messages for undefined nodes or parents</li> <li>Parameter Errors: Validation of probability tables and distributions</li> <li>Structure Errors: Detection of cycles and invalid relationships</li> </ul>"},{"location":"api/bn_io_dsc/#advanced-features","title":"Advanced Features","text":""},{"location":"api/bn_io_dsc/#comments-and-documentation","title":"Comments and Documentation","text":"<pre><code># This is a comment\nnode Weather {\n    # Weather conditions for the day\n    type: discrete\n    values: Sunny, Rainy, Cloudy  # Three possible states\n    table: 0.6, 0.2, 0.2         # Prior probabilities\n}\n</code></pre>"},{"location":"api/bn_io_dsc/#include-files","title":"Include Files","text":"<pre><code># Include common definitions\ninclude: common_nodes.dsc\n\n# Define network-specific nodes\nnode SpecialCase {\n    type: discrete\n    values: Yes, No\n    table: 0.1, 0.9\n}\n</code></pre>"},{"location":"api/bn_io_dsc/#parameter-macros","title":"Parameter Macros","text":"<pre><code># Define reusable parameters\ndefine NOISE_LEVEL 0.05\ndefine DEFAULT_MEAN 0.0\n\nnode Measurement {\n    type: continuous\n    mean: DEFAULT_MEAN\n    sd: NOISE_LEVEL\n}\n</code></pre>"},{"location":"api/bn_io_dsc/#api-reference","title":"API Reference","text":""},{"location":"api/bn_io_dsc/#causaliq_core.bn.io.dsc","title":"dsc","text":"<p>Functions:</p> <ul> <li> <code>read</code>             \u2013              <p>Reads in a BN from a DSC format BN specification file.</p> </li> <li> <code>write</code>             \u2013              <p>Writes Bayesian Network to disk file in DSC format.</p> </li> </ul>"},{"location":"api/bn_io_dsc/#causaliq_core.bn.io.dsc.read","title":"read","text":"<pre><code>read(path: str) -&gt; Tuple[List[str], List[Tuple[str, str, str]], Any]\n</code></pre> <p>Reads in a BN from a DSC format BN specification file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple[List[str], List[Tuple[str, str, str]], Any]</code>           \u2013            <p>Tuple containing nodes, edges, and cptdata.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If path is not a string.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If file does not exist.</p> </li> <li> <code>FileFormatError</code>             \u2013            <p>If file contents not valid.</p> </li> </ul>"},{"location":"api/bn_io_dsc/#causaliq_core.bn.io.dsc.read(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Full path name of file.</p>"},{"location":"api/bn_io_dsc/#causaliq_core.bn.io.dsc.write","title":"write","text":"<pre><code>write(bn: Any, filename: str) -&gt; None\n</code></pre> <p>Writes Bayesian Network to disk file in DSC format.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If file location nonexistent.</p> </li> </ul>"},{"location":"api/bn_io_dsc/#causaliq_core.bn.io.dsc.write(bn)","title":"<code>bn</code>","text":"(<code>Any</code>)           \u2013            <p>Bayesian Network to dump to file.</p>"},{"location":"api/bn_io_dsc/#causaliq_core.bn.io.dsc.write(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>Name of file to write.</p>"},{"location":"api/bn_io_xdsl/","title":"XDSL Format I/O","text":"<p>The XDSL format is an XML-based format used by GeNIe and SMILE software for representing complete Bayesian Networks. It provides comprehensive serialization including network structure, parameters, and visual layout information.</p>"},{"location":"api/bn_io_xdsl/#overview","title":"Overview","text":"<p>XDSL (eXtended Decision Structures Language) files contain:</p> <ul> <li>Complete Network Definition: All nodes, relationships, and parameters</li> <li>Visual Layout: Node positions, colors, and graphical properties  </li> <li>Metadata: Network properties, documentation, and annotations</li> <li>Tool Integration: Full compatibility with GeNIe/SMILE software</li> </ul>"},{"location":"api/bn_io_xdsl/#key-features","title":"Key Features","text":"<ul> <li>Industry Standard: Widely supported format for Bayesian Network tools</li> <li>Complete Serialization: Preserves all network properties and metadata</li> <li>Visual Information: Maintains graphical layout and presentation</li> <li>Tool Interoperability: Exchange networks with other BN software</li> <li>Rich Metadata: Support for detailed network documentation</li> </ul>"},{"location":"api/bn_io_xdsl/#reading-xdsl-files","title":"Reading XDSL Files","text":"<pre><code>from causaliq_core.bn.io import read_bn\n\n# Read XDSL file created by GeNIe or other tools\nbn = read_bn('network.xdsl')\n\n# Access network structure\nprint(f\"Loaded network with {len(bn.dag.nodes)} nodes\")\nprint(f\"Nodes: {list(bn.dag.nodes)}\")\nprint(f\"Edges: {list(bn.dag.edges)}\")\n\n# Examine distributions\nfor node_name, cnd in bn.cnds.items():\n    print(f\"Node '{node_name}' has {cnd.param_count} parameters\")\n</code></pre>"},{"location":"api/bn_io_xdsl/#writing-xdsl-files","title":"Writing XDSL Files","text":"<pre><code>from causaliq_core.bn.io import write_bn\nfrom causaliq_core.bn import BN, CPT\nfrom causaliq_core.graph import DAG\n\n# Create network\ndag = DAG(['Disease', 'Symptom1', 'Symptom2'], \n          [('Disease', 'Symptom1'), ('Disease', 'Symptom2')])\n\ncnd_specs = {\n    'Disease': CPT(values=['Present', 'Absent'], table=[0.01, 0.99]),\n    'Symptom1': CPT(values=['Yes', 'No'], \n                    table=[0.9, 0.1, 0.05, 0.95], \n                    parents=['Disease']),\n    'Symptom2': CPT(values=['Yes', 'No'],\n                    table=[0.8, 0.2, 0.02, 0.98],\n                    parents=['Disease'])\n}\n\nbn = BN(dag, cnd_specs)\n\n# Write to XDSL format (can be opened in GeNIe)\nwrite_bn(bn, 'medical_diagnosis.xdsl')\n</code></pre>"},{"location":"api/bn_io_xdsl/#xdsl-file-structure","title":"XDSL File Structure","text":"<p>A typical XDSL file contains XML sections like:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;smile version=\"1.0\" id=\"Network\" numsamples=\"10000\"&gt;\n  &lt;nodes&gt;\n    &lt;cpt id=\"Disease\"&gt;\n      &lt;state id=\"Present\" /&gt;\n      &lt;state id=\"Absent\" /&gt;\n      &lt;probabilities&gt;0.01 0.99&lt;/probabilities&gt;\n    &lt;/cpt&gt;\n\n    &lt;cpt id=\"Symptom1\"&gt;\n      &lt;state id=\"Yes\" /&gt;\n      &lt;state id=\"No\" /&gt;\n      &lt;parents&gt;Disease&lt;/parents&gt;\n      &lt;probabilities&gt;0.9 0.1 0.05 0.95&lt;/probabilities&gt;\n    &lt;/cpt&gt;\n  &lt;/nodes&gt;\n\n  &lt;extensions&gt;\n    &lt;genie version=\"1.0\" app=\"GeNIe\"&gt;\n      &lt;node id=\"Disease\"&gt;\n        &lt;name&gt;Disease Status&lt;/name&gt;\n        &lt;interior color=\"e5f6f7\" /&gt;\n        &lt;outline color=\"000080\" /&gt;\n        &lt;font color=\"000000\" name=\"Arial\" size=\"8\" /&gt;\n        &lt;position&gt;100 50 180 90&lt;/position&gt;\n      &lt;/node&gt;\n    &lt;/genie&gt;\n  &lt;/extensions&gt;\n&lt;/smile&gt;\n</code></pre>"},{"location":"api/bn_io_xdsl/#supported-elements","title":"Supported Elements","text":""},{"location":"api/bn_io_xdsl/#node-types","title":"Node Types","text":"<p>The XDSL reader/writer supports:</p> <ul> <li>CPT Nodes: Discrete nodes with conditional probability tables</li> <li>Continuous Nodes: Linear Gaussian nodes (limited support)</li> <li>Decision Nodes: For influence diagrams (where supported)</li> <li>Utility Nodes: For decision analysis (where supported)</li> </ul>"},{"location":"api/bn_io_xdsl/#network-properties","title":"Network Properties","text":"<ul> <li>Node States: Discrete value labels and continuous ranges</li> <li>Probability Tables: Full CPT specifications  </li> <li>Parent Relationships: Conditional dependency structure</li> <li>Network Metadata: Names, descriptions, and annotations</li> </ul>"},{"location":"api/bn_io_xdsl/#interoperability-examples","title":"Interoperability Examples","text":""},{"location":"api/bn_io_xdsl/#from-genie-to-causaliq","title":"From GeNIe to CausalIQ","text":"<pre><code>from causaliq_core.bn.io import read_bn\n\n# Read network created in GeNIe\nbn = read_bn('genie_network.xdsl')\n\n# Use in CausalIQ analysis\nmarginals = bn.marginals(['NodeA', 'NodeB'])\nprint(\"Marginal probabilities:\")\nprint(marginals)\n\n# Perform inference\nposterior = bn.conditional(['Disease'], ['Symptom1'], 'Yes')\nprint(f\"P(Disease | Symptom1=Yes): {posterior}\")\n</code></pre>"},{"location":"api/bn_io_xdsl/#from-causaliq-to-genie","title":"From CausalIQ to GeNIe","text":"<pre><code>from causaliq_core.bn import BN\nfrom causaliq_core.bn.io import write_bn\n\n# Create network in CausalIQ\n# ... network creation code ...\n\n# Export for GeNIe\nwrite_bn(bn, 'for_genie.xdsl')\n\n# File can now be opened and edited in GeNIe software\n# Visual layout and additional properties can be added\n</code></pre>"},{"location":"api/bn_io_xdsl/#advanced-features","title":"Advanced Features","text":""},{"location":"api/bn_io_xdsl/#visual-layout-preservation","title":"Visual Layout Preservation","text":"<p>When reading XDSL files with visual information:</p> <pre><code># Read network with layout information\nbn = read_bn('visual_network.xdsl')\n\n# Layout information is preserved in metadata\n# (Access depends on specific implementation)\n</code></pre>"},{"location":"api/bn_io_xdsl/#metadata-handling","title":"Metadata Handling","text":"<pre><code># XDSL files can contain rich metadata\nbn = read_bn('documented_network.xdsl')\n\n# Access network documentation\n# (Implementation-specific metadata access)\n</code></pre>"},{"location":"api/bn_io_xdsl/#format-limitations","title":"Format Limitations","text":"<p>Current XDSL support has some limitations:</p> <ul> <li>Continuous Nodes: Limited support for complex continuous distributions</li> <li>Visual Elements: Layout information may not be fully preserved</li> <li>Extensions: Some GeNIe-specific extensions may not be supported</li> <li>Decision Networks: Influence diagrams have limited support</li> </ul>"},{"location":"api/bn_io_xdsl/#error-handling","title":"Error Handling","text":"<p>The XDSL parser handles common issues:</p> <ul> <li>Invalid XML: Clear error messages for malformed XML</li> <li>Missing Elements: Detection of incomplete network definitions</li> <li>Version Compatibility: Handling of different XDSL versions</li> <li>Encoding Issues: Robust handling of character encodings</li> </ul>"},{"location":"api/bn_io_xdsl/#performance-notes","title":"Performance Notes","text":"<ul> <li>Large Networks: Efficient parsing of networks with many nodes</li> <li>Memory Usage: Optimized memory usage during parsing</li> <li>Validation: Optional validation for faster loading</li> <li>Streaming: Support for large XDSL files</li> </ul>"},{"location":"api/bn_io_xdsl/#api-reference","title":"API Reference","text":""},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl","title":"xdsl","text":"<p>Functions:</p> <ul> <li> <code>genie_str</code>             \u2013              <p>Cleanses string so that it conforms to Genie requirements.</p> </li> <li> <code>read</code>             \u2013              <p>Reads in a BN from a XDSL format BN specification file.</p> </li> <li> <code>write</code>             \u2013              <p>Write Bayesian Network to disk file in XDSL format.</p> </li> <li> <code>write_genie_extension</code>             \u2013              <p>Writes the XDSL Genie extension XML.</p> </li> </ul>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.genie_str","title":"genie_str","text":"<pre><code>genie_str(string: Any, prefix: Any) -&gt; Any\n</code></pre> <p>Cleanses string so that it conforms to Genie requirements.</p> <p>Cleanses string so that it conforms to Genie requirements for a node name or value.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Cleansed string that meets Genie requirements.</p> </li> </ul>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.genie_str(string)","title":"<code>string</code>","text":"(<code>Any</code>)           \u2013            <p>Node name or value to cleanse.</p>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.genie_str(prefix)","title":"<code>prefix</code>","text":"(<code>Any</code>)           \u2013            <p>Prefix to use if doesn't start with letter.</p>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.read","title":"read","text":"<pre><code>read(path: Any, correct: Any = False) -&gt; Any\n</code></pre> <p>Reads in a BN from a XDSL format BN specification file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Tuple</code> (              <code>Any</code> )          \u2013            <p>nodes, edges, CND_specs.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If path is not a string.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If PMF probabilities don't sum to 1 (adjust=False).</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If file does not exist.</p> </li> <li> <code>FileFormatError</code>             \u2013            <p>If file contents not valid.</p> </li> </ul>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.read(path)","title":"<code>path</code>","text":"(<code>Any</code>)           \u2013            <p>Full path name of file.</p>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.read(correct)","title":"<code>correct</code>","text":"(<code>Any</code>, default:                   <code>False</code> )           \u2013            <p>Whether to correct sets of PMF probabilities that      don't sum to 1.</p>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.write","title":"write","text":"<pre><code>write(bn: Any, filename: Any, genie: Any = False) -&gt; Any\n</code></pre> <p>Write Bayesian Network to disk file in XDSL format.</p> <p>Ensure everything written out with node name and values ordered alphabetically.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>Bad argument types.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If file location nonexistent.</p> </li> </ul>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.write(bn)","title":"<code>bn</code>","text":"(<code>Any</code>)           \u2013            <p>Bayesian Network to dump to file.</p>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.write(filename)","title":"<code>filename</code>","text":"(<code>Any</code>)           \u2013            <p>Name of file to write.</p>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.write(genie)","title":"<code>genie</code>","text":"(<code>Any</code>, default:                   <code>False</code> )           \u2013            <p>Whether files needs to be read by Genie - if so,    will ensure all node and state names start with    a letter.</p>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.write_genie_extension","title":"write_genie_extension","text":"<pre><code>write_genie_extension(f: Any, partial_order: Any) -&gt; Any\n</code></pre> <p>Writes the XDSL Genie extension XML.</p> <p>Writes the XDSL Genie extension XML which defines node placement on the visual drawing of the network.</p> <p>Parameters:</p>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.write_genie_extension(f)","title":"<code>f</code>","text":"(<code>Any</code>)           \u2013            <p>Handle to write text.</p>"},{"location":"api/bn_io_xdsl/#causaliq_core.bn.io.xdsl.write_genie_extension(partial_order)","title":"<code>partial_order</code>","text":"(<code>Any</code>)           \u2013            <p>Of (list of) nodes in each partial order            group of nodes.</p>"},{"location":"api/cli/","title":"CLI Module","text":"<p>The <code>causaliq_core.cli</code> module provides command-line interface functionality for CausalIQ Core.</p>"},{"location":"api/cli/#cli-entry-point","title":"CLI entry point","text":"<p>This is the entry point for the CLI logic.</p>"},{"location":"api/cli/#causaliq_core.cli","title":"cli","text":"<p>Command-line interface for causaliq-core.</p> <p>Functions:</p> <ul> <li> <code>cli</code>             \u2013              <p>Simple CLI example.</p> </li> <li> <code>main</code>             \u2013              <p>Entry point for the CLI.</p> </li> </ul>"},{"location":"api/cli/#causaliq_core.cli.cli","title":"cli","text":"<pre><code>cli(name: str, greet: str) -&gt; None\n</code></pre> <p>Simple CLI example.</p> <p>NAME is the person to greet</p>"},{"location":"api/cli/#causaliq_core.cli.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Entry point for the CLI.</p>"},{"location":"api/graph/","title":"Graph Module Overview","text":"<p>The <code>causaliq_core.graph</code> module provides graph-related classes and utilities for representing different types of graphs used in causal discovery algorithms, including directed acyclic graphs (DAGs), partially directed acyclic graphs (PDAGs), and summary dependence graphs (SDGs).</p>"},{"location":"api/graph/#core-components","title":"Core Components","text":""},{"location":"api/graph/#sdg-summary-dependence-graph","title":"SDG - Summary Dependence Graph","text":"<p>Base graph class supporting mixed edge types:</p> <ul> <li>Directed, undirected, and bidirected edges</li> <li>General graph operations and validation</li> <li>Foundation for specialized graph types</li> </ul>"},{"location":"api/graph/#pdag-partially-directed-acyclic-graph","title":"PDAG - Partially Directed Acyclic Graph","text":"<p>Specialized graph for causal discovery:</p> <ul> <li>Directed and undirected edges (no bidirected)</li> <li>Represents uncertainty in edge orientation</li> <li>Used in constraint-based causal discovery</li> </ul>"},{"location":"api/graph/#dag-directed-acyclic-graph","title":"DAG - Directed Acyclic Graph","text":"<p>Fully oriented causal structures:</p> <ul> <li>Only directed edges</li> <li>Represents definite causal relationships</li> <li>Topological ordering and string representation</li> </ul>"},{"location":"api/graph/#graph-conversion-functions","title":"Graph Conversion Functions","text":"<p>Transform between graph representations:</p> <ul> <li><code>dag_to_pdag()</code> - DAG to equivalence class PDAG</li> <li><code>pdag_to_cpdag()</code> - Complete a PDAG to CPDAG form</li> <li><code>extend_pdag()</code> - Extend PDAG to consistent DAG</li> <li><code>is_cpdag()</code> - Check if PDAG is completed</li> <li><code>dict_to_adjmat()</code> - Convert dictionary to adjacency matrix DataFrame</li> </ul>"},{"location":"api/graph/#io-functions","title":"I/O Functions","text":""},{"location":"api/graph/#common-io-functions","title":"Common I/O Functions","text":"<p>Unified interface for reading and writing graphs:</p> <ul> <li><code>read()</code> - Automatically detects format and reads graphs</li> <li><code>write()</code> - Automatically detects format and writes graphs</li> <li>Supports <code>.csv</code> (Bayesys) and <code>.tetrad</code> (Tetrad) formats</li> <li>Available directly from <code>causaliq_core.graph</code> for convenience</li> </ul>"},{"location":"api/graph/#bayesys-format-io","title":"Bayesys Format I/O","text":"<p>CSV-based graph file format:</p> <ul> <li><code>read()</code> - Read graphs from Bayesys CSV files</li> <li><code>write()</code> - Write graphs to Bayesys CSV format</li> </ul>"},{"location":"api/graph/#tetrad-format-io","title":"Tetrad Format I/O","text":"<p>Native Tetrad software format:</p> <ul> <li><code>read()</code> - Read graphs from Tetrad format files</li> <li><code>write()</code> - Write graphs to Tetrad format</li> <li>Supports both DAGs and PDAGs</li> </ul>"},{"location":"api/graph/#tetrad-format-io_1","title":"Tetrad Format I/O","text":"<p>Native Tetrad graph file format:</p> <ul> <li><code>read()</code> - Read graphs from Tetrad format files</li> <li><code>write()</code> - Write graphs to Tetrad format</li> <li>Supports both DAGs and PDAGs</li> </ul>"},{"location":"api/graph/#constants","title":"Constants","text":""},{"location":"api/graph/#bayesys_versions","title":"<code>BAYESYS_VERSIONS</code>","text":"<p>List of supported BayeSys versions for graph comparison semantics.</p> <p>Value: <code>['v1.3', 'v1.5+']</code></p> <p>Usage:</p> <pre><code>from causaliq_core.graph import BAYESYS_VERSIONS\n\n# Check version compatibility\nif version in BAYESYS_VERSIONS:\n    print(f\"Version {version} is supported\")\n</code></pre>"},{"location":"api/graph/#functions","title":"Functions","text":""},{"location":"api/graph/#adjmatcolumns","title":"<code>adjmat(columns)</code>","text":"<p>Create an adjacency matrix with specified entries.</p> <p>Parameters:</p> <ul> <li><code>columns</code> (dict): Data for matrix specified by column, where each key is a column name and each value is a list of integers representing edge types</li> </ul> <p>Returns:</p> <ul> <li><code>DataFrame</code>: The adjacency matrix with proper indexing</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>: If argument types are incorrect</li> <li><code>ValueError</code>: If values specified are invalid (wrong lengths or invalid edge codes)</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import adjmat, EdgeType\n\n# Create a simple adjacency matrix\ncolumns = {\n    'A': [0, 1, 0],  # No edge, directed edge, no edge\n    'B': [0, 0, 1],  # No edge, no edge, directed edge  \n    'C': [0, 0, 0]   # No edge, no edge, no edge\n}\nadj_matrix = adjmat(columns)\n</code></pre>"},{"location":"api/graph/#classes","title":"Classes","text":""},{"location":"api/graph/#edgemark","title":"<code>EdgeMark</code>","text":"<p>Enumeration of supported 'ends' of an edge in a graph.</p> <p>Values:</p> <ul> <li><code>NONE = 0</code>: No marking on edge end</li> <li><code>LINE = 1</code>: Line marking (e.g., for undirected edges)</li> <li><code>ARROW = 2</code>: Arrow marking (e.g., for directed edges)  </li> <li><code>CIRCLE = 3</code>: Circle marking (e.g., for partial direction)</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import EdgeMark\n\n# Check edge marking\nif edge_end == EdgeMark.ARROW:\n    print(\"This end is directed\")\n</code></pre>"},{"location":"api/graph/#edgetype","title":"<code>EdgeType</code>","text":"<p>Enumeration of supported edge types and their symbols, combining start and end markings.</p> <p>Structure:</p> <p>Each edge type is defined as a tuple containing: - <code>(value, start_mark, end_mark, symbol)</code></p> <p>Usage:</p> <pre><code>from causaliq_core.graph import EdgeType, EdgeMark\n\n# Access edge type components\nedge = EdgeType.DIRECTED\nprint(f\"Symbol: {edge.symbol}\")\nprint(f\"Start: {edge.start_mark}\")\nprint(f\"End: {edge.end_mark}\")\n</code></pre>"},{"location":"api/graph/#reference","title":"Reference","text":"<p>Graph-related enums and utilities for CausalIQ Core.</p> <p>Modules:</p> <ul> <li> <code>convert</code>           \u2013            </li> <li> <code>dag</code>           \u2013            </li> <li> <code>enums</code>           \u2013            <p>Graph-related enumerations for CausalIQ Core.</p> </li> <li> <code>io</code>           \u2013            <p>Graph I/O module for reading and writing various graph file formats.</p> </li> <li> <code>pdag</code>           \u2013            </li> <li> <code>sdg</code>           \u2013            <p>Simple Dependency Graph (SDG)</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>NotDAGError</code>           \u2013            <p>Indicate graph is not a DAG when one is expected.</p> </li> <li> <code>EdgeMark</code>           \u2013            <p>Supported 'ends' of an edge in a graph.</p> </li> <li> <code>EdgeType</code>           \u2013            <p>Supported edge types and their symbols.</p> </li> <li> <code>NotPDAGError</code>           \u2013            <p>Indicate graph is not a PDAG when one is expected.</p> </li> </ul>"},{"location":"api/graph/#causaliq_core.graph-classes","title":"Classes","text":""},{"location":"api/graph/#causaliq_core.graph.NotDAGError","title":"NotDAGError","text":"<p>Indicate graph is not a DAG when one is expected.</p>"},{"location":"api/graph/#causaliq_core.graph.EdgeMark","title":"EdgeMark","text":"<p>Supported 'ends' of an edge in a graph.</p>"},{"location":"api/graph/#causaliq_core.graph.EdgeType","title":"EdgeType","text":"<p>Supported edge types and their symbols.</p>"},{"location":"api/graph/#causaliq_core.graph.NotPDAGError","title":"NotPDAGError","text":"<p>Indicate graph is not a PDAG when one is expected.</p>"},{"location":"api/graph/#implementation-notes","title":"Implementation Notes","text":"<p>These classes and functions provide a standardised way to represent and manipulate different graph types commonly used in causal discovery algorithms. The hierarchy (SDG \u2192 PDAG \u2192 DAG) reflects increasing constraints on edge types and graph structure.</p>"},{"location":"api/graph_convert/","title":"Graph Conversion Functions","text":"<p>The <code>convert</code> module provides functions for transforming between different graph representations used in causal discovery algorithms and utilities for working with adjacency matrices.</p>"},{"location":"api/graph_convert/#functions","title":"Functions","text":""},{"location":"api/graph_convert/#dag_to_pdagdag","title":"<code>dag_to_pdag(dag)</code>","text":"<p>Convert a DAG to its corresponding PDAG representation (equivalence class).</p> <p>Parameters:</p> <ul> <li><code>dag</code> (DAG): The directed acyclic graph to convert</li> </ul> <p>Returns:</p> <ul> <li><code>PDAG</code>: PDAG representing the Markov equivalence class</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import DAG, dag_to_pdag\n\n# Create a DAG\ndag = DAG(['X', 'Y', 'Z'], [('X', '-&gt;', 'Y'), ('Y', '-&gt;', 'Z')])\n\n# Convert to PDAG equivalence class\npdag = dag_to_pdag(dag)\n</code></pre>"},{"location":"api/graph_convert/#pdag_to_cpdagpdag","title":"<code>pdag_to_cpdag(pdag)</code>","text":"<p>Convert a PDAG to its completed PDAG (CPDAG) form.</p> <p>Parameters:</p> <ul> <li><code>pdag</code> (PDAG): The partially directed graph to complete</li> </ul> <p>Returns:</p> <ul> <li><code>PDAG</code> or <code>None</code>: Completed PDAG, or None if completion fails</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import PDAG, pdag_to_cpdag\n\n# Create a PDAG\npdag = PDAG(['A', 'B', 'C'], [('A', '--', 'B'), ('B', '-&gt;', 'C')])\n\n# Complete to CPDAG\ncpdag = pdag_to_cpdag(pdag)\n</code></pre>"},{"location":"api/graph_convert/#dict_to_adjmatadjmat_dict-labelsnone","title":"<code>dict_to_adjmat(adjmat_dict, labels=None)</code>","text":"<p>Convert a dictionary representation of an adjacency matrix to a pandas DataFrame.</p> <p>Parameters:</p> <ul> <li><code>adjmat_dict</code> (Dict): Dictionary with (row, col) tuple keys and numeric values</li> <li><code>labels</code> (List[str], optional): Variable labels. If None, creates labels A, B, C, etc.</li> </ul> <p>Returns:</p> <ul> <li><code>DataFrame</code>: Adjacency matrix as a pandas DataFrame</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>: If adjmat_dict is not a dictionary or labels is not a list</li> <li><code>ValueError</code>: If keys are not tuples of length 2 or contain non-integer indices</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph.convert import dict_to_adjmat\n\n# Create adjacency matrix from dictionary\nadjmat_dict = {(0, 1): 1.0, (1, 2): 1.0}\nlabels = ['X', 'Y', 'Z']\ndf = dict_to_adjmat(adjmat_dict, labels)\n</code></pre>"},{"location":"api/graph_convert/#extend_pdagpdag","title":"<code>extend_pdag(pdag)</code>","text":"<p>Extend a PDAG to a consistent DAG by orienting undirected edges.</p> <p>Parameters:</p> <ul> <li><code>pdag</code> (PDAG): The partially directed graph to extend</li> </ul> <p>Returns:</p> <ul> <li><code>DAG</code>: A DAG extension of the PDAG</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import PDAG, extend_pdag\n\n# Create a PDAG\npdag = PDAG(['X', 'Y'], [('X', '--', 'Y')])\n\n# Extend to DAG\ndag = extend_pdag(pdag)\n</code></pre>"},{"location":"api/graph_convert/#is_cpdagpdag","title":"<code>is_cpdag(pdag)</code>","text":"<p>Check whether a PDAG is a completed PDAG (CPDAG).</p> <p>Parameters:</p> <ul> <li><code>pdag</code> (PDAG): The graph to check</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if the PDAG is completed, False otherwise</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import PDAG, is_cpdag\n\n# Check if PDAG is complete\npdag = PDAG(['A', 'B'], [('A', '-&gt;', 'B')])\nis_complete = is_cpdag(pdag)  # True\n</code></pre>"},{"location":"api/graph_convert/#reference","title":"Reference","text":"<p>Functions:</p> <ul> <li> <code>dag_to_pdag</code>             \u2013              <p>Generates PDAG representing equivalence class DAG belongs to.</p> </li> <li> <code>pdag_to_cpdag</code>             \u2013              <p>Generates a completed PDAG (CPDAG) from supplied PDAG</p> </li> <li> <code>is_cpdag</code>             \u2013              <p>Whether the PDAG is a Completed PDAG (CPDAG)</p> </li> <li> <code>extend_pdag</code>             \u2013              <p>Generates a DAG which extends a PDAG (i.e. is a member of the</p> </li> <li> <code>dict_to_adjmat</code>             \u2013              <p>Create an adjacency matrix with specified entries.</p> </li> </ul>"},{"location":"api/graph_convert/#causaliq_core.graph.convert-classes","title":"Classes","text":""},{"location":"api/graph_convert/#causaliq_core.graph.convert-functions","title":"Functions","text":""},{"location":"api/graph_convert/#causaliq_core.graph.convert.dag_to_pdag","title":"dag_to_pdag","text":"<pre><code>dag_to_pdag(dag: DAG) -&gt; PDAG\n</code></pre> <p>Generates PDAG representing equivalence class DAG belongs to.</p> <p>Uses the algorithm in \"A Transformational Characterization of Equivalent Bayesian Network Structures\", Chickering, 1995. Step numbers in comments refer to algorithm step numbers in paper.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if dag is not of type DAG</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PDAG</code>           \u2013            <p>PDAG for equivalence class that dag belongs to</p> </li> </ul>"},{"location":"api/graph_convert/#causaliq_core.graph.convert.dag_to_pdag(dag)","title":"<code>dag</code>","text":"(<code>DAG</code>)           \u2013            <p>DAG whose PDAG is required.</p>"},{"location":"api/graph_convert/#causaliq_core.graph.convert.pdag_to_cpdag","title":"pdag_to_cpdag","text":"<pre><code>pdag_to_cpdag(pdag: PDAG) -&gt; Union[PDAG, None]\n</code></pre> <p>Generates a completed PDAG (CPDAG) from supplied PDAG</p> <p>:param PDAG pdag: PDAG to be completed</p> <p>:raises TypeError: if pdag is not of type PDAG :raises ValueError: if pdag is non-extendable</p> <p>:returns PDAG/None: CPDAG corresponding to pdag</p>"},{"location":"api/graph_convert/#causaliq_core.graph.convert.is_cpdag","title":"is_cpdag","text":"<pre><code>is_cpdag(pdag: PDAG) -&gt; bool\n</code></pre> <p>Whether the PDAG is a Completed PDAG (CPDAG)</p> <p>:param PDAG pdag: PDAG to check</p> <p>:raises ValueError: if PDAG is not extendable</p> <p>:returns bool: True if CPDAG, otherwise False</p>"},{"location":"api/graph_convert/#causaliq_core.graph.convert.extend_pdag","title":"extend_pdag","text":"<pre><code>extend_pdag(pdag: PDAG) -&gt; DAG\n</code></pre> <p>Generates a DAG which extends a PDAG (i.e. is a member of the equivalence class the PDAG represents)</p> <p>Uses the algorithm in \"A simple algorithm to construct a consistent extension of a partially oriented graph\", Dor and Tarsi, 1992</p> <p>:param PDAG pdag: PDAG from which DAG derived</p> <p>:raises TypeError: if pdag is not of type PDAG :raises ValueError: if pdag is not extendable (example is                     an undirected square PDAG)</p> <p>:returns DAG: extension of pdag</p>"},{"location":"api/graph_convert/#causaliq_core.graph.convert.dict_to_adjmat","title":"dict_to_adjmat","text":"<pre><code>dict_to_adjmat(columns: Optional[Dict[str, List[int]]] = None) -&gt; DataFrame\n</code></pre> <p>Create an adjacency matrix with specified entries.</p> <p>:param dict columns: data for matrix specified by column</p> <p>:raises TypeError: if arg types incorrect :raises ValueError: if values specified are invalid</p> <p>:returns DataFrame: the adjacency matrix</p>"},{"location":"api/graph_dag/","title":"Graph DAG Module","text":"<p>The <code>DAG</code> (Directed Acyclic Graph) class provides functionality for working with fully directed acyclic graphs, commonly used to represent causal structures.</p>"},{"location":"api/graph_dag/#classes","title":"Classes","text":""},{"location":"api/graph_dag/#dag","title":"<code>DAG</code>","text":"<p>Directed Acyclic Graph class for representing fully oriented causal structures.</p> <p>Features:</p> <ul> <li>Fully directed edges only</li> <li>Strict acyclicity enforcement</li> <li>Topological ordering</li> <li>String representation (bnlearn format)</li> <li>Causal model representation</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import DAG\n\n# Create a DAG\nnodes = ['X', 'Y', 'Z']\nedges = [\n    ('X', '-&gt;', 'Y'),    # X causes Y\n    ('Y', '-&gt;', 'Z'),    # Y causes Z\n]\ndag = DAG(nodes, edges)\n\n# Get topological ordering\nfor node in dag.ordered_nodes():\n    print(f\"Node: {node}\")\n\n# Get string representation\nprint(dag.to_string())  # e.g. [X][Y|X][Z|Y]\n</code></pre>"},{"location":"api/graph_dag/#notdagerror","title":"<code>NotDAGError</code>","text":"<p>Exception raised when attempting to create an invalid DAG (e.g., contains cycles).</p>"},{"location":"api/graph_dag/#reference","title":"Reference","text":"<p>Classes:</p> <ul> <li> <code>NotDAGError</code>           \u2013            <p>Indicate graph is not a DAG when one is expected.</p> </li> <li> <code>DAG</code>           \u2013            <p>Directed Acyclic Graph (DAG).</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag-classes","title":"Classes","text":""},{"location":"api/graph_dag/#causaliq_core.graph.dag.NotDAGError","title":"NotDAGError","text":"<p>Indicate graph is not a DAG when one is expected.</p>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG","title":"DAG","text":"<pre><code>DAG(nodes: List[str], edges: List[Tuple[str, str, str]])\n</code></pre> <p>Directed Acyclic Graph (DAG).</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>nodes</code>               (<code>List[str]</code>)           \u2013            <p>Graph nodes in alphabetical order.</p> </li> <li> <code>edges</code>               (<code>Dict[Tuple[str, str], EdgeType]</code>)           \u2013            <p>Graph edges {(node1, node2): EdgeType}.</p> </li> <li> <code>is_directed</code>               (<code>bool</code>)           \u2013            <p>Always True for DAGs.</p> </li> <li> <code>parents</code>               (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of node {node: [parents]}.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If nodes and edges not both lists.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If node or edge invalid.</p> </li> <li> <code>NotDAGError</code>             \u2013            <p>If graph is not a DAG.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotDAGError</code>             \u2013            <p>If graph is not a DAG.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ordered_nodes</code>             \u2013              <p>Generator which returns nodes in a topological order.</p> </li> <li> <code>to_string</code>             \u2013              <p>Compact (bnlearn) string representation of DAG e.g. <code>[A][B][C|A:B]</code>.</p> </li> <li> <code>__str__</code>             \u2013              <p>Return a human-readable description of the DAG.</p> </li> <li> <code>rename</code>             \u2013              <p>Rename nodes in place according to name map.</p> </li> <li> <code>partial_order</code>             \u2013              <p>Return partial topological ordering for the directed part of a</p> </li> <li> <code>is_DAG</code>             \u2013              <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> </li> <li> <code>is_PDAG</code>             \u2013              <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> </li> <li> <code>undirected_trees</code>             \u2013              <p>Return undirected trees present in graph.</p> </li> <li> <code>components</code>             \u2013              <p>Return components present in graph.</p> </li> <li> <code>number_components</code>             \u2013              <p>Return number of components (including unconnected nodes) in graph.</p> </li> <li> <code>to_adjmat</code>             \u2013              <p>Return an adjacency matrix representation of the graph.</p> </li> <li> <code>__eq__</code>             \u2013              <p>Test if graph is identical to this one.</p> </li> <li> <code>edge_reversible</code>             \u2013              <p>Return whether specified edge is in CPDAG and is reversible.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes present in the graph.</p>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>Edges which define the graph connections as list of tuples: (node1, dependency symbol, node2).</p>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes present in the graph.</p>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>Edges which define the graph connections.</p>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG-functions","title":"Functions","text":""},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.ordered_nodes","title":"ordered_nodes","text":"<pre><code>ordered_nodes() -&gt; Generator[str, None, None]\n</code></pre> <p>Generator which returns nodes in a topological order.</p> <p>Yields:</p> <ul> <li> <code>str</code>           \u2013            <p>Next node in topological order.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the graph has cycles (shouldn't happen for a DAG).</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.to_string","title":"to_string","text":"<pre><code>to_string() -&gt; str\n</code></pre> <p>Compact (bnlearn) string representation of DAG e.g. <code>[A][B][C|A:B]</code>.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Description of graph.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a human-readable description of the DAG.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Description of DAG.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.rename","title":"rename","text":"<pre><code>rename(name_map: Dict[str, str]) -&gt; None\n</code></pre> <p>Rename nodes in place according to name map.</p> <p>Parameters:</p> <ul> <li> <code>name_map</code> \u00b6              (<code>Dict[str, str]</code>)           \u2013            <p>Name mapping {name: new name}. Must have mapping for every node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values e.g. unknown node names.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.partial_order","title":"partial_order  <code>classmethod</code>","text":"<pre><code>partial_order(\n    parents: Dict[str, List[str]],\n    nodes: Optional[Union[List[str], Set[str]]] = None,\n    new_arc: Optional[Tuple[str, str]] = None,\n) -&gt; Optional[List[Set[str]]]\n</code></pre> <p>Return partial topological ordering for the directed part of a graph.</p> <p>The graph is specified by list of parents for each node.</p> <p>Parameters:</p> <ul> <li> <code>parents</code> \u00b6              (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of each node {node: [parents]}.</p> </li> <li> <code>nodes</code> \u00b6              (<code>Optional[Union[List[str], Set[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional complete list of nodes including parentless ones for use if parents argument doesn't include them already.</p> </li> <li> <code>new_arc</code> \u00b6              (<code>Optional[Tuple[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A new arc (n1, n2) to be added before order is evaluated. If the opposing arc is implied in parents then it is removed so that arc reversal is also supported. This argument facilitates seeing whether an arc addition or reversal would create a cycle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>Nodes in a partial topological order as list of sets or None if</p> </li> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>there is no ordering which means the graph is cyclic.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.is_DAG","title":"is_DAG","text":"<pre><code>is_DAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a DAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.is_PDAG","title":"is_PDAG","text":"<pre><code>is_PDAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a PDAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.undirected_trees","title":"undirected_trees","text":"<pre><code>undirected_trees() -&gt; List[Set[Union[Tuple[str, str], Tuple[str, None]]]]\n</code></pre> <p>Return undirected trees present in graph.</p> <p>Returns:</p> <ul> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>List of trees, each tree a set of tuples representing edges in tree</p> </li> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>(n1, n2) or a single isolated node (n1, None).</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.components","title":"components","text":"<pre><code>components() -&gt; List[List[str]]\n</code></pre> <p>Return components present in graph.</p> <p>Uses tree search algorithm to span the undirected graph to identify nodes in individual trees which are the spanning tree of each component.</p> <p>Returns:</p> <ul> <li> <code>List[List[str]]</code>           \u2013            <p>List of lists, each a list of sorted nodes in component.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.number_components","title":"number_components","text":"<pre><code>number_components() -&gt; int\n</code></pre> <p>Return number of components (including unconnected nodes) in graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of components.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.to_adjmat","title":"to_adjmat","text":"<pre><code>to_adjmat() -&gt; DataFrame\n</code></pre> <p>Return an adjacency matrix representation of the graph.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Adjacency matrix as a pandas DataFrame.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Test if graph is identical to this one.</p> <p>Parameters:</p> <ul> <li> <code>other</code> \u00b6              (<code>object</code>)           \u2013            <p>Graph to compare with self.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if other is identical to self.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.edge_reversible","title":"edge_reversible","text":"<pre><code>edge_reversible(edge: Tuple[str, str]) -&gt; bool\n</code></pre> <p>Return whether specified edge is in CPDAG and is reversible.</p> <p>Parameters:</p> <ul> <li> <code>edge</code> \u00b6              (<code>Tuple[str, str]</code>)           \u2013            <p>Edge to examine, (node1, node2).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether present and reversible, or not.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If edge argument has bad type.</p> </li> </ul>"},{"location":"api/graph_io_bayesys/","title":"Bayesys Format I/O","text":"<p>The <code>causaliq_core.graph.io.bayesys</code> module provides functions for reading and writing graphs in the Bayesys CSV format.</p>"},{"location":"api/graph_io_bayesys/#format-description","title":"Format Description","text":"<p>The Bayesys format uses CSV files to represent graphs where: - Each row represents an edge in the graph - Columns specify source node, edge type, and target node - Edge types include directed (<code>-&gt;</code>) and undirected (<code>--</code>) edges</p>"},{"location":"api/graph_io_bayesys/#functions","title":"Functions","text":""},{"location":"api/graph_io_bayesys/#readpath-str-all_nodes-optionalliststr-none-strict-bool-true-unionpdag-dag","title":"<code>read(path: str, all_nodes: Optional[List[str]] = None, strict: bool = True) -&gt; Union[PDAG, DAG]</code>","text":"<p>Read a graph from a Bayesys CSV format file.</p> <p>Parameters: - <code>path</code> (str): Full path name of file to read - <code>all_nodes</code> (List[str], optional): Complete list of nodes that should be included in the graph. If provided, nodes not appearing in edges will be added as isolated nodes - <code>strict</code> (bool): If True, enforces strict format validation</p> <p>Returns: - <code>PDAG</code> or <code>DAG</code>: Graph read from file. Returns DAG if all edges are directed, PDAG otherwise</p> <p>Raises: - <code>TypeError</code>: If path is not a string - <code>FileNotFoundError</code>: If file is not found - <code>FileFormatError</code>: If file format is invalid</p> <p>Example:</p> <pre><code>from causaliq_core.graph.io.bayesys import read\n\n# Read graph with automatic node detection\ngraph = read(\"data/graph.csv\")\n\n# Read graph with explicit node list\nall_nodes = ['A', 'B', 'C', 'D'] \ngraph = read(\"data/graph.csv\", all_nodes=all_nodes)\n</code></pre>"},{"location":"api/graph_io_bayesys/#writegraph-unionpdag-dag-path-str-none","title":"<code>write(graph: Union[PDAG, DAG], path: str) -&gt; None</code>","text":"<p>Write a graph to a Bayesys CSV format file.</p> <p>Parameters: - <code>graph</code> (PDAG or DAG): Graph to write - <code>path</code> (str): Full path name of file to create</p> <p>Raises: - <code>TypeError</code>: If graph is not a PDAG or DAG instance, or path is not a string - <code>OSError</code>: If file cannot be created</p> <p>Example:</p> <pre><code>from causaliq_core.graph import PDAG\nfrom causaliq_core.graph.io.bayesys import write\n\n# Create and write a PDAG\npdag = PDAG(['X', 'Y', 'Z'], [('X', '-&gt;', 'Y'), ('Y', '--', 'Z')])\nwrite(pdag, \"output/graph.csv\")\n</code></pre>"},{"location":"api/graph_io_bayesys/#file-format-details","title":"File Format Details","text":"<p>The CSV file contains rows with three columns: 1. Source node name 2. Edge type (<code>-&gt;</code> for directed, <code>--</code> for undirected) 3. Target node name</p> <p>Example CSV content: <pre><code>A,-&gt;,B\nB,--,C\nA,--,C\n</code></pre></p> <p>This represents a PDAG with nodes A, B, C where: - A \u2192 B (directed edge) - B \u2014 C (undirected edge) - A \u2014 C (undirected edge)</p>"},{"location":"api/graph_io_common/","title":"Common I/O Functions","text":"<p>The <code>causaliq_core.graph.io.common</code> module provides a unified interface for reading and writing graphs from different file formats. It automatically detects the file format based on the file suffix and delegates to the appropriate format-specific module.</p>"},{"location":"api/graph_io_common/#supported-formats","title":"Supported Formats","text":"Extension Format Module Description <code>.csv</code> Bayesys <code>bayesys</code> CSV-based format used by Bayesys software <code>.tetrad</code> Tetrad <code>tetrad</code> Native format used by Tetrad software"},{"location":"api/graph_io_common/#functions","title":"Functions","text":""},{"location":"api/graph_io_common/#readpath-str-unionpdag","title":"<code>read(path: str) -&gt; Union[PDAG]</code>","text":"<p>Read a graph from a file, automatically detecting the format from the file suffix.</p> <p>Parameters: - <code>path</code> (str): Full path name of file to read</p> <p>Returns: - <code>PDAG</code> or <code>DAG</code>: Graph read from file</p> <p>Raises: - <code>TypeError</code>: If path is not a string - <code>ValueError</code>: If file suffix is not supported - <code>FileNotFoundError</code>: If file is not found - <code>FileFormatError</code>: If file format is invalid</p> <p>Example:</p> <pre><code># Import from common module directly\nfrom causaliq_core.graph.io.common import read\n\n# Or import from top-level graph module (recommended)\nfrom causaliq_core.graph import read\n\n# Read Bayesys CSV file\ncsv_graph = read(\"data/graph.csv\")\n\n# Read Tetrad format file  \ntetrad_graph = read(\"data/graph.tetrad\")\n</code></pre>"},{"location":"api/graph_io_common/#writegraph-pdag-path-str-none","title":"<code>write(graph: PDAG, path: str) -&gt; None</code>","text":"<p>Write a graph to a file, automatically detecting the format from the file suffix.</p> <p>Parameters: - <code>graph</code> (PDAG): Graph to write to file - <code>path</code> (str): Full path name of file to write</p> <p>Raises: - <code>TypeError</code>: If bad argument types - <code>ValueError</code>: If file suffix is not supported - <code>FileNotFoundError</code>: If path to file does not exist</p> <p>Example:</p> <pre><code># Import from common module directly\nfrom causaliq_core.graph.io.common import write\n\n# Or import from top-level graph module (recommended)\nfrom causaliq_core.graph import write, DAG\n\n# Create a graph\ndag = DAG([\"A\", \"B\", \"C\"], [(\"A\", \"-&gt;\", \"B\"), (\"B\", \"-&gt;\", \"C\")])\n\n# Write to Bayesys CSV format\nwrite(dag, \"output/result.csv\")\n\n# Write to Tetrad format\nwrite(dag, \"output/result.tetrad\")\n</code></pre>"},{"location":"api/graph_io_common/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/graph_io_common/#format-detection","title":"Format Detection","text":"<p>The module uses the file extension to determine the appropriate format:</p> <pre><code># Import from top-level graph module (recommended)\nfrom causaliq_core.graph import read\n\n# These will use different I/O modules automatically\nbayesys_graph = read(\"data.csv\")      # Uses bayesys.read()\ntetrad_graph = read(\"data.tetrad\")    # Uses tetrad.read()\n</code></pre>"},{"location":"api/graph_io_common/#error-handling","title":"Error Handling","text":"<pre><code>from causaliq_core.graph import read\n\ntry:\n    graph = read(\"data.txt\")  # Unsupported format\nexcept ValueError as e:\n    print(f\"Unsupported format: {e}\")\n    # Output: \"common.read() unsupported file suffix: .txt\"\n</code></pre>"},{"location":"api/graph_io_common/#round-trip-operations","title":"Round-trip Operations","text":"<pre><code>from causaliq_core.graph import read, write\n\n# Read graph in one format\ngraph = read(\"input.csv\")\n\n# Write in different format  \nwrite(graph, \"output.tetrad\")\n\n# Verify round-trip\ngraph2 = read(\"output.tetrad\")\nassert set(graph.nodes) == set(graph2.nodes)\n</code></pre>"},{"location":"api/graph_io_common/#reference","title":"Reference","text":"<p>Functions:</p> <ul> <li> <code>read_graph</code>             \u2013              <p>Read a graph from a file, automatically detecting format from suffix.</p> </li> <li> <code>write_graph</code>             \u2013              <p>Write a graph to a file, automatically detecting format from suffix.</p> </li> </ul>"},{"location":"api/graph_io_common/#causaliq_core.graph.io.common.read_graph","title":"read_graph","text":"<pre><code>read_graph(path: str) -&gt; Union[PDAG]\n</code></pre> <p>Read a graph from a file, automatically detecting format from suffix.</p> <p>Supports: - .csv files (Bayesys format) - .tetrad files (Tetrad format)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union[PDAG]</code>           \u2013            <p>Graph read from file (PDAG or DAG).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If path is not a string.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If file suffix is not supported.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If file is not found.</p> </li> <li> <code>FileFormatError</code>             \u2013            <p>If file format is invalid.</p> </li> </ul>"},{"location":"api/graph_io_common/#causaliq_core.graph.io.common.read_graph(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Full path name of file to read.</p>"},{"location":"api/graph_io_common/#causaliq_core.graph.io.common.write_graph","title":"write_graph","text":"<pre><code>write_graph(graph: PDAG, path: str) -&gt; None\n</code></pre> <p>Write a graph to a file, automatically detecting format from suffix.</p> <p>Supports: - .csv files (Bayesys format) - .tetrad files (Tetrad format)</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad arg types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If file suffix is not supported.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If path to file does not exist.</p> </li> </ul>"},{"location":"api/graph_io_common/#causaliq_core.graph.io.common.write_graph(graph)","title":"<code>graph</code>","text":"(<code>PDAG</code>)           \u2013            <p>Graph to write to file.</p>"},{"location":"api/graph_io_common/#causaliq_core.graph.io.common.write_graph(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Full path name of file to write.</p>"},{"location":"api/graph_io_tetrad/","title":"Tetrad Format I/O","text":"<p>The <code>causaliq_core.graph.io.tetrad</code> module provides functions for reading and writing graphs in the Tetrad native format.</p>"},{"location":"api/graph_io_tetrad/#format-description","title":"Format Description","text":"<p>The Tetrad format is a text-based format used by the Tetrad software suite for representing graphs: - Each line represents an edge with numbered format - Supports directed (<code>--&gt;</code>) and undirected (<code>---</code>) edges - Nodes are identified by names, edges by source and target nodes</p>"},{"location":"api/graph_io_tetrad/#functions","title":"Functions","text":""},{"location":"api/graph_io_tetrad/#readpath-str-uniondag-pdag","title":"<code>read(path: str) -&gt; Union[DAG, PDAG]</code>","text":"<p>Read a graph from a Tetrad format file.</p> <p>Parameters: - <code>path</code> (str): Full path name of file to read</p> <p>Returns: - <code>DAG</code> or <code>PDAG</code>: Graph read from file. Returns DAG if all edges are directed, PDAG otherwise</p> <p>Raises: - <code>TypeError</code>: If path is not a string - <code>FileNotFoundError</code>: If file is not found - <code>FileFormatError</code>: If file format is invalid or contains syntax errors</p> <p>Example:</p> <pre><code>from causaliq_core.graph.io.tetrad import read\n\n# Read graph from Tetrad format file\ngraph = read(\"data/graph.tetrad\")\n</code></pre>"},{"location":"api/graph_io_tetrad/#writegraph-unionpdag-dag-path-str-none","title":"<code>write(graph: Union[PDAG, DAG], path: str) -&gt; None</code>","text":"<p>Write a graph to a Tetrad format file.</p> <p>Parameters: - <code>graph</code> (PDAG or DAG): Graph to write - <code>path</code> (str): Full path name of file to create</p> <p>Raises: - <code>TypeError</code>: If graph is not a PDAG or DAG instance, or path is not a string - <code>OSError</code>: If file cannot be created</p> <p>Example:</p> <pre><code>from causaliq_core.graph import DAG\nfrom causaliq_core.graph.io.tetrad import write\n\n# Create and write a DAG\ndag = DAG(['X', 'Y', 'Z'], [('X', '-&gt;', 'Y'), ('Y', '-&gt;', 'Z')])\nwrite(dag, \"output/graph.tetrad\")\n</code></pre>"},{"location":"api/graph_io_tetrad/#file-format-details","title":"File Format Details","text":"<p>The Tetrad format uses numbered lines to represent edges: - Each edge line starts with a number followed by a period - Format: <code>{number}. {source} {edge_type} {target}</code> - Edge types: <code>--&gt;</code> for directed, <code>---</code> for undirected</p> <p>Example Tetrad file content: <pre><code>Graph Nodes:\nX,Y,Z\n\nGraph Edges:\n1. X --&gt; Y\n2. Y --&gt; Z  \n</code></pre></p> <p>This represents a DAG with nodes X, Y, Z and directed edges X \u2192 Y \u2192 Z.</p>"},{"location":"api/graph_io_tetrad/#compatibility","title":"Compatibility","text":"<p>This module is compatible with graphs exported from: - Tetrad software suite - PCALG R package (when using Tetrad export format) - Other causal discovery tools that support Tetrad format</p>"},{"location":"api/graph_pdag/","title":"Graph PDAG Module","text":"<p>The <code>PDAG</code> (Partially Directed Acyclic Graph) class extends SDG to work specifically with partially directed acyclic graphs used in causal discovery.</p>"},{"location":"api/graph_pdag/#classes","title":"Classes","text":""},{"location":"api/graph_pdag/#pdag","title":"<code>PDAG</code>","text":"<p>Partially Directed Acyclic Graph class for representing causal graph structures.</p> <p>Features:</p> <ul> <li>Directed and undirected edges only</li> <li>Acyclicity validation</li> <li>Causal discovery algorithm support</li> <li>Conversion to/from other graph types</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import PDAG\n\n# Create a PDAG\nnodes = ['X', 'Y', 'Z']\nedges = [\n    ('X', '-&gt;', 'Y'),    # Directed edge (oriented)\n    ('Y', '--', 'Z'),    # Undirected edge (unoriented)\n]\npdag = PDAG(nodes, edges)\n</code></pre>"},{"location":"api/graph_pdag/#notpdagerror","title":"<code>NotPDAGError</code>","text":"<p>Exception raised when attempting to create an invalid PDAG.</p>"},{"location":"api/graph_pdag/#reference","title":"Reference","text":"<p>Classes:</p> <ul> <li> <code>NotPDAGError</code>           \u2013            <p>Indicate graph is not a PDAG when one is expected.</p> </li> <li> <code>PDAG</code>           \u2013            <p>Partially directed acyclic graph (PDAG).</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag-classes","title":"Classes","text":""},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.NotPDAGError","title":"NotPDAGError","text":"<p>Indicate graph is not a PDAG when one is expected.</p>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG","title":"PDAG","text":"<pre><code>PDAG(nodes: List[str], edges: List[Tuple[str, str, str]])\n</code></pre> <p>Partially directed acyclic graph (PDAG).</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>nodes</code>               (<code>List[str]</code>)           \u2013            <p>Graph nodes in alphabetical order.</p> </li> <li> <code>edges</code>               (<code>Dict[Tuple[str, str], EdgeType]</code>)           \u2013            <p>Graph edges {(node1, node2): EdgeType}.</p> </li> <li> <code>is_directed</code>               (<code>bool</code>)           \u2013            <p>Graph only has directed (causal) edges.</p> </li> <li> <code>parents</code>               (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of node {node: [parents]}.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If nodes and edges not both lists.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If node or edge invalid.</p> </li> <li> <code>NotPDAGError</code>             \u2013            <p>If graph is not a PDAG.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotPDAGError</code>             \u2013            <p>If graph is not a PDAG.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>edge_reversible</code>             \u2013              <p>Return whether specified edge is in CPDAG and is reversible.</p> </li> <li> <code>rename</code>             \u2013              <p>Rename nodes in place according to name map.</p> </li> <li> <code>partial_order</code>             \u2013              <p>Return partial topological ordering for the directed part of a</p> </li> <li> <code>is_DAG</code>             \u2013              <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> </li> <li> <code>is_PDAG</code>             \u2013              <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> </li> <li> <code>undirected_trees</code>             \u2013              <p>Return undirected trees present in graph.</p> </li> <li> <code>components</code>             \u2013              <p>Return components present in graph.</p> </li> <li> <code>number_components</code>             \u2013              <p>Return number of components (including unconnected nodes) in graph.</p> </li> <li> <code>to_adjmat</code>             \u2013              <p>Return an adjacency matrix representation of the graph.</p> </li> <li> <code>__str__</code>             \u2013              <p>Return a human-readable description of the graph.</p> </li> <li> <code>__eq__</code>             \u2013              <p>Test if graph is identical to this one.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes present in the graph.</p>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>Edges which define the graph connections as list of tuples: (node1, dependency symbol, node2).</p>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes present in the graph.</p>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>Edges which define the graph connections.</p>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG-functions","title":"Functions","text":""},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.edge_reversible","title":"edge_reversible","text":"<pre><code>edge_reversible(edge: Tuple[str, str]) -&gt; bool\n</code></pre> <p>Return whether specified edge is in CPDAG and is reversible.</p> <p>Parameters:</p> <ul> <li> <code>edge</code> \u00b6              (<code>Tuple[str, str]</code>)           \u2013            <p>Edge to examine, (node1, node2).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether present and reversible, or not.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If edge argument has bad type.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.rename","title":"rename","text":"<pre><code>rename(name_map: Dict[str, str]) -&gt; None\n</code></pre> <p>Rename nodes in place according to name map.</p> <p>Parameters:</p> <ul> <li> <code>name_map</code> \u00b6              (<code>Dict[str, str]</code>)           \u2013            <p>Name mapping {name: new name}. Must have mapping for every node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values e.g. unknown node names.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.partial_order","title":"partial_order  <code>classmethod</code>","text":"<pre><code>partial_order(\n    parents: Dict[str, List[str]],\n    nodes: Optional[Union[List[str], Set[str]]] = None,\n    new_arc: Optional[Tuple[str, str]] = None,\n) -&gt; Optional[List[Set[str]]]\n</code></pre> <p>Return partial topological ordering for the directed part of a graph.</p> <p>The graph is specified by list of parents for each node.</p> <p>Parameters:</p> <ul> <li> <code>parents</code> \u00b6              (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of each node {node: [parents]}.</p> </li> <li> <code>nodes</code> \u00b6              (<code>Optional[Union[List[str], Set[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional complete list of nodes including parentless ones for use if parents argument doesn't include them already.</p> </li> <li> <code>new_arc</code> \u00b6              (<code>Optional[Tuple[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A new arc (n1, n2) to be added before order is evaluated. If the opposing arc is implied in parents then it is removed so that arc reversal is also supported. This argument facilitates seeing whether an arc addition or reversal would create a cycle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>Nodes in a partial topological order as list of sets or None if</p> </li> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>there is no ordering which means the graph is cyclic.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.is_DAG","title":"is_DAG","text":"<pre><code>is_DAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a DAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.is_PDAG","title":"is_PDAG","text":"<pre><code>is_PDAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a PDAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.undirected_trees","title":"undirected_trees","text":"<pre><code>undirected_trees() -&gt; List[Set[Union[Tuple[str, str], Tuple[str, None]]]]\n</code></pre> <p>Return undirected trees present in graph.</p> <p>Returns:</p> <ul> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>List of trees, each tree a set of tuples representing edges in tree</p> </li> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>(n1, n2) or a single isolated node (n1, None).</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.components","title":"components","text":"<pre><code>components() -&gt; List[List[str]]\n</code></pre> <p>Return components present in graph.</p> <p>Uses tree search algorithm to span the undirected graph to identify nodes in individual trees which are the spanning tree of each component.</p> <p>Returns:</p> <ul> <li> <code>List[List[str]]</code>           \u2013            <p>List of lists, each a list of sorted nodes in component.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.number_components","title":"number_components","text":"<pre><code>number_components() -&gt; int\n</code></pre> <p>Return number of components (including unconnected nodes) in graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of components.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.to_adjmat","title":"to_adjmat","text":"<pre><code>to_adjmat() -&gt; DataFrame\n</code></pre> <p>Return an adjacency matrix representation of the graph.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Adjacency matrix as a pandas DataFrame.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a human-readable description of the graph.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String description of graph.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Test if graph is identical to this one.</p> <p>Parameters:</p> <ul> <li> <code>other</code> \u00b6              (<code>object</code>)           \u2013            <p>Graph to compare with self.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if other is identical to self.</p> </li> </ul>"},{"location":"api/graph_sdg/","title":"Graph SDG Module","text":"<p>This module supports Simple Dependency Graphs (SDGs) which are a general form of graph that has at most one edge between any pair of nodes.</p> <p>The two endpoints of each edge can be a head \"&gt;\", tail \"-\" or circle \"o\" (which means either head or tail).</p> <p>This format can represent most dependency graph types including:  - Markov Graphs  - Directed Acyclic Graphs (DAGs)  - Partially Directed Acyclic Graphs (PDAGs)  - Maximal Ancestral Graphs (MAGs)  - Partial Ancestral Graphs (PAGs)</p>"},{"location":"api/graph_sdg/#classes","title":"Classes","text":""},{"location":"api/graph_sdg/#sdg","title":"<code>SDG</code>","text":"<p>Simple Dependency Graph class that supports multiple edge types.</p> <p>Features:</p> <ul> <li>Mixed edge types (directed, undirected, bidirected)</li> <li>Node and edge validation</li> <li>Graph manipulation and traversal</li> <li>Adjacency matrix representation</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import SDG, EdgeType\n\n# Create an SDG with mixed edges\nnodes = ['A', 'B', 'C']\nedges = [\n    ('A', '-&gt;', 'B'),    # Directed edge\n    ('B', '--', 'C'),    # Undirected edge\n]\nsdg = SDG(nodes, edges)\n</code></pre>"},{"location":"api/graph_sdg/#reference","title":"Reference","text":"<p>Simple Dependency Graph (SDG)</p> <p>This module supports Simple Dependency Graphs (SDGs) which are a general form of graph that has at most one edge between any pair of nodes.</p> <p>The two endpoints of each edge can be a head \"&gt;\", tail \"-\" or circle \"o\" (which means either head or tail).</p> This format can represent most dependency graph types including <ul> <li>Markov Graphs</li> <li>Directed Acyclic Graphs (DAGs)</li> <li>Partially Directed Acyclic Graphs (PDAGs)</li> <li>Maximal Ancestral Graphs (MAGs)</li> <li>Partial Ancestral Graphs (PAGs)</li> </ul> <p>Classes:</p> <ul> <li> <code>SDG</code>           \u2013            <p>Base class for simple dependency graphs (one edge between vertices).</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg-classes","title":"Classes","text":""},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG","title":"SDG","text":"<pre><code>SDG(nodes: List[str], edges: List[Tuple[str, str, str]])\n</code></pre> <p>Base class for simple dependency graphs (one edge between vertices).</p> <p>Simple Dependency Graphs (SDGs) are a general form of graph that has at most one edge between any pair of nodes. The two endpoints of each edge can be a     head \"&gt;\", tail \"-\" or circle \"o\" (which means either head or tail).</p> <p>This format can represent most dependency graph types including: - Markov Graphs - Directed Acyclic Graphs (DAGs) - Partially Directed Acyclic Graphs (PDAGs) - Maximal Ancestral Graphs (MAGs) - Partial Ancestral Graphs (PAGs)</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>nodes</code>               (<code>List[str]</code>)           \u2013            <p>Graph nodes in alphabetical order.</p> </li> <li> <code>edges</code>               (<code>Dict[Tuple[str, str], EdgeType]</code>)           \u2013            <p>Graph edges {(node1, node2): EdgeType}.</p> </li> <li> <code>is_directed</code>               (<code>bool</code>)           \u2013            <p>Graph only has directed (causal) edges.</p> </li> <li> <code>is_partially_directed</code>               (<code>bool</code>)           \u2013            <p>Graph is partially directed.</p> </li> <li> <code>parents</code>               (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of node {node: [parents]}.</p> </li> <li> <code>has_directed_cycles</code>               (<code>bool</code>)           \u2013            <p>Contains any directed cycles.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If nodes and edges are not both lists.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If node or edge is invalid.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> </ul> <p>Methods:</p> <ul> <li> <code>rename</code>             \u2013              <p>Rename nodes in place according to name map.</p> </li> <li> <code>partial_order</code>             \u2013              <p>Return partial topological ordering for the directed part of a</p> </li> <li> <code>is_DAG</code>             \u2013              <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> </li> <li> <code>is_PDAG</code>             \u2013              <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> </li> <li> <code>undirected_trees</code>             \u2013              <p>Return undirected trees present in graph.</p> </li> <li> <code>components</code>             \u2013              <p>Return components present in graph.</p> </li> <li> <code>number_components</code>             \u2013              <p>Return number of components (including unconnected nodes) in graph.</p> </li> <li> <code>to_adjmat</code>             \u2013              <p>Return an adjacency matrix representation of the graph.</p> </li> <li> <code>__str__</code>             \u2013              <p>Return a human-readable description of the graph.</p> </li> <li> <code>__eq__</code>             \u2013              <p>Test if graph is identical to this one.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes present in the graph.</p>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>Edges which define the graph connections as list of tuples: (node1, dependency symbol, node2).</p>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>List of node names in the graph.</p>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>List of edge tuples in format (node1, edge_type_symbol, node2).</p>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG-functions","title":"Functions","text":""},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.rename","title":"rename","text":"<pre><code>rename(name_map: Dict[str, str]) -&gt; None\n</code></pre> <p>Rename nodes in place according to name map.</p> <p>Parameters:</p> <ul> <li> <code>name_map</code> \u00b6              (<code>Dict[str, str]</code>)           \u2013            <p>Name mapping {name: new name}. Must have mapping for every node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values e.g. unknown node names.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.partial_order","title":"partial_order  <code>classmethod</code>","text":"<pre><code>partial_order(\n    parents: Dict[str, List[str]],\n    nodes: Optional[Union[List[str], Set[str]]] = None,\n    new_arc: Optional[Tuple[str, str]] = None,\n) -&gt; Optional[List[Set[str]]]\n</code></pre> <p>Return partial topological ordering for the directed part of a graph.</p> <p>The graph is specified by list of parents for each node.</p> <p>Parameters:</p> <ul> <li> <code>parents</code> \u00b6              (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of each node {node: [parents]}.</p> </li> <li> <code>nodes</code> \u00b6              (<code>Optional[Union[List[str], Set[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional complete list of nodes including parentless ones for use if parents argument doesn't include them already.</p> </li> <li> <code>new_arc</code> \u00b6              (<code>Optional[Tuple[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A new arc (n1, n2) to be added before order is evaluated. If the opposing arc is implied in parents then it is removed so that arc reversal is also supported. This argument facilitates seeing whether an arc addition or reversal would create a cycle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>Nodes in a partial topological order as list of sets or None if</p> </li> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>there is no ordering which means the graph is cyclic.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.is_DAG","title":"is_DAG","text":"<pre><code>is_DAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a DAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.is_PDAG","title":"is_PDAG","text":"<pre><code>is_PDAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a PDAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.undirected_trees","title":"undirected_trees","text":"<pre><code>undirected_trees() -&gt; List[Set[Union[Tuple[str, str], Tuple[str, None]]]]\n</code></pre> <p>Return undirected trees present in graph.</p> <p>Returns:</p> <ul> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>List of trees, each tree a set of tuples representing edges in tree</p> </li> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>(n1, n2) or a single isolated node (n1, None).</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.components","title":"components","text":"<pre><code>components() -&gt; List[List[str]]\n</code></pre> <p>Return components present in graph.</p> <p>Uses tree search algorithm to span the undirected graph to identify nodes in individual trees which are the spanning tree of each component.</p> <p>Returns:</p> <ul> <li> <code>List[List[str]]</code>           \u2013            <p>List of lists, each a list of sorted nodes in component.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.number_components","title":"number_components","text":"<pre><code>number_components() -&gt; int\n</code></pre> <p>Return number of components (including unconnected nodes) in graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of components.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.to_adjmat","title":"to_adjmat","text":"<pre><code>to_adjmat() -&gt; DataFrame\n</code></pre> <p>Return an adjacency matrix representation of the graph.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Adjacency matrix as a pandas DataFrame.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a human-readable description of the graph.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String description of graph.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Test if graph is identical to this one.</p> <p>Parameters:</p> <ul> <li> <code>other</code> \u00b6              (<code>object</code>)           \u2013            <p>Graph to compare with self.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if other is identical to self.</p> </li> </ul>"},{"location":"api/main/","title":"Main Package","text":"<p>The main <code>causaliq_core</code> package provides core constants and metadata for the CausalIQ ecosystem.</p>"},{"location":"api/main/#constants","title":"Constants","text":""},{"location":"api/main/#software_version","title":"<code>SOFTWARE_VERSION</code>","text":"<p>Legacy software version constant for backward compatibility.</p> <p>Type: <code>int</code> Value: <code>229</code></p> <p>Usage:</p> <pre><code>from causaliq_core import SOFTWARE_VERSION\n\nprint(f\"Software version: {SOFTWARE_VERSION}\")\n</code></pre> <p>This constant was migrated from the legacy module and is maintained for compatibility with existing code.</p>"},{"location":"api/main/#package-metadata","title":"Package Metadata","text":"<p>The package also exports standard metadata:</p> <ul> <li><code>__version__</code>: Package version string (e.g., \"0.1.0\")</li> <li><code>VERSION</code>: Version as tuple for programmatic comparison</li> <li><code>__author__</code>, <code>__email__</code>: Author information</li> <li><code>__title__</code>, <code>__description__</code>: Package title and description</li> <li><code>__url__</code>, <code>__license__</code>: Repository URL and license</li> </ul> <p>Usage:</p> <pre><code>import causaliq_core\n\nprint(f\"Package version: {causaliq_core.__version__}\")\nprint(f\"Version tuple: {causaliq_core.VERSION}\")\n</code></pre>"},{"location":"api/overview/","title":"CausalIQ Core API Reference","text":"<p>This is the entry point for the API documentation. It is organised by module, with each module briefly described here to ease navigation of the API and avoid overlong pages.</p>"},{"location":"api/overview/#main-package","title":"Main Package","text":"<p>The main <code>causaliq_core</code> package exports: - <code>SOFTWARE_VERSION</code>: Legacy software version constant for compatibility - Package metadata (<code>__version__</code>, <code>VERSION</code>, etc.)</p>"},{"location":"api/overview/#modules","title":"Modules","text":""},{"location":"api/overview/#bayesian-networks","title":"Bayesian Networks","text":"<p>Bayesian Networks functionality including network structures, conditional distributions, and I/O operations.</p>"},{"location":"api/overview/#cli","title":"CLI","text":"<p>Command-line interface functionality for CausalIQ Core.</p>"},{"location":"api/overview/#graph","title":"Graph","text":"<p>Graph-related enumerations and utilities for edge types and marks used in causal discovery.</p>"},{"location":"api/overview/#utils","title":"Utils","text":"<p>Comprehensive utility module with specialized functional areas: - Mathematical Functions: Number formatting and logarithm calculations - Environment Detection: System information with caching - Random Numbers: Reproducible random number generation - Timing Utilities: Performance measurement and timeouts - Enhanced enumeration functionality</p>"},{"location":"api/utils/","title":"Utils Module Overview","text":"<p>The <code>causaliq_core.utils</code> module provides utility classes, enhanced enumeration functionality, mathematical utilities, random number utilities, and system utilities for common programming patterns used across the CausalIQ ecosystem.</p>"},{"location":"api/utils/#core-components","title":"Core Components","text":""},{"location":"api/utils/#mathematical-functions","title":"Mathematical Functions","text":"<p>Number formatting and logarithm calculations including:</p> <ul> <li><code>rndsf()</code> - Round to significant figures with precise formatting</li> <li><code>ln()</code> - Logarithm with configurable base (2, 10, or 'e')</li> </ul>"},{"location":"api/utils/#io-operations","title":"I/O Operations","text":"<p>File and path handling utilities:</p> <ul> <li><code>is_valid_path()</code> - Path validation and existence checking</li> <li><code>write_dataframe()</code> - Enhanced DataFrame writing with compression and formatting</li> </ul>"},{"location":"api/utils/#environment-detection","title":"Environment Detection","text":"<p>System environment detection with intelligent caching:</p> <ul> <li><code>environment()</code> - Hardware and software environment information</li> <li>Cross-platform compatibility with automatic caching</li> </ul>"},{"location":"api/utils/#random-number-generation","title":"Random Number Generation","text":"<p>Stable, reproducible random number sequences:</p> <ul> <li>Cross-platform reproducible sequences</li> <li>Stable random number generation for experiments</li> <li>Random integer iterators</li> <li>Experiment randomization enums</li> </ul>"},{"location":"api/utils/#timing-utilities","title":"Timing Utilities","text":"<p>Performance measurement and timeout functionality:</p> <ul> <li><code>Timing</code> class for performance measurement</li> <li><code>run_with_timeout()</code> and <code>@with_timeout</code> for algorithm timeouts  </li> <li>Thread-safe execution with configurable timeouts</li> </ul>"},{"location":"api/utils/#enhanced-enumerations","title":"Enhanced Enumerations","text":""},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs","title":"EnumWithAttrs","text":"<pre><code>EnumWithAttrs(_: str, label: str)\n</code></pre> <p>Base class for enumerations with additional read-only attributes.</p> <p>This class extends the standard Python Enum to support enums that carry additional attributes such as human-readable labels. Sub-classes can extend this pattern to include more attributes.</p> Example <p>class Status(EnumWithAttrs): ...     PENDING = 'pending', 'Pending Review' ...     APPROVED = 'approved', 'Approved for Use' ...     REJECTED = 'rejected', 'Rejected - Needs Changes'</p> <p>print(Status.PENDING)  # 'pending' print(Status.PENDING.label)  # 'Pending Review'</p> Note <p>Values should be set as tuples where the first element is the enum value and subsequent elements are the additional attributes. The base class provides a <code>label</code> attribute from the second tuple element.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__new__</code>             \u2013              <p>Create a new enum instance with additional attributes.</p> </li> <li> <code>__str__</code>             \u2013              <p>Return the string representation of the enum value.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>Get the human-readable label for this enum value.</p> </li> </ul>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs(_)","title":"<code>_</code>","text":"(<code>str</code>)           \u2013            <p>The enum value (already set in new)</p>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs(label)","title":"<code>label</code>","text":"(<code>str</code>)           \u2013            <p>Human-readable label for this enum value</p>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs.label","title":"label  <code>property</code>","text":"<pre><code>label: str\n</code></pre> <p>Get the human-readable label for this enum value.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The label string for this enum value</p> </li> </ul>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs.__new__","title":"__new__","text":"<pre><code>__new__(*args: Any, **kwargs: Any) -&gt; EnumWithAttrs\n</code></pre> <p>Create a new enum instance with additional attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EnumWithAttrs</code>           \u2013            <p>New enum instance with the value set to the first argument</p> </li> </ul>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs.__new__(*args)","title":"<code>*args</code>","text":"(<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>The enum value and additional attribute values</p>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs.__new__(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments (unused)</p>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the string representation of the enum value.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The enum's value as a string</p> </li> </ul>"},{"location":"api/utils/#usage-pattern","title":"Usage Pattern","text":"<p>The utils module is designed as a consolidated toolkit for common programming patterns:</p> <pre><code># Mathematical operations\nfrom causaliq_core.utils import rndsf, ln\n\n# Environment detection  \nfrom causaliq_core.utils import environment\n\n# Enhanced enums\nfrom causaliq_core.utils import EnumWithAttrs\n\n# Timing and random numbers in submodules\nfrom causaliq_core.utils.timing import Timing\nfrom causaliq_core.utils.random import stable_random\n</code></pre>"},{"location":"api/utils/#module-structure","title":"Module Structure","text":"<ul> <li>Main Module (<code>causaliq_core.utils</code>): Core functions and enhanced enums</li> <li>Random Submodule (<code>causaliq_core.utils.random</code>): Random number utilities</li> <li>Timing Submodule (<code>causaliq_core.utils.timing</code>): Performance and timeout utilities</li> </ul> <p>For detailed API documentation, see the specialized pages linked above.</p>"},{"location":"api/utils_environment/","title":"Environment Functions","text":"<p>System environment detection with intelligent caching for performance optimization.</p>"},{"location":"api/utils_environment/#causaliq_core.utils.environment","title":"environment","text":"<p>Environment and system information utilities.</p> <p>Functions:</p> <ul> <li> <code>environment</code>             \u2013              <p>Obtain details of the hardware and software environment.</p> </li> </ul>"},{"location":"api/utils_environment/#causaliq_core.utils.environment.environment","title":"environment","text":"<pre><code>environment(cache_dir: Optional[str] = None) -&gt; Dict[str, Any]\n</code></pre> <p>Obtain details of the hardware and software environment.</p> <p>For efficiency, this is obtained from a cached file \"environment.json\" if one modified in the last 24 hours is available, otherwise the OS is queried and a new cache file created.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Environment information including os, cpu, python, ram.</p> </li> </ul>"},{"location":"api/utils_environment/#causaliq_core.utils.environment.environment(cache_dir)","title":"<code>cache_dir</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Optional cache directory. If None, uses standard user cache directory for the platform.</p>"},{"location":"api/utils_environment/#usage-examples","title":"Usage Examples","text":""},{"location":"api/utils_environment/#basic-environment-detection","title":"Basic Environment Detection","text":"<pre><code>from causaliq_core.utils import environment\n\n# Use default cache location\nenv = environment()\nprint(f\"Running on {env['os']} with {env['ram']}GB RAM\")\nprint(f\"CPU: {env['cpu']}\")\nprint(f\"Python: {env['python']}\")\n</code></pre>"},{"location":"api/utils_environment/#custom-cache-directory","title":"Custom Cache Directory","text":"<pre><code>from causaliq_core.utils import environment\n\n# Use custom cache directory\nenv = environment(cache_dir=\"/tmp/my_cache\")\nprint(f\"OS: {env['os']}\")\n</code></pre>"},{"location":"api/utils_environment/#returned-information","title":"Returned Information","text":"<p>The environment function returns a dictionary with the following keys:</p> <ul> <li><code>'os'</code>: Operating system name and version</li> <li><code>'cpu'</code>: CPU brand/model information  </li> <li><code>'python'</code>: Python version string</li> <li><code>'ram'</code>: Total system RAM in GB (rounded to nearest GB)</li> </ul>"},{"location":"api/utils_environment/#caching-behavior","title":"Caching Behavior","text":"<ul> <li>Cache files are stored as <code>environment.json</code> in the cache directory</li> <li>Cache is refreshed if older than 24 hours</li> <li>Uses platform-appropriate cache locations (e.g., <code>~/.cache</code> on Linux, <code>~/Library/Caches</code> on macOS)</li> <li>Gracefully handles cache corruption or permission errors</li> </ul>"},{"location":"api/utils_io/","title":"I/O Operations","text":"<p>The I/O utilities module provides enhanced file and path handling functionality, including robust path validation and DataFrame writing with advanced formatting options.</p>"},{"location":"api/utils_io/#overview","title":"Overview","text":"<p>The <code>causaliq_core.utils.io</code> module provides:</p> <ul> <li>Path Validation: Robust checking of file and directory paths</li> <li>Enhanced DataFrame Writing: CSV output with compression and numerical formatting</li> <li>Cross-Platform Support: Consistent behavior across operating systems</li> <li>Error Handling: Clear error messages for common I/O issues</li> </ul>"},{"location":"api/utils_io/#functions","title":"Functions","text":""},{"location":"api/utils_io/#is_valid_path","title":"is_valid_path()","text":"<p>Validates that a path exists and matches the expected type (file or directory).</p> <pre><code>from causaliq_core.utils.io import is_valid_path\n\n# Check if file exists\nif is_valid_path('data/network.dsc', is_file=True):\n    print(\"File exists and is accessible\")\n\n# Check if directory exists  \nif is_valid_path('output/', is_file=False):\n    print(\"Directory exists and is accessible\")\n\n# Default behavior checks for file\ntry:\n    is_valid_path('important_file.txt')\n    print(\"File is valid\")\nexcept FileNotFoundError:\n    print(\"File not found\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>path</code> (str): Full path to validate</li> <li><code>is_file</code> (bool): Whether path should be a file (True) or directory (False)</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if path exists and matches expected type</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>: If arguments have invalid types</li> <li><code>FileNotFoundError</code>: If path doesn't exist or doesn't match expected type</li> </ul>"},{"location":"api/utils_io/#write_dataframe","title":"write_dataframe()","text":"<p>Enhanced DataFrame writing with numerical formatting, compression, and validation.</p> <pre><code>from causaliq_core.utils.io import write_dataframe\nimport pandas as pd\n\n# Create sample data\ndf = pd.DataFrame({\n    'measurement': [1.234567, 2.789012, 3.456789],\n    'category': ['A', 'B', 'C'],\n    'value': [10.123456789, 20.987654321, 30.555555555]\n})\n\n# Basic usage\nwrite_dataframe(df, 'output.csv')\n\n# With numerical formatting (3 significant figures)\nwrite_dataframe(df, 'formatted.csv', sf=3)\n\n# With compression\nwrite_dataframe(df, 'compressed.csv.gz', compress=True)\n\n# Preserve original DataFrame (default)\nwrite_dataframe(df, 'output.csv', preserve=True)\n\n# Modify DataFrame in-place (faster for large data)\nwrite_dataframe(df, 'output.csv', preserve=False)\n\n# Custom zero threshold\nwrite_dataframe(df, 'output.csv', sf=4, zero=1e-6)\n</code></pre> <p>Parameters:</p> <ul> <li><code>df</code> (DataFrame): Pandas DataFrame to write</li> <li><code>filename</code> (str): Output file path</li> <li><code>compress</code> (bool): Whether to gzip compress the output (default: False)</li> <li><code>sf</code> (int): Number of significant figures for numerical formatting (default: 10)</li> <li><code>zero</code> (float, optional): Values below this threshold are treated as zero (default: 10^(-sf))</li> <li><code>preserve</code> (bool): Whether to preserve original DataFrame unchanged (default: True)</li> </ul> <p>Returns:</p> <ul> <li>None</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>: If arguments have invalid types</li> <li><code>ValueError</code>: If sf or zero parameters are out of valid ranges</li> <li><code>FileNotFoundError</code>: If destination directory doesn't exist</li> </ul>"},{"location":"api/utils_io/#features","title":"Features","text":""},{"location":"api/utils_io/#numerical-formatting","title":"Numerical Formatting","text":"<p>The <code>write_dataframe()</code> function provides sophisticated numerical formatting:</p> <pre><code>import pandas as pd\nfrom causaliq_core.utils.io import write_dataframe\n\n# Data with varying precision\ndf = pd.DataFrame({\n    'high_precision': [1.23456789012345, 2.98765432109876],\n    'low_precision': [1.2, 3.4],\n    'scientific': [1.23e-8, 4.56e12]\n})\n\n# Format to 3 significant figures\nwrite_dataframe(df, 'formatted.csv', sf=3)\n# Results: 1.23, 2.99, 1.20, 3.40, 1.23e-08, 4.56e+12\n</code></pre>"},{"location":"api/utils_io/#compression-support","title":"Compression Support","text":"<p>Automatic compression for large datasets:</p> <pre><code># Large dataset\nlarge_df = pd.DataFrame({\n    'data': range(100000),\n    'values': [random.random() for _ in range(100000)]\n})\n\n# Compressed output (much smaller file size)\nwrite_dataframe(large_df, 'large_data.csv.gz', compress=True)\n</code></pre>"},{"location":"api/utils_io/#memory-efficiency","title":"Memory Efficiency","text":"<p>Control memory usage with the <code>preserve</code> parameter:</p> <pre><code># For large DataFrames, avoid copying\nwrite_dataframe(huge_df, 'output.csv', preserve=False)\n# Original DataFrame may be modified for efficiency\n\n# For small DataFrames, preserve original\nwrite_dataframe(small_df, 'output.csv', preserve=True)  # Default\n# Original DataFrame remains unchanged\n</code></pre>"},{"location":"api/utils_io/#error-handling","title":"Error Handling","text":"<p>The I/O utilities provide comprehensive error handling:</p> <pre><code>from causaliq_core.utils.io import write_dataframe, is_valid_path\n\n# Handle path validation errors\ntry:\n    is_valid_path('nonexistent/path.txt')\nexcept FileNotFoundError as e:\n    print(f\"Path error: {e}\")\n\n# Handle DataFrame writing errors\ntry:\n    write_dataframe(df, '/invalid/path/output.csv')\nexcept FileNotFoundError:\n    print(\"Destination directory doesn't exist\")\n\ntry:\n    write_dataframe(df, 'output.csv', sf=50)  # Invalid sf\nexcept ValueError as e:\n    print(f\"Parameter error: {e}\")\n</code></pre>"},{"location":"api/utils_io/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/utils_io/#data-pipeline-integration","title":"Data Pipeline Integration","text":"<pre><code>from causaliq_core.utils.io import write_dataframe, is_valid_path\nimport pandas as pd\nfrom pathlib import Path\n\ndef save_analysis_results(df, output_dir, filename, compress_large=True):\n    \"\"\"Save analysis results with appropriate formatting.\"\"\"\n\n    # Ensure output directory exists\n    output_path = Path(output_dir)\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    # Full output path\n    full_path = output_path / filename\n\n    # Determine if compression is needed\n    should_compress = compress_large and len(df) &gt; 10000\n    if should_compress:\n        full_path = full_path.with_suffix('.csv.gz')\n\n    # Write with appropriate settings\n    write_dataframe(\n        df, \n        str(full_path),\n        compress=should_compress,\n        sf=4,  # 4 significant figures for analysis data\n        preserve=True  # Keep original data unchanged\n    )\n\n    print(f\"Results saved to {full_path}\")\n    return full_path\n</code></pre>"},{"location":"api/utils_io/#validation-workflow","title":"Validation Workflow","text":"<pre><code>from causaliq_core.utils.io import is_valid_path\n\ndef validate_inputs(file_paths):\n    \"\"\"Validate all required input files exist.\"\"\"\n\n    missing_files = []\n    for path in file_paths:\n        try:\n            is_valid_path(path, is_file=True)\n        except FileNotFoundError:\n            missing_files.append(path)\n\n    if missing_files:\n        raise FileNotFoundError(f\"Missing required files: {missing_files}\")\n\n    print(\"All input files validated successfully\")\n</code></pre>"},{"location":"api/utils_io/#api-reference","title":"API Reference","text":""},{"location":"api/utils_io/#causaliq_core.utils.io","title":"io","text":"<p>IO-related utilities for file and path handling.</p> <p>Classes:</p> <ul> <li> <code>FileFormatError</code>           \u2013            <p>Exception raised when a file format is invalid or unsupported.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>is_valid_path</code>             \u2013              <p>Check if path is a string and it exists.</p> </li> <li> <code>write_dataframe</code>             \u2013              <p>Write DataFrame to CSV with numeric rounding and compression options.</p> </li> </ul>"},{"location":"api/utils_io/#causaliq_core.utils.io.FileFormatError","title":"FileFormatError","text":"<p>Exception raised when a file format is invalid or unsupported.</p>"},{"location":"api/utils_io/#causaliq_core.utils.io.is_valid_path","title":"is_valid_path","text":"<pre><code>is_valid_path(path: str, is_file: bool = True) -&gt; bool\n</code></pre> <p>Check if path is a string and it exists.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if path is valid and exists.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have bad types.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If path is not found.</p> </li> </ul>"},{"location":"api/utils_io/#causaliq_core.utils.io.is_valid_path(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Full path name of file or directory.</p>"},{"location":"api/utils_io/#causaliq_core.utils.io.is_valid_path(is_file)","title":"<code>is_file</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Should path be a file (otherwise a directory).</p>"},{"location":"api/utils_io/#causaliq_core.utils.io.write_dataframe","title":"write_dataframe","text":"<pre><code>write_dataframe(\n    df: DataFrame,\n    filename: str,\n    compress: bool = False,\n    sf: int = 10,\n    zero: Optional[float] = None,\n    preserve: bool = True,\n) -&gt; None\n</code></pre> <p>Write DataFrame to CSV with numeric rounding and compression options.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If argument types incorrect.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If sf or zero parameters are invalid.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If destination folder does not exist.</p> </li> </ul>"},{"location":"api/utils_io/#causaliq_core.utils.io.write_dataframe(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>DataFrame to write.</p>"},{"location":"api/utils_io/#causaliq_core.utils.io.write_dataframe(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>Full path of output file.</p>"},{"location":"api/utils_io/#causaliq_core.utils.io.write_dataframe(compress)","title":"<code>compress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to gzip compress the file.</p>"},{"location":"api/utils_io/#causaliq_core.utils.io.write_dataframe(sf)","title":"<code>sf</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of significant figures to retain for numeric values.</p>"},{"location":"api/utils_io/#causaliq_core.utils.io.write_dataframe(zero)","title":"<code>zero</code>","text":"(<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Absolute values below this counted as zero.</p>"},{"location":"api/utils_io/#causaliq_core.utils.io.write_dataframe(preserve)","title":"<code>preserve</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether df is left unchanged (True conserves original).</p>"},{"location":"api/utils_math/","title":"Mathematical Functions","text":"<p>Mathematical utility functions for number formatting and logarithm calculations.</p>"},{"location":"api/utils_math/#causaliq_core.utils.rndsf","title":"rndsf","text":"<pre><code>rndsf(x: Union[int, float], sf: int, zero: Optional[float] = None) -&gt; str\n</code></pre> <p>Round number to specified significant figures.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted string representation with specified significant figures.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have invalid types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid values.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rndsf(1.234567, 3)\n'1.23'\n&gt;&gt;&gt; rndsf(0.001234, 3)\n'0.00123'\n&gt;&gt;&gt; rndsf(1234567, 3)\n'1230000'\n</code></pre>"},{"location":"api/utils_math/#causaliq_core.utils.rndsf(x)","title":"<code>x</code>","text":"(<code>Union[int, float]</code>)           \u2013            <p>Number to round.</p>"},{"location":"api/utils_math/#causaliq_core.utils.rndsf(sf)","title":"<code>sf</code>","text":"(<code>int</code>)           \u2013            <p>Number of significant figures (2-10).</p>"},{"location":"api/utils_math/#causaliq_core.utils.rndsf(zero)","title":"<code>zero</code>","text":"(<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Optional zero threshold (default: 10^-sf).</p>"},{"location":"api/utils_math/#causaliq_core.utils.ln","title":"ln","text":"<pre><code>ln(x: float, base: Union[int, str] = 'e') -&gt; float\n</code></pre> <p>Return logarithm to specified base.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Logarithm of x to the specified base.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have invalid types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid values.</p> </li> </ul> Example <p>ln(10, 10) 1.0 ln(8, 2) 3.0 ln(2.718281828459045)  # e 1.0</p>"},{"location":"api/utils_math/#causaliq_core.utils.ln(x)","title":"<code>x</code>","text":"(<code>float</code>)           \u2013            <p>Number to obtain logarithm of.</p>"},{"location":"api/utils_math/#causaliq_core.utils.ln(base)","title":"<code>base</code>","text":"(<code>Union[int, str]</code>, default:                   <code>'e'</code> )           \u2013            <p>Base to use - 2, 10, or 'e' for natural logarithm.</p>"},{"location":"api/utils_math/#usage-examples","title":"Usage Examples","text":""},{"location":"api/utils_math/#significant-figure-rounding","title":"Significant Figure Rounding","text":"<pre><code>from causaliq_core.utils import rndsf\n\n# Basic rounding\nrndsf(1.23456789, 4)  # Returns '1.235'\n\n# Small numbers\nrndsf(0.000123, 3)    # Returns '0.000123'\n\n# Large numbers  \nrndsf(1234567, 3)     # Returns '1230000.0'\n\n# Custom zero threshold\nrndsf(0.0001, 3, zero=0.001)  # Returns '0.0'\n</code></pre>"},{"location":"api/utils_math/#logarithm-calculations","title":"Logarithm Calculations","text":"<pre><code>from causaliq_core.utils import ln\n\n# Base 10 logarithm\nln(10, 10)  # Returns 1.0\n\n# Base 2 logarithm\nln(8, 2)    # Returns 3.0\n\n# Natural logarithm (default)\nln(2.718281828459045)  # Returns 1.0\nln(2.718281828459045, 'e')  # Same as above\n</code></pre>"},{"location":"api/utils_random/","title":"Random Number Utilities","text":"<p>Stable, reproducible random number generation for scientific computing and experimental repeatability.</p>"},{"location":"api/utils_random/#core-functions","title":"Core Functions","text":""},{"location":"api/utils_random/#causaliq_core.utils.random.random_generator","title":"random_generator","text":"<pre><code>random_generator() -&gt; Generator\n</code></pre> <p>Get the current random number generator instance.</p> <p>Returns:</p> <ul> <li> <code>Generator</code>           \u2013            <p>numpy.random.Generator: The current random number generator</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.set_random_seed","title":"set_random_seed","text":"<pre><code>set_random_seed(seed: Optional[int] = None) -&gt; None\n</code></pre> <p>Set the seed of the random number generator.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If seed is not an int or None</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.set_random_seed(seed)","title":"<code>seed</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Seed for pseudo-random number generation, or None for truly random</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.stable_random","title":"stable_random","text":"<pre><code>stable_random(path: Optional[str] = None) -&gt; float\n</code></pre> <p>Return next random number in stable sequence.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Next random number from stable sequence</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>StopIteration</code>             \u2013            <p>When no more numbers available</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>For legacy compatibility when sequence unavailable</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.stable_random(path)","title":"<code>path</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Legacy compatibility parameter (ignored)</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.generate_stable_random","title":"generate_stable_random","text":"<pre><code>generate_stable_random(N: int, path: Optional[str] = None) -&gt; List[float]\n</code></pre> <p>Generate a sequence of random numbers for repeatability.</p> <p>This function returns N random numbers from the embedded stable sequence, maintaining compatibility with legacy code that expects file-based generation. For compatibility, the path parameter is accepted but ignored.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>List of N random numbers from the stable sequence</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If N is greater than available sequence length</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.generate_stable_random(N)","title":"<code>N</code>","text":"(<code>int</code>)           \u2013            <p>Number of random numbers to generate</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.generate_stable_random(path)","title":"<code>path</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Legacy compatibility parameter (ignored)</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.init_stable_random","title":"init_stable_random","text":"<pre><code>init_stable_random(offset: int = 0) -&gt; None\n</code></pre> <p>Set the stable random offset and clear cache.</p> <p>Sets the stable random offset so that different stable sequences can be generated from the same embedded data. Also clears the cache.</p> <p>Parameters:</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.init_stable_random(offset)","title":"<code>offset</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Offset which generates different sequences</p>"},{"location":"api/utils_random/#classes","title":"Classes","text":""},{"location":"api/utils_random/#causaliq_core.utils.random.Randomise","title":"Randomise","text":"<p>Supported experiment randomisations.</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers","title":"RandomIntegers","text":"<pre><code>RandomIntegers(n: int, subsample: int = 0, path: Optional[str] = None)\n</code></pre> <p>Iterable producing repeatable sequences of random integers.</p> <p>Produces repeatable sequences of random integers for all integers in a range from 0 to specified n.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad argument type</p> </li> <li> <code>ValueError</code>             \u2013            <p>If bad argument value</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If stable random sequence unavailable</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__iter__</code>             \u2013              <p>Initialize the iterator.</p> </li> <li> <code>__next__</code>             \u2013              <p>Return next integer in random sequence.</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers(n)","title":"<code>n</code>","text":"(<code>int</code>)           \u2013            <p>Maximum integer in sequence (exclusive upper bound)</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers(subsample)","title":"<code>subsample</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Unique integer id for each sequence</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers(path)","title":"<code>path</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Legacy compatibility parameter (ignored)</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; RandomIntegers\n</code></pre> <p>Initialize the iterator.</p> <p>Returns:</p> <ul> <li> <code>RandomIntegers</code>           \u2013            <p>The initialized iterator</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; int\n</code></pre> <p>Return next integer in random sequence.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Next integer in random sequence</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>StopIteration</code>             \u2013            <p>When all values have been returned</p> </li> </ul>"},{"location":"api/utils_random/#usage-examples","title":"Usage Examples","text":""},{"location":"api/utils_random/#basic-random-number-generation","title":"Basic Random Number Generation","text":"<pre><code>from causaliq_core.utils.random import random_generator, set_random_seed\n\n# Set seed for reproducibility\nset_random_seed(42)\n\n# Get generator instance\ngen = random_generator()\nvalue = gen.random()  # Generate random float [0.0, 1.0)\n</code></pre>"},{"location":"api/utils_random/#stable-random-sequences","title":"Stable Random Sequences","text":"<pre><code>from causaliq_core.utils.random import stable_random, init_stable_random\n\n# Initialize stable random sequence\ninit_stable_random()\n\n# Generate stable random numbers\nfor i in range(5):\n    print(stable_random())  # Same sequence every run\n</code></pre>"},{"location":"api/utils_random/#random-integer-sequences","title":"Random Integer Sequences","text":"<pre><code>from causaliq_core.utils.random import RandomIntegers\n\n# Create iterator for random integers 1-10\nrand_ints = RandomIntegers(1, 10)\nfor value in rand_ints:\n    print(value)  # Each integer appears exactly once\n</code></pre>"},{"location":"api/utils_random/#experiment-randomization-types","title":"Experiment Randomization Types","text":"<pre><code>from causaliq_core.utils.random import Randomise\n\n# Available randomization types for experiments\nprint(Randomise.ORDER)      # Randomize variable order\nprint(Randomise.NAMES)      # Randomize variable names  \nprint(Randomise.KNOWLEDGE)  # Randomize knowledge\nprint(Randomise.ROWS)       # Randomize row order\nprint(Randomise.SAMPLE)     # Randomize sample rows\n</code></pre>"},{"location":"api/utils_random/#features","title":"Features","text":"<ul> <li>Cross-platform reproducibility: Same sequences on all platforms</li> <li>Stable sequences: Pre-generated sequence for consistent results</li> <li>Configurable seeding: Support for both deterministic and random seeding</li> <li>Iterator patterns: Clean iteration over random integer sequences</li> <li>Experiment support: Built-in randomization types for scientific experiments</li> </ul>"},{"location":"api/utils_timing/","title":"Timing Utilities","text":"<p>Performance measurement and timeout functionality for algorithm execution.</p>"},{"location":"api/utils_timing/#timing-collection","title":"Timing Collection","text":""},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing","title":"Timing","text":"<p>Singleton class collects count, mean and max time for actions.</p> <p>:cvar bool active: whether timing collection is active :cvar times dict: times collected                   {action1: {scale1: {count, total, max}, ...}, ...} :cvar set/None filter: only these actions will be recorded</p> <p>Methods:</p> <ul> <li> <code>__repr__</code>             \u2013              <p>Print out all timings in nice format</p> </li> <li> <code>add</code>             \u2013              <p>Add an elapsed time without having called now() and record().</p> </li> <li> <code>now</code>             \u2013              <p>Returns current time, generally for the start of an action</p> </li> <li> <code>off</code>             \u2013              <p>Turn timing collection off, lose collected timings.</p> </li> <li> <code>on</code>             \u2013              <p>Switching timing on and off</p> </li> <li> <code>record</code>             \u2013              <p>Records time for specified action</p> </li> <li> <code>to_string</code>             \u2013              <p>Print out timings in nice format, optionally only for specified</p> </li> </ul>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.__repr__","title":"__repr__  <code>classmethod</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Print out all timings in nice format</p> <p>:return str: human friendly timing information</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.add","title":"add  <code>classmethod</code>","text":"<pre><code>add(action: str, elapsed: float, scale: int = 100) -&gt; None\n</code></pre> <p>Add an elapsed time without having called now() and record().</p> <p>Parameters:</p> <p>:raises TypeError: if bad arg type :raises ValueError: if bad arg value</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.add(action)","title":"<code>action</code>","text":"(<code>str</code>)           \u2013            <p>action being timed</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.add(elapsed)","title":"<code>elapsed</code>","text":"(<code>float</code>)           \u2013            <p>elapsed time to add</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.add(scale)","title":"<code>scale</code>","text":"(<code>int</code>, default:                   <code>100</code> )           \u2013            <p>indication of scale of action e.g. num of nodes</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.now","title":"now  <code>classmethod</code>","text":"<pre><code>now() -&gt; Optional[float]\n</code></pre> <p>Returns current time, generally for the start of an action</p> <p>:returns float: epoch time in seconds</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.off","title":"off  <code>classmethod</code>","text":"<pre><code>off() -&gt; None\n</code></pre> <p>Turn timing collection off, lose collected timings.</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.on","title":"on  <code>classmethod</code>","text":"<pre><code>on(active: bool, filter: Optional[set] = None) -&gt; None\n</code></pre> <p>Switching timing on and off</p> <p>:param bool active: whether timing should be on or off :param set/None filter: only these actions recorded</p> <p>:raises TypeError: if bad arg type</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.record","title":"record  <code>classmethod</code>","text":"<pre><code>record(action: str, scale: int, start: Optional[float]) -&gt; Optional[float]\n</code></pre> <p>Records time for specified action</p> <p>:param str action: action being timed :param int scale: indication of scale of action e.g. num of nodes :param int start: time at which action started</p> <p>:raises TypeError: if bad arg type :raises ValueError: if bad arg value</p> <p>:returns float: epoch time when this function called</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.to_string","title":"to_string  <code>classmethod</code>","text":"<pre><code>to_string(filter: Optional[set] = None) -&gt; str\n</code></pre> <p>Print out timings in nice format, optionally only for specified actions.</p> <p>:param set/None filter: only return info about these actions.</p> <p>:return str: human friendly timing information</p>"},{"location":"api/utils_timing/#timeout-functions","title":"Timeout Functions","text":""},{"location":"api/utils_timing/#causaliq_core.utils.timing.run_with_timeout","title":"run_with_timeout","text":"<pre><code>run_with_timeout(\n    func: Callable,\n    args: tuple = (),\n    kwargs: Optional[dict] = None,\n    timeout_seconds: Optional[int] = None,\n) -&gt; Any\n</code></pre> <p>Run a function with a timeout using threading approach.</p> <p>This is compatible with both subprocess-based (R, Java) and direct Python function calls (causal-learn). For subprocess calls, the timeout will terminate the subprocess if it exceeds the time limit.</p> <p>:param func: Function to execute :param args: Positional arguments for the function :param kwargs: Keyword arguments for the function :param timeout_seconds: Maximum execution time in seconds,                        None for no timeout</p> <p>:raises TimeoutError: if execution exceeds timeout_seconds :raises Exception: any exception raised by the wrapped function</p> <p>:returns: Result from the wrapped function</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.with_timeout","title":"with_timeout","text":"<pre><code>with_timeout(timeout_seconds: Optional[int] = None) -&gt; Callable\n</code></pre> <p>Decorator version of run_with_timeout.</p> <p>:param timeout_seconds: Maximum execution time in seconds,                        None for no timeout</p> Usage <p>@with_timeout(300)  # 5 minute timeout def my_algorithm(data):     # algorithm implementation     return result</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.TimeoutError","title":"TimeoutError","text":"<p>Raised when an operation times out</p>"},{"location":"api/utils_timing/#usage-examples","title":"Usage Examples","text":""},{"location":"api/utils_timing/#basic-timing-collection","title":"Basic Timing Collection","text":"<pre><code>from causaliq_core.utils.timing import Timing\nfrom time import sleep\n\n# Enable timing collection\nTiming.on(True)\n\n# Time an operation\nstart = Timing.now()\nsleep(0.1)  # Simulate work\nTiming.record(\"sleep_test\", 1, start)\n\n# View timing summary\nprint(Timing.summary())\n\n# Turn off timing\nTiming.off()\n</code></pre>"},{"location":"api/utils_timing/#filtered-timing","title":"Filtered Timing","text":"<pre><code>from causaliq_core.utils.timing import Timing\n\n# Only collect timing for specific actions\nTiming.on(True, filter={\"critical_operation\", \"slow_function\"})\n\n# This will be recorded\nstart = Timing.now()\n# ... do critical operation ...\nTiming.record(\"critical_operation\", 100, start)\n\n# This will be ignored\nstart = Timing.now()\n# ... do normal operation ...\nTiming.record(\"normal_operation\", 50, start)\n</code></pre>"},{"location":"api/utils_timing/#function-timeout-decorator","title":"Function Timeout Decorator","text":"<pre><code>from causaliq_core.utils.timing import with_timeout, TimeoutError\n\n@with_timeout(5)  # 5 second timeout\ndef slow_function():\n    # This function will be interrupted if it takes &gt; 5 seconds\n    import time\n    time.sleep(10)  # Would normally take 10 seconds\n\ntry:\n    slow_function()\nexcept TimeoutError:\n    print(\"Function timed out!\")\n</code></pre>"},{"location":"api/utils_timing/#direct-timeout-execution","title":"Direct Timeout Execution","text":"<pre><code>from causaliq_core.utils.timing import run_with_timeout, TimeoutError\n\ndef potentially_slow_task(data):\n    # Process data...\n    return processed_data\n\ntry:\n    result = run_with_timeout(\n        potentially_slow_task,\n        args=(my_data,),\n        timeout_seconds=30\n    )\n    print(f\"Completed: {result}\")\nexcept TimeoutError:\n    print(\"Task took too long!\")\n</code></pre>"},{"location":"api/utils_timing/#adding-pre-calculated-times","title":"Adding Pre-calculated Times","text":"<pre><code>from causaliq_core.utils.timing import Timing\n\n# Enable timing\nTiming.on(True)\n\n# Add a timing measurement without calling now()/record()\nTiming.add(\"algorithm_run\", elapsed_time=1.234, scale=500)\n\n# View results\nprint(Timing.summary())\n</code></pre>"},{"location":"api/utils_timing/#features","title":"Features","text":"<ul> <li>Singleton pattern: Global timing collection across application</li> <li>Filtering: Collect timing only for specified actions</li> <li>Scale tracking: Record scale indicators (e.g., number of nodes)</li> <li>Statistical summary: Automatic count, mean, and max calculations</li> <li>Thread-safe timeouts: Reliable timeout functionality for long-running operations</li> <li>Decorator support: Clean timeout decoration for functions</li> <li>Flexible timeout: Support both function decoration and direct execution</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":""},{"location":"architecture/overview/#causaliq-ecosystem","title":"CausalIQ Ecosystem","text":"<p>causaliq-core is a foundational component of the overall CausalIQ ecosystem architecture, providing core utilities and patterns used across CausalIQ projects.</p>"},{"location":"architecture/overview/#design-philosophy","title":"Design Philosophy","text":"<p>The architecture emphasizes reproducibility, performance, and cross-platform compatibility through thoughtful design patterns and data management strategies.</p>"},{"location":"architecture/overview/#key-architectural-features","title":"Key Architectural Features","text":""},{"location":"architecture/overview/#deterministic-random-number-generation","title":"Deterministic Random Number Generation","text":"<p>Design Goal: Ensure reproducible results across platforms and Python versions.</p> <p>Implementation: - Uses an embedded list of pre-generated random numbers (<code>STABLE_RANDOM_SEQUENCE</code>)  - 10,000+ values generated from a fixed seed for cross-platform repeatability - Avoids platform-specific random number generator differences - Supports stable experiment randomization for scientific reproducibility</p> <pre><code># Stable across all platforms and Python versions\nfrom causaliq_core.utils.random import stable_random\nvalues = stable_random(seed=42, count=100)  # Always identical results\n</code></pre>"},{"location":"architecture/overview/#intelligent-environment-caching","title":"Intelligent Environment Caching","text":"<p>Design Goal: Minimize expensive system queries while maintaining fresh data.</p> <p>Implementation: - 24-hour cache expiration for hardware/software environment detection - Platform-appropriate cache directories (follows OS conventions) - Graceful fallback on cache corruption or permission errors - JSON-based cache storage for human readability and debugging</p> <pre><code># First call queries system, subsequent calls use cache\nenv = environment()  # May take 100ms+ on first call\nenv = environment()  # Returns cached data instantly\n</code></pre>"},{"location":"architecture/overview/#enhanced-enumeration-pattern","title":"Enhanced Enumeration Pattern","text":"<p>Design Goal: Extend Python enums with additional attributes while preserving enum semantics.</p> <p>Implementation:</p> <ul> <li><code>EnumWithAttrs</code> base class for enums with human-readable labels</li> <li>Maintains enum value integrity while adding metadata</li> <li>Supports extensible attribute patterns for domain-specific needs</li> </ul>"},{"location":"architecture/overview/#performance-aware-timing-infrastructure","title":"Performance-Aware Timing Infrastructure","text":"<p>Design Goal: Non-intrusive performance measurement for production use.</p> <p>Implementation:</p> <ul> <li>Singleton pattern for centralized timing collection</li> <li>Thread-safe timeout decorators and context managers</li> <li>Optional activation to eliminate overhead in production</li> <li>Hierarchical timing with action/scale categorization</li> </ul>"},{"location":"architecture/overview/#mathematical-precision-controls","title":"Mathematical Precision Controls","text":"<p>Design Goal: Consistent numerical formatting across scientific applications.</p> <p>Implementation:</p> <ul> <li>Significant figure rounding with exact legacy behavior preservation</li> <li>Configurable zero thresholds for scientific notation edge cases</li> <li>String-based output for precise display formatting control</li> </ul>"},{"location":"architecture/overview/#module-organization","title":"Module Organization","text":"<pre><code>causaliq_core/\n\u251c\u2500\u2500 __init__.py          # Package metadata and constants\n\u251c\u2500\u2500 cli.py              # Command-line interface\n\u251c\u2500\u2500 bn/                 # Bayesian Networks\n\u2502   \u251c\u2500\u2500 dist/           # Conditional distributions (CPT, LinGauss)\n\u2502   \u2514\u2500\u2500 io/             # BN file I/O (DSC, XDSL formats)\n\u251c\u2500\u2500 graph/              # Graph structures and enums\n\u251c\u2500\u2500 utils/              # Core utilities\n\u2502   \u251c\u2500\u2500 __init__.py     # Math functions, enums, environment\n\u2502   \u251c\u2500\u2500 io.py           # File and DataFrame I/O utilities\n\u2502   \u251c\u2500\u2500 random.py       # Stable random generation\n\u2502   \u2514\u2500\u2500 timing.py       # Performance measurement\n</code></pre>"},{"location":"architecture/overview/#bayesian-networks-architecture","title":"Bayesian Networks Architecture","text":"<p>Design Goal: Modular probabilistic modeling with multiple distribution types and file format support.</p> <p>Implementation:</p> <ul> <li>BN Core: Main BN and BNFit classes for network representation</li> <li>Distribution Module: Pluggable conditional distributions (CPT for discrete, LinGauss for continuous)  </li> <li>I/O Layer: Format-agnostic interface with DSC and XDSL backend support</li> <li>Graph Integration: Built on causaliq_core.graph DAG foundation</li> </ul>"},{"location":"architecture/overview/#package-reorganization-rationale","title":"Package Reorganization Rationale","text":"<p>The recent package structure balances functionality distribution:</p> <ul> <li>Main package: Constants and metadata (lightweight imports)</li> <li>Utils package: Mathematical functions and core utilities </li> <li>Specialized modules: Domain-specific functionality (graph, timing, random)</li> </ul> <p>This structure supports both convenience imports (<code>from causaliq_core.utils import rndsf</code>) and modular usage patterns while maintaining backward compatibility.</p>"}]}