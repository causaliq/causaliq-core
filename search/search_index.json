{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CausalIQ Core","text":""},{"location":"#welcome","title":"Welcome","text":"<p>Welcome to the documentation for the CausalIQ Core \u2014 part of the CausalIQ ecosystem for intelligent causal discovery. </p> <p>CausalIQ Core provides functionality required by several CausalIQ projects. It is not envisaged that it will be used or called directly itself, nor can it be directly used in CausalIQ Workflows.</p>"},{"location":"#overview","title":"Overview","text":"<p>CausalIQ Core provides the following common functionality required by several user-facing CausalIQ packages in the following areas:</p> <ul> <li>graph: support for general graphs, PDAGs and CPDAGs used in causal discovery;</li> <li>bn: support for Bayesian Networks (BNs);</li> <li>io: filesystem io and format conversion, particularly relating to standard formats for graphs (.graphml, .dsc etc) and BNs (.xdsl)</li> <li>utils: utility enums, functions and classes, relating to random numbers, mathematical functions, path handling etc.</li> </ul> <p>This site provides detailed documentation, including: development roadmap, architectural vision, design notes, and API reference for contributors. Since this is not a \"user-facing\" capability a user guide is not provided.</p>"},{"location":"#quickstart-installation","title":"Quickstart &amp; Installation","text":"<p>For a quickstart guide and installation instructions, see the README on GitHub.</p>"},{"location":"#documentation-contents","title":"Documentation Contents","text":"<ul> <li>Development Roadmap: roadmap of upcoming features</li> <li>Architecture: overall architecture and design notes</li> <li>API Reference: complete reference for Python code</li> <li>Development Guidelines: CausalIQ guidelines for developers</li> <li>Changelog</li> <li>License</li> </ul>"},{"location":"#support-community","title":"Support &amp; Community","text":"<ul> <li>GitHub Issues: Report bugs or request features.</li> <li>GitHub Discussions: Ask questions and join the community.</li> </ul> <p>Tip: Use the navigation sidebar to explore the documentation. For the latest code and releases, visit the causaliq-core GitHub repository.</p> <p>Supported Python Versions: 3.9, 3.10, 3.11, 3.12 Default Python Version: 3.11</p>"},{"location":"roadmap/","title":"CausalIQ Repo Template - Development Roadmap","text":"<p>Last updated: November 21, 2025  </p> <p>This project roadmap fits into the overall ecosystem roadmap</p>"},{"location":"roadmap/#current-release","title":"\ud83c\udfaf Current Release","text":"<ul> <li>\u2705 0.1 Foundation: Initial package creation and support for shared utility capabilities (mathematical, random numbers and enums etc.)</li> </ul> <p>Commits:</p> <ul> <li><code>current</code> docs: provide the initial document set</li> <li><code>bac248f</code> Refactor: moved math functions into utils, and legacy constant into top level init.py</li> <li><code>b6f6369</code> Refactor: migrate timing capabilities into utils.timing</li> <li><code>16851c8</code> Refactor: migrate random number capabilities into utils.random</li> <li><code>38cf6e8</code> Refactor: migrate environment into utils</li> <li><code>05549d7</code> Refactor: migrate adjmat and BAYESYS_VERSIONS into graph</li> <li><code>42a3f9f</code> Refactor: migrate ln and rndsf math function, and simplify package structure</li> <li><code>a626001</code> Refactor: migrate SOFTWARE_VERSION, EdgeMark, EdgeType and EnumWithAttrs</li> <li><code>a469829</code> Fix: restrict CI testing to Python 3.11 on Ubuntu</li> <li><code>c00bdb2</code> Refactor: change package name to causaliq-core</li> <li><code>66cb058</code> Initial commit</li> </ul>"},{"location":"roadmap/#previous-releases","title":"\u2705 Previous Releases","text":"<p>See Git commit history for detailed implementation progress</p> <ul> <li>None</li> </ul>"},{"location":"roadmap/#upcoming-implementation","title":"\ud83d\udee3\ufe0f Upcoming Implementation","text":""},{"location":"roadmap/#release-02-graphs-november-2025","title":"Release 0.2: Graphs [November 2025]","text":"<p>Key Deliverables: Graph classes representing SDG (general graph), PDAGs and DAGs </p>"},{"location":"roadmap/#release-03-bayesian-networks-december-2025","title":"Release 0.3: Bayesian Networks [December 2025]","text":"<p>Key Deliverables: BN class and classes for local probability distributions</p>"},{"location":"roadmap/#release-04-inputoutput-december-2025","title":"Release 0.4: Input/Output [December 2025]","text":"<p>Key Deliverables: Input and output of graph, BN and data in different formats</p>"},{"location":"testing/","title":"Test Execution Guide","text":""},{"location":"testing/#pytest-markers","title":"Pytest Markers","text":"<p>This project uses pytest markers to categorize tests:</p> <ul> <li><code>unit</code>: Fast unit tests with no external dependencies</li> <li><code>functional</code>: Tests that interact with CLI or use mocked dependencies  </li> <li><code>integration</code>: Tests with real external dependencies</li> <li><code>slow</code>: Tests that take significant time (system resource access, etc.)</li> </ul>"},{"location":"testing/#running-tests","title":"Running Tests","text":""},{"location":"testing/#fast-development-workflow","title":"Fast Development Workflow","text":"<p>Skip slow tests for quick feedback during development: <pre><code>pytest -m \"not slow\"\n</code></pre></p>"},{"location":"testing/#full-test-suite","title":"Full Test Suite","text":"<p>Run all tests including slow ones: <pre><code>pytest\n</code></pre></p>"},{"location":"testing/#specific-categories","title":"Specific Categories","text":"<p>Run only specific test categories: <pre><code>pytest -m \"unit\"           # Only unit tests\npytest -m \"functional\"     # Only functional tests  \npytest -m \"slow\"          # Only slow tests\npytest -m \"unit or functional and not slow\"  # Complex combinations\n</code></pre></p>"},{"location":"testing/#coverage-without-slow-tests","title":"Coverage Without Slow Tests","text":"<pre><code>pytest --cov=causaliq_core -m \"not slow\"\n</code></pre>"},{"location":"testing/#environment-tests","title":"Environment Tests","text":"<p>The <code>tests/functional/test_environment.py</code> tests are marked as <code>slow</code> because they: - Access real system resources (CPU info, memory stats) - Read/write to filesystem cache - Take longer to execute</p> <p>These tests are important for validating cross-platform behavior but can be skipped during rapid development cycles.</p>"},{"location":"api/cli/","title":"CLI Module","text":"<p>The <code>causaliq_core.cli</code> module provides command-line interface functionality for CausalIQ Core.</p>"},{"location":"api/cli/#cli-entry-point","title":"CLI entry point","text":"<p>This is the entry point for the CLI logic.</p>"},{"location":"api/cli/#causaliq_core.cli","title":"cli","text":"<p>Command-line interface for causaliq-core.</p> <p>Functions:</p> <ul> <li> <code>cli</code>             \u2013              <p>Simple CLI example.</p> </li> <li> <code>main</code>             \u2013              <p>Entry point for the CLI.</p> </li> </ul>"},{"location":"api/cli/#causaliq_core.cli.cli","title":"cli","text":"<pre><code>cli(name: str, greet: str) -&gt; None\n</code></pre> <p>Simple CLI example.</p> <p>NAME is the person to greet</p>"},{"location":"api/cli/#causaliq_core.cli.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Entry point for the CLI.</p>"},{"location":"api/graph/","title":"Graph Module Overview","text":"<p>The <code>causaliq_core.graph</code> module provides graph-related classes and utilities for representing different types of graphs used in causal discovery algorithms, including directed acyclic graphs (DAGs), partially directed acyclic graphs (PDAGs), and summary dependence graphs (SDGs).</p>"},{"location":"api/graph/#core-components","title":"Core Components","text":""},{"location":"api/graph/#sdg-summary-dependence-graph","title":"SDG - Summary Dependence Graph","text":"<p>Base graph class supporting mixed edge types:</p> <ul> <li>Directed, undirected, and bidirected edges</li> <li>General graph operations and validation</li> <li>Foundation for specialized graph types</li> </ul>"},{"location":"api/graph/#pdag-partially-directed-acyclic-graph","title":"PDAG - Partially Directed Acyclic Graph","text":"<p>Specialized graph for causal discovery:</p> <ul> <li>Directed and undirected edges (no bidirected)</li> <li>Represents uncertainty in edge orientation</li> <li>Used in constraint-based causal discovery</li> </ul>"},{"location":"api/graph/#dag-directed-acyclic-graph","title":"DAG - Directed Acyclic Graph","text":"<p>Fully oriented causal structures:</p> <ul> <li>Only directed edges</li> <li>Represents definite causal relationships</li> <li>Topological ordering and string representation</li> </ul>"},{"location":"api/graph/#graph-conversion-functions","title":"Graph Conversion Functions","text":"<p>Transform between graph representations:</p> <ul> <li><code>dag_to_pdag()</code> - DAG to equivalence class PDAG</li> <li><code>pdag_to_cpdag()</code> - Complete a PDAG to CPDAG form</li> <li><code>extend_pdag()</code> - Extend PDAG to consistent DAG</li> <li><code>is_cpdag()</code> - Check if PDAG is completed</li> <li><code>dict_to_adjmat()</code> - Convert dictionary to adjacency matrix DataFrame</li> </ul>"},{"location":"api/graph/#io-functions","title":"I/O Functions","text":""},{"location":"api/graph/#common-io-functions","title":"Common I/O Functions","text":"<p>Unified interface for reading and writing graphs:</p> <ul> <li><code>read()</code> - Automatically detects format and reads graphs</li> <li><code>write()</code> - Automatically detects format and writes graphs</li> <li>Supports <code>.csv</code> (Bayesys) and <code>.tetrad</code> (Tetrad) formats</li> <li>Available directly from <code>causaliq_core.graph</code> for convenience</li> </ul>"},{"location":"api/graph/#bayesys-format-io","title":"Bayesys Format I/O","text":"<p>CSV-based graph file format:</p> <ul> <li><code>read()</code> - Read graphs from Bayesys CSV files</li> <li><code>write()</code> - Write graphs to Bayesys CSV format</li> </ul>"},{"location":"api/graph/#tetrad-format-io","title":"Tetrad Format I/O","text":"<p>Native Tetrad software format:</p> <ul> <li><code>read()</code> - Read graphs from Tetrad format files</li> <li><code>write()</code> - Write graphs to Tetrad format</li> <li>Supports both DAGs and PDAGs</li> </ul>"},{"location":"api/graph/#tetrad-format-io_1","title":"Tetrad Format I/O","text":"<p>Native Tetrad graph file format:</p> <ul> <li><code>read()</code> - Read graphs from Tetrad format files</li> <li><code>write()</code> - Write graphs to Tetrad format</li> <li>Supports both DAGs and PDAGs</li> </ul>"},{"location":"api/graph/#constants","title":"Constants","text":""},{"location":"api/graph/#bayesys_versions","title":"<code>BAYESYS_VERSIONS</code>","text":"<p>List of supported BayeSys versions for graph comparison semantics.</p> <p>Value: <code>['v1.3', 'v1.5+']</code></p> <p>Usage:</p> <pre><code>from causaliq_core.graph import BAYESYS_VERSIONS\n\n# Check version compatibility\nif version in BAYESYS_VERSIONS:\n    print(f\"Version {version} is supported\")\n</code></pre>"},{"location":"api/graph/#functions","title":"Functions","text":""},{"location":"api/graph/#adjmatcolumns","title":"<code>adjmat(columns)</code>","text":"<p>Create an adjacency matrix with specified entries.</p> <p>Parameters:</p> <ul> <li><code>columns</code> (dict): Data for matrix specified by column, where each key is a column name and each value is a list of integers representing edge types</li> </ul> <p>Returns:</p> <ul> <li><code>DataFrame</code>: The adjacency matrix with proper indexing</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>: If argument types are incorrect</li> <li><code>ValueError</code>: If values specified are invalid (wrong lengths or invalid edge codes)</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import adjmat, EdgeType\n\n# Create a simple adjacency matrix\ncolumns = {\n    'A': [0, 1, 0],  # No edge, directed edge, no edge\n    'B': [0, 0, 1],  # No edge, no edge, directed edge  \n    'C': [0, 0, 0]   # No edge, no edge, no edge\n}\nadj_matrix = adjmat(columns)\n</code></pre>"},{"location":"api/graph/#classes","title":"Classes","text":""},{"location":"api/graph/#edgemark","title":"<code>EdgeMark</code>","text":"<p>Enumeration of supported 'ends' of an edge in a graph.</p> <p>Values:</p> <ul> <li><code>NONE = 0</code>: No marking on edge end</li> <li><code>LINE = 1</code>: Line marking (e.g., for undirected edges)</li> <li><code>ARROW = 2</code>: Arrow marking (e.g., for directed edges)  </li> <li><code>CIRCLE = 3</code>: Circle marking (e.g., for partial direction)</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import EdgeMark\n\n# Check edge marking\nif edge_end == EdgeMark.ARROW:\n    print(\"This end is directed\")\n</code></pre>"},{"location":"api/graph/#edgetype","title":"<code>EdgeType</code>","text":"<p>Enumeration of supported edge types and their symbols, combining start and end markings.</p> <p>Structure:</p> <p>Each edge type is defined as a tuple containing: - <code>(value, start_mark, end_mark, symbol)</code></p> <p>Usage:</p> <pre><code>from causaliq_core.graph import EdgeType, EdgeMark\n\n# Access edge type components\nedge = EdgeType.DIRECTED\nprint(f\"Symbol: {edge.symbol}\")\nprint(f\"Start: {edge.start_mark}\")\nprint(f\"End: {edge.end_mark}\")\n</code></pre>"},{"location":"api/graph/#reference","title":"Reference","text":"<p>Graph-related enums and utilities for CausalIQ Core.</p> <p>Modules:</p> <ul> <li> <code>convert</code>           \u2013            </li> <li> <code>dag</code>           \u2013            </li> <li> <code>enums</code>           \u2013            <p>Graph-related enumerations for CausalIQ Core.</p> </li> <li> <code>io</code>           \u2013            <p>Graph I/O module for reading and writing various graph file formats.</p> </li> <li> <code>pdag</code>           \u2013            </li> <li> <code>sdg</code>           \u2013            <p>Simple Dependency Graph (SDG)</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>NotDAGError</code>           \u2013            <p>Indicate graph is not a DAG when one is expected.</p> </li> <li> <code>EdgeMark</code>           \u2013            <p>Supported 'ends' of an edge in a graph.</p> </li> <li> <code>EdgeType</code>           \u2013            <p>Supported edge types and their symbols.</p> </li> <li> <code>NotPDAGError</code>           \u2013            <p>Indicate graph is not a PDAG when one is expected.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>read</code>             \u2013              <p>Read a graph from a file, automatically detecting format from suffix.</p> </li> <li> <code>write</code>             \u2013              <p>Write a graph to a file, automatically detecting format from suffix.</p> </li> </ul>"},{"location":"api/graph/#causaliq_core.graph-classes","title":"Classes","text":""},{"location":"api/graph/#causaliq_core.graph.NotDAGError","title":"NotDAGError","text":"<p>Indicate graph is not a DAG when one is expected.</p>"},{"location":"api/graph/#causaliq_core.graph.EdgeMark","title":"EdgeMark","text":"<p>Supported 'ends' of an edge in a graph.</p>"},{"location":"api/graph/#causaliq_core.graph.EdgeType","title":"EdgeType","text":"<p>Supported edge types and their symbols.</p>"},{"location":"api/graph/#causaliq_core.graph.NotPDAGError","title":"NotPDAGError","text":"<p>Indicate graph is not a PDAG when one is expected.</p>"},{"location":"api/graph/#causaliq_core.graph-functions","title":"Functions","text":""},{"location":"api/graph/#causaliq_core.graph.read","title":"read","text":"<pre><code>read(path: str) -&gt; Union[PDAG]\n</code></pre> <p>Read a graph from a file, automatically detecting format from suffix.</p> <p>Supports: - .csv files (Bayesys format) - .tetrad files (Tetrad format)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union[PDAG]</code>           \u2013            <p>Graph read from file (PDAG or DAG).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If path is not a string.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If file suffix is not supported.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If file is not found.</p> </li> <li> <code>FileFormatError</code>             \u2013            <p>If file format is invalid.</p> </li> </ul>"},{"location":"api/graph/#causaliq_core.graph.read(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Full path name of file to read.</p>"},{"location":"api/graph/#causaliq_core.graph.write","title":"write","text":"<pre><code>write(graph: PDAG, path: str) -&gt; None\n</code></pre> <p>Write a graph to a file, automatically detecting format from suffix.</p> <p>Supports: - .csv files (Bayesys format) - .tetrad files (Tetrad format)</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad arg types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If file suffix is not supported.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If path to file does not exist.</p> </li> </ul>"},{"location":"api/graph/#causaliq_core.graph.write(graph)","title":"<code>graph</code>","text":"(<code>PDAG</code>)           \u2013            <p>Graph to write to file.</p>"},{"location":"api/graph/#causaliq_core.graph.write(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Full path name of file to write.</p>"},{"location":"api/graph/#implementation-notes","title":"Implementation Notes","text":"<p>These classes and functions provide a standardised way to represent and manipulate different graph types commonly used in causal discovery algorithms. The hierarchy (SDG \u2192 PDAG \u2192 DAG) reflects increasing constraints on edge types and graph structure.</p>"},{"location":"api/graph_convert/","title":"Graph Conversion Functions","text":"<p>The <code>convert</code> module provides functions for transforming between different graph representations used in causal discovery algorithms and utilities for working with adjacency matrices.</p>"},{"location":"api/graph_convert/#functions","title":"Functions","text":""},{"location":"api/graph_convert/#dag_to_pdagdag","title":"<code>dag_to_pdag(dag)</code>","text":"<p>Convert a DAG to its corresponding PDAG representation (equivalence class).</p> <p>Parameters:</p> <ul> <li><code>dag</code> (DAG): The directed acyclic graph to convert</li> </ul> <p>Returns:</p> <ul> <li><code>PDAG</code>: PDAG representing the Markov equivalence class</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import DAG, dag_to_pdag\n\n# Create a DAG\ndag = DAG(['X', 'Y', 'Z'], [('X', '-&gt;', 'Y'), ('Y', '-&gt;', 'Z')])\n\n# Convert to PDAG equivalence class\npdag = dag_to_pdag(dag)\n</code></pre>"},{"location":"api/graph_convert/#pdag_to_cpdagpdag","title":"<code>pdag_to_cpdag(pdag)</code>","text":"<p>Convert a PDAG to its completed PDAG (CPDAG) form.</p> <p>Parameters:</p> <ul> <li><code>pdag</code> (PDAG): The partially directed graph to complete</li> </ul> <p>Returns:</p> <ul> <li><code>PDAG</code> or <code>None</code>: Completed PDAG, or None if completion fails</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import PDAG, pdag_to_cpdag\n\n# Create a PDAG\npdag = PDAG(['A', 'B', 'C'], [('A', '--', 'B'), ('B', '-&gt;', 'C')])\n\n# Complete to CPDAG\ncpdag = pdag_to_cpdag(pdag)\n</code></pre>"},{"location":"api/graph_convert/#dict_to_adjmatadjmat_dict-labelsnone","title":"<code>dict_to_adjmat(adjmat_dict, labels=None)</code>","text":"<p>Convert a dictionary representation of an adjacency matrix to a pandas DataFrame.</p> <p>Parameters:</p> <ul> <li><code>adjmat_dict</code> (Dict): Dictionary with (row, col) tuple keys and numeric values</li> <li><code>labels</code> (List[str], optional): Variable labels. If None, creates labels A, B, C, etc.</li> </ul> <p>Returns:</p> <ul> <li><code>DataFrame</code>: Adjacency matrix as a pandas DataFrame</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>: If adjmat_dict is not a dictionary or labels is not a list</li> <li><code>ValueError</code>: If keys are not tuples of length 2 or contain non-integer indices</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph.convert import dict_to_adjmat\n\n# Create adjacency matrix from dictionary\nadjmat_dict = {(0, 1): 1.0, (1, 2): 1.0}\nlabels = ['X', 'Y', 'Z']\ndf = dict_to_adjmat(adjmat_dict, labels)\n</code></pre>"},{"location":"api/graph_convert/#extend_pdagpdag","title":"<code>extend_pdag(pdag)</code>","text":"<p>Extend a PDAG to a consistent DAG by orienting undirected edges.</p> <p>Parameters:</p> <ul> <li><code>pdag</code> (PDAG): The partially directed graph to extend</li> </ul> <p>Returns:</p> <ul> <li><code>DAG</code>: A DAG extension of the PDAG</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import PDAG, extend_pdag\n\n# Create a PDAG\npdag = PDAG(['X', 'Y'], [('X', '--', 'Y')])\n\n# Extend to DAG\ndag = extend_pdag(pdag)\n</code></pre>"},{"location":"api/graph_convert/#is_cpdagpdag","title":"<code>is_cpdag(pdag)</code>","text":"<p>Check whether a PDAG is a completed PDAG (CPDAG).</p> <p>Parameters:</p> <ul> <li><code>pdag</code> (PDAG): The graph to check</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if the PDAG is completed, False otherwise</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import PDAG, is_cpdag\n\n# Check if PDAG is complete\npdag = PDAG(['A', 'B'], [('A', '-&gt;', 'B')])\nis_complete = is_cpdag(pdag)  # True\n</code></pre>"},{"location":"api/graph_convert/#reference","title":"Reference","text":"<p>Functions:</p> <ul> <li> <code>dag_to_pdag</code>             \u2013              <p>Generates PDAG representing equivalence class DAG belongs to.</p> </li> <li> <code>pdag_to_cpdag</code>             \u2013              <p>Generates a completed PDAG (CPDAG) from supplied PDAG</p> </li> <li> <code>is_cpdag</code>             \u2013              <p>Whether the PDAG is a Completed PDAG (CPDAG)</p> </li> <li> <code>extend_pdag</code>             \u2013              <p>Generates a DAG which extends a PDAG (i.e. is a member of the</p> </li> <li> <code>dict_to_adjmat</code>             \u2013              <p>Create an adjacency matrix with specified entries.</p> </li> </ul>"},{"location":"api/graph_convert/#causaliq_core.graph.convert-classes","title":"Classes","text":""},{"location":"api/graph_convert/#causaliq_core.graph.convert-functions","title":"Functions","text":""},{"location":"api/graph_convert/#causaliq_core.graph.convert.dag_to_pdag","title":"dag_to_pdag","text":"<pre><code>dag_to_pdag(dag: DAG) -&gt; PDAG\n</code></pre> <p>Generates PDAG representing equivalence class DAG belongs to.</p> <p>Uses the algorithm in \"A Transformational Characterization of Equivalent Bayesian Network Structures\", Chickering, 1995. Step numbers in comments refer to algorithm step numbers in paper.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if dag is not of type DAG</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PDAG</code>           \u2013            <p>PDAG for equivalence class that dag belongs to</p> </li> </ul>"},{"location":"api/graph_convert/#causaliq_core.graph.convert.dag_to_pdag(dag)","title":"<code>dag</code>","text":"(<code>DAG</code>)           \u2013            <p>DAG whose PDAG is required.</p>"},{"location":"api/graph_convert/#causaliq_core.graph.convert.pdag_to_cpdag","title":"pdag_to_cpdag","text":"<pre><code>pdag_to_cpdag(pdag: PDAG) -&gt; Union[PDAG, None]\n</code></pre> <p>Generates a completed PDAG (CPDAG) from supplied PDAG</p> <p>:param PDAG pdag: PDAG to be completed</p> <p>:raises TypeError: if pdag is not of type PDAG :raises ValueError: if pdag is non-extendable</p> <p>:returns PDAG/None: CPDAG corresponding to pdag</p>"},{"location":"api/graph_convert/#causaliq_core.graph.convert.is_cpdag","title":"is_cpdag","text":"<pre><code>is_cpdag(pdag: PDAG) -&gt; bool\n</code></pre> <p>Whether the PDAG is a Completed PDAG (CPDAG)</p> <p>:param PDAG pdag: PDAG to check</p> <p>:raises ValueError: if PDAG is not extendable</p> <p>:returns bool: True if CPDAG, otherwise False</p>"},{"location":"api/graph_convert/#causaliq_core.graph.convert.extend_pdag","title":"extend_pdag","text":"<pre><code>extend_pdag(pdag: PDAG) -&gt; DAG\n</code></pre> <p>Generates a DAG which extends a PDAG (i.e. is a member of the equivalence class the PDAG represents)</p> <p>Uses the algorithm in \"A simple algorithm to construct a consistent extension of a partially oriented graph\", Dor and Tarsi, 1992</p> <p>:param PDAG pdag: PDAG from which DAG derived</p> <p>:raises TypeError: if pdag is not of type PDAG :raises ValueError: if pdag is not extendable (example is                     an undirected square PDAG)</p> <p>:returns DAG: extension of pdag</p>"},{"location":"api/graph_convert/#causaliq_core.graph.convert.dict_to_adjmat","title":"dict_to_adjmat","text":"<pre><code>dict_to_adjmat(columns: Optional[Dict[str, List[int]]] = None) -&gt; DataFrame\n</code></pre> <p>Create an adjacency matrix with specified entries.</p> <p>:param dict columns: data for matrix specified by column</p> <p>:raises TypeError: if arg types incorrect :raises ValueError: if values specified are invalid</p> <p>:returns DataFrame: the adjacency matrix</p>"},{"location":"api/graph_dag/","title":"Graph DAG Module","text":"<p>The <code>DAG</code> (Directed Acyclic Graph) class provides functionality for working with fully directed acyclic graphs, commonly used to represent causal structures.</p>"},{"location":"api/graph_dag/#classes","title":"Classes","text":""},{"location":"api/graph_dag/#dag","title":"<code>DAG</code>","text":"<p>Directed Acyclic Graph class for representing fully oriented causal structures.</p> <p>Features:</p> <ul> <li>Fully directed edges only</li> <li>Strict acyclicity enforcement</li> <li>Topological ordering</li> <li>String representation (bnlearn format)</li> <li>Causal model representation</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import DAG\n\n# Create a DAG\nnodes = ['X', 'Y', 'Z']\nedges = [\n    ('X', '-&gt;', 'Y'),    # X causes Y\n    ('Y', '-&gt;', 'Z'),    # Y causes Z\n]\ndag = DAG(nodes, edges)\n\n# Get topological ordering\nfor node in dag.ordered_nodes():\n    print(f\"Node: {node}\")\n\n# Get string representation\nprint(dag.to_string())  # e.g. [X][Y|X][Z|Y]\n</code></pre>"},{"location":"api/graph_dag/#notdagerror","title":"<code>NotDAGError</code>","text":"<p>Exception raised when attempting to create an invalid DAG (e.g., contains cycles).</p>"},{"location":"api/graph_dag/#reference","title":"Reference","text":"<p>Classes:</p> <ul> <li> <code>NotDAGError</code>           \u2013            <p>Indicate graph is not a DAG when one is expected.</p> </li> <li> <code>DAG</code>           \u2013            <p>Directed Acyclic Graph (DAG).</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag-classes","title":"Classes","text":""},{"location":"api/graph_dag/#causaliq_core.graph.dag.NotDAGError","title":"NotDAGError","text":"<p>Indicate graph is not a DAG when one is expected.</p>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG","title":"DAG","text":"<pre><code>DAG(nodes: List[str], edges: List[Tuple[str, str, str]])\n</code></pre> <p>Directed Acyclic Graph (DAG).</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>nodes</code>               (<code>List[str]</code>)           \u2013            <p>Graph nodes in alphabetical order.</p> </li> <li> <code>edges</code>               (<code>Dict[Tuple[str, str], EdgeType]</code>)           \u2013            <p>Graph edges {(node1, node2): EdgeType}.</p> </li> <li> <code>is_directed</code>               (<code>bool</code>)           \u2013            <p>Always True for DAGs.</p> </li> <li> <code>parents</code>               (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of node {node: [parents]}.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If nodes and edges not both lists.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If node or edge invalid.</p> </li> <li> <code>NotDAGError</code>             \u2013            <p>If graph is not a DAG.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotDAGError</code>             \u2013            <p>If graph is not a DAG.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ordered_nodes</code>             \u2013              <p>Generator which returns nodes in a topological order.</p> </li> <li> <code>to_string</code>             \u2013              <p>Compact (bnlearn) string representation of DAG e.g. <code>[A][B][C|A:B]</code>.</p> </li> <li> <code>__str__</code>             \u2013              <p>Return a human-readable description of the DAG.</p> </li> <li> <code>rename</code>             \u2013              <p>Rename nodes in place according to name map.</p> </li> <li> <code>partial_order</code>             \u2013              <p>Return partial topological ordering for the directed part of a</p> </li> <li> <code>is_DAG</code>             \u2013              <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> </li> <li> <code>is_PDAG</code>             \u2013              <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> </li> <li> <code>undirected_trees</code>             \u2013              <p>Return undirected trees present in graph.</p> </li> <li> <code>components</code>             \u2013              <p>Return components present in graph.</p> </li> <li> <code>number_components</code>             \u2013              <p>Return number of components (including unconnected nodes) in graph.</p> </li> <li> <code>to_adjmat</code>             \u2013              <p>Return an adjacency matrix representation of the graph.</p> </li> <li> <code>__eq__</code>             \u2013              <p>Test if graph is identical to this one.</p> </li> <li> <code>edge_reversible</code>             \u2013              <p>Return whether specified edge is in CPDAG and is reversible.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes present in the graph.</p>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>Edges which define the graph connections as list of tuples: (node1, dependency symbol, node2).</p>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes present in the graph.</p>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>Edges which define the graph connections.</p>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG-functions","title":"Functions","text":""},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.ordered_nodes","title":"ordered_nodes","text":"<pre><code>ordered_nodes() -&gt; Generator[str, None, None]\n</code></pre> <p>Generator which returns nodes in a topological order.</p> <p>Yields:</p> <ul> <li> <code>str</code>           \u2013            <p>Next node in topological order.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the graph has cycles (shouldn't happen for a DAG).</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.to_string","title":"to_string","text":"<pre><code>to_string() -&gt; str\n</code></pre> <p>Compact (bnlearn) string representation of DAG e.g. <code>[A][B][C|A:B]</code>.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Description of graph.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a human-readable description of the DAG.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Description of DAG.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.rename","title":"rename","text":"<pre><code>rename(name_map: Dict[str, str]) -&gt; None\n</code></pre> <p>Rename nodes in place according to name map.</p> <p>Parameters:</p> <ul> <li> <code>name_map</code> \u00b6              (<code>Dict[str, str]</code>)           \u2013            <p>Name mapping {name: new name}. Must have mapping for every node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values e.g. unknown node names.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.partial_order","title":"partial_order  <code>classmethod</code>","text":"<pre><code>partial_order(\n    parents: Dict[str, List[str]],\n    nodes: Optional[Union[List[str], Set[str]]] = None,\n    new_arc: Optional[Tuple[str, str]] = None,\n) -&gt; Optional[List[Set[str]]]\n</code></pre> <p>Return partial topological ordering for the directed part of a graph.</p> <p>The graph is specified by list of parents for each node.</p> <p>Parameters:</p> <ul> <li> <code>parents</code> \u00b6              (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of each node {node: [parents]}.</p> </li> <li> <code>nodes</code> \u00b6              (<code>Optional[Union[List[str], Set[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional complete list of nodes including parentless ones for use if parents argument doesn't include them already.</p> </li> <li> <code>new_arc</code> \u00b6              (<code>Optional[Tuple[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A new arc (n1, n2) to be added before order is evaluated. If the opposing arc is implied in parents then it is removed so that arc reversal is also supported. This argument facilitates seeing whether an arc addition or reversal would create a cycle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>Nodes in a partial topological order as list of sets or None if</p> </li> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>there is no ordering which means the graph is cyclic.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.is_DAG","title":"is_DAG","text":"<pre><code>is_DAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a DAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.is_PDAG","title":"is_PDAG","text":"<pre><code>is_PDAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a PDAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.undirected_trees","title":"undirected_trees","text":"<pre><code>undirected_trees() -&gt; List[Set[Union[Tuple[str, str], Tuple[str, None]]]]\n</code></pre> <p>Return undirected trees present in graph.</p> <p>Returns:</p> <ul> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>List of trees, each tree a set of tuples representing edges in tree</p> </li> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>(n1, n2) or a single isolated node (n1, None).</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.components","title":"components","text":"<pre><code>components() -&gt; List[List[str]]\n</code></pre> <p>Return components present in graph.</p> <p>Uses tree search algorithm to span the undirected graph to identify nodes in individual trees which are the spanning tree of each component.</p> <p>Returns:</p> <ul> <li> <code>List[List[str]]</code>           \u2013            <p>List of lists, each a list of sorted nodes in component.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.number_components","title":"number_components","text":"<pre><code>number_components() -&gt; int\n</code></pre> <p>Return number of components (including unconnected nodes) in graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of components.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.to_adjmat","title":"to_adjmat","text":"<pre><code>to_adjmat() -&gt; DataFrame\n</code></pre> <p>Return an adjacency matrix representation of the graph.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Adjacency matrix as a pandas DataFrame.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Test if graph is identical to this one.</p> <p>Parameters:</p> <ul> <li> <code>other</code> \u00b6              (<code>object</code>)           \u2013            <p>Graph to compare with self.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if other is identical to self.</p> </li> </ul>"},{"location":"api/graph_dag/#causaliq_core.graph.dag.DAG.edge_reversible","title":"edge_reversible","text":"<pre><code>edge_reversible(edge: Tuple[str, str]) -&gt; bool\n</code></pre> <p>Return whether specified edge is in CPDAG and is reversible.</p> <p>Parameters:</p> <ul> <li> <code>edge</code> \u00b6              (<code>Tuple[str, str]</code>)           \u2013            <p>Edge to examine, (node1, node2).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether present and reversible, or not.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If edge argument has bad type.</p> </li> </ul>"},{"location":"api/graph_io_bayesys/","title":"Bayesys Format I/O","text":"<p>The <code>causaliq_core.graph.io.bayesys</code> module provides functions for reading and writing graphs in the Bayesys CSV format.</p>"},{"location":"api/graph_io_bayesys/#format-description","title":"Format Description","text":"<p>The Bayesys format uses CSV files to represent graphs where: - Each row represents an edge in the graph - Columns specify source node, edge type, and target node - Edge types include directed (<code>-&gt;</code>) and undirected (<code>--</code>) edges</p>"},{"location":"api/graph_io_bayesys/#functions","title":"Functions","text":""},{"location":"api/graph_io_bayesys/#readpath-str-all_nodes-optionalliststr-none-strict-bool-true-unionpdag-dag","title":"<code>read(path: str, all_nodes: Optional[List[str]] = None, strict: bool = True) -&gt; Union[PDAG, DAG]</code>","text":"<p>Read a graph from a Bayesys CSV format file.</p> <p>Parameters: - <code>path</code> (str): Full path name of file to read - <code>all_nodes</code> (List[str], optional): Complete list of nodes that should be included in the graph. If provided, nodes not appearing in edges will be added as isolated nodes - <code>strict</code> (bool): If True, enforces strict format validation</p> <p>Returns: - <code>PDAG</code> or <code>DAG</code>: Graph read from file. Returns DAG if all edges are directed, PDAG otherwise</p> <p>Raises: - <code>TypeError</code>: If path is not a string - <code>FileNotFoundError</code>: If file is not found - <code>FileFormatError</code>: If file format is invalid</p> <p>Example:</p> <pre><code>from causaliq_core.graph.io.bayesys import read\n\n# Read graph with automatic node detection\ngraph = read(\"data/graph.csv\")\n\n# Read graph with explicit node list\nall_nodes = ['A', 'B', 'C', 'D'] \ngraph = read(\"data/graph.csv\", all_nodes=all_nodes)\n</code></pre>"},{"location":"api/graph_io_bayesys/#writegraph-unionpdag-dag-path-str-none","title":"<code>write(graph: Union[PDAG, DAG], path: str) -&gt; None</code>","text":"<p>Write a graph to a Bayesys CSV format file.</p> <p>Parameters: - <code>graph</code> (PDAG or DAG): Graph to write - <code>path</code> (str): Full path name of file to create</p> <p>Raises: - <code>TypeError</code>: If graph is not a PDAG or DAG instance, or path is not a string - <code>OSError</code>: If file cannot be created</p> <p>Example:</p> <pre><code>from causaliq_core.graph import PDAG\nfrom causaliq_core.graph.io.bayesys import write\n\n# Create and write a PDAG\npdag = PDAG(['X', 'Y', 'Z'], [('X', '-&gt;', 'Y'), ('Y', '--', 'Z')])\nwrite(pdag, \"output/graph.csv\")\n</code></pre>"},{"location":"api/graph_io_bayesys/#file-format-details","title":"File Format Details","text":"<p>The CSV file contains rows with three columns: 1. Source node name 2. Edge type (<code>-&gt;</code> for directed, <code>--</code> for undirected) 3. Target node name</p> <p>Example CSV content: <pre><code>A,-&gt;,B\nB,--,C\nA,--,C\n</code></pre></p> <p>This represents a PDAG with nodes A, B, C where: - A \u2192 B (directed edge) - B \u2014 C (undirected edge) - A \u2014 C (undirected edge)</p>"},{"location":"api/graph_io_common/","title":"Common I/O Functions","text":"<p>The <code>causaliq_core.graph.io.common</code> module provides a unified interface for reading and writing graphs from different file formats. It automatically detects the file format based on the file suffix and delegates to the appropriate format-specific module.</p>"},{"location":"api/graph_io_common/#supported-formats","title":"Supported Formats","text":"Extension Format Module Description <code>.csv</code> Bayesys <code>bayesys</code> CSV-based format used by Bayesys software <code>.tetrad</code> Tetrad <code>tetrad</code> Native format used by Tetrad software"},{"location":"api/graph_io_common/#functions","title":"Functions","text":""},{"location":"api/graph_io_common/#readpath-str-unionpdag","title":"<code>read(path: str) -&gt; Union[PDAG]</code>","text":"<p>Read a graph from a file, automatically detecting the format from the file suffix.</p> <p>Parameters: - <code>path</code> (str): Full path name of file to read</p> <p>Returns: - <code>PDAG</code> or <code>DAG</code>: Graph read from file</p> <p>Raises: - <code>TypeError</code>: If path is not a string - <code>ValueError</code>: If file suffix is not supported - <code>FileNotFoundError</code>: If file is not found - <code>FileFormatError</code>: If file format is invalid</p> <p>Example:</p> <pre><code># Import from common module directly\nfrom causaliq_core.graph.io.common import read\n\n# Or import from top-level graph module (recommended)\nfrom causaliq_core.graph import read\n\n# Read Bayesys CSV file\ncsv_graph = read(\"data/graph.csv\")\n\n# Read Tetrad format file  \ntetrad_graph = read(\"data/graph.tetrad\")\n</code></pre>"},{"location":"api/graph_io_common/#writegraph-pdag-path-str-none","title":"<code>write(graph: PDAG, path: str) -&gt; None</code>","text":"<p>Write a graph to a file, automatically detecting the format from the file suffix.</p> <p>Parameters: - <code>graph</code> (PDAG): Graph to write to file - <code>path</code> (str): Full path name of file to write</p> <p>Raises: - <code>TypeError</code>: If bad argument types - <code>ValueError</code>: If file suffix is not supported - <code>FileNotFoundError</code>: If path to file does not exist</p> <p>Example:</p> <pre><code># Import from common module directly\nfrom causaliq_core.graph.io.common import write\n\n# Or import from top-level graph module (recommended)\nfrom causaliq_core.graph import write, DAG\n\n# Create a graph\ndag = DAG([\"A\", \"B\", \"C\"], [(\"A\", \"-&gt;\", \"B\"), (\"B\", \"-&gt;\", \"C\")])\n\n# Write to Bayesys CSV format\nwrite(dag, \"output/result.csv\")\n\n# Write to Tetrad format\nwrite(dag, \"output/result.tetrad\")\n</code></pre>"},{"location":"api/graph_io_common/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/graph_io_common/#format-detection","title":"Format Detection","text":"<p>The module uses the file extension to determine the appropriate format:</p> <pre><code># Import from top-level graph module (recommended)\nfrom causaliq_core.graph import read\n\n# These will use different I/O modules automatically\nbayesys_graph = read(\"data.csv\")      # Uses bayesys.read()\ntetrad_graph = read(\"data.tetrad\")    # Uses tetrad.read()\n</code></pre>"},{"location":"api/graph_io_common/#error-handling","title":"Error Handling","text":"<pre><code>from causaliq_core.graph import read\n\ntry:\n    graph = read(\"data.txt\")  # Unsupported format\nexcept ValueError as e:\n    print(f\"Unsupported format: {e}\")\n    # Output: \"common.read() unsupported file suffix: .txt\"\n</code></pre>"},{"location":"api/graph_io_common/#round-trip-operations","title":"Round-trip Operations","text":"<pre><code>from causaliq_core.graph import read, write\n\n# Read graph in one format\ngraph = read(\"input.csv\")\n\n# Write in different format  \nwrite(graph, \"output.tetrad\")\n\n# Verify round-trip\ngraph2 = read(\"output.tetrad\")\nassert set(graph.nodes) == set(graph2.nodes)\n</code></pre>"},{"location":"api/graph_io_common/#reference","title":"Reference","text":"<p>Functions:</p> <ul> <li> <code>read</code>             \u2013              <p>Read a graph from a file, automatically detecting format from suffix.</p> </li> <li> <code>write</code>             \u2013              <p>Write a graph to a file, automatically detecting format from suffix.</p> </li> </ul>"},{"location":"api/graph_io_common/#causaliq_core.graph.io.common.read","title":"read","text":"<pre><code>read(path: str) -&gt; Union[PDAG]\n</code></pre> <p>Read a graph from a file, automatically detecting format from suffix.</p> <p>Supports: - .csv files (Bayesys format) - .tetrad files (Tetrad format)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union[PDAG]</code>           \u2013            <p>Graph read from file (PDAG or DAG).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If path is not a string.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If file suffix is not supported.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If file is not found.</p> </li> <li> <code>FileFormatError</code>             \u2013            <p>If file format is invalid.</p> </li> </ul>"},{"location":"api/graph_io_common/#causaliq_core.graph.io.common.read(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Full path name of file to read.</p>"},{"location":"api/graph_io_common/#causaliq_core.graph.io.common.write","title":"write","text":"<pre><code>write(graph: PDAG, path: str) -&gt; None\n</code></pre> <p>Write a graph to a file, automatically detecting format from suffix.</p> <p>Supports: - .csv files (Bayesys format) - .tetrad files (Tetrad format)</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad arg types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If file suffix is not supported.</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If path to file does not exist.</p> </li> </ul>"},{"location":"api/graph_io_common/#causaliq_core.graph.io.common.write(graph)","title":"<code>graph</code>","text":"(<code>PDAG</code>)           \u2013            <p>Graph to write to file.</p>"},{"location":"api/graph_io_common/#causaliq_core.graph.io.common.write(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Full path name of file to write.</p>"},{"location":"api/graph_io_tetrad/","title":"Tetrad Format I/O","text":"<p>The <code>causaliq_core.graph.io.tetrad</code> module provides functions for reading and writing graphs in the Tetrad native format.</p>"},{"location":"api/graph_io_tetrad/#format-description","title":"Format Description","text":"<p>The Tetrad format is a text-based format used by the Tetrad software suite for representing graphs: - Each line represents an edge with numbered format - Supports directed (<code>--&gt;</code>) and undirected (<code>---</code>) edges - Nodes are identified by names, edges by source and target nodes</p>"},{"location":"api/graph_io_tetrad/#functions","title":"Functions","text":""},{"location":"api/graph_io_tetrad/#readpath-str-uniondag-pdag","title":"<code>read(path: str) -&gt; Union[DAG, PDAG]</code>","text":"<p>Read a graph from a Tetrad format file.</p> <p>Parameters: - <code>path</code> (str): Full path name of file to read</p> <p>Returns: - <code>DAG</code> or <code>PDAG</code>: Graph read from file. Returns DAG if all edges are directed, PDAG otherwise</p> <p>Raises: - <code>TypeError</code>: If path is not a string - <code>FileNotFoundError</code>: If file is not found - <code>FileFormatError</code>: If file format is invalid or contains syntax errors</p> <p>Example:</p> <pre><code>from causaliq_core.graph.io.tetrad import read\n\n# Read graph from Tetrad format file\ngraph = read(\"data/graph.tetrad\")\n</code></pre>"},{"location":"api/graph_io_tetrad/#writegraph-unionpdag-dag-path-str-none","title":"<code>write(graph: Union[PDAG, DAG], path: str) -&gt; None</code>","text":"<p>Write a graph to a Tetrad format file.</p> <p>Parameters: - <code>graph</code> (PDAG or DAG): Graph to write - <code>path</code> (str): Full path name of file to create</p> <p>Raises: - <code>TypeError</code>: If graph is not a PDAG or DAG instance, or path is not a string - <code>OSError</code>: If file cannot be created</p> <p>Example:</p> <pre><code>from causaliq_core.graph import DAG\nfrom causaliq_core.graph.io.tetrad import write\n\n# Create and write a DAG\ndag = DAG(['X', 'Y', 'Z'], [('X', '-&gt;', 'Y'), ('Y', '-&gt;', 'Z')])\nwrite(dag, \"output/graph.tetrad\")\n</code></pre>"},{"location":"api/graph_io_tetrad/#file-format-details","title":"File Format Details","text":"<p>The Tetrad format uses numbered lines to represent edges: - Each edge line starts with a number followed by a period - Format: <code>{number}. {source} {edge_type} {target}</code> - Edge types: <code>--&gt;</code> for directed, <code>---</code> for undirected</p> <p>Example Tetrad file content: <pre><code>Graph Nodes:\nX,Y,Z\n\nGraph Edges:\n1. X --&gt; Y\n2. Y --&gt; Z  \n</code></pre></p> <p>This represents a DAG with nodes X, Y, Z and directed edges X \u2192 Y \u2192 Z.</p>"},{"location":"api/graph_io_tetrad/#compatibility","title":"Compatibility","text":"<p>This module is compatible with graphs exported from: - Tetrad software suite - PCALG R package (when using Tetrad export format) - Other causal discovery tools that support Tetrad format</p>"},{"location":"api/graph_pdag/","title":"Graph PDAG Module","text":"<p>The <code>PDAG</code> (Partially Directed Acyclic Graph) class extends SDG to work specifically with partially directed acyclic graphs used in causal discovery.</p>"},{"location":"api/graph_pdag/#classes","title":"Classes","text":""},{"location":"api/graph_pdag/#pdag","title":"<code>PDAG</code>","text":"<p>Partially Directed Acyclic Graph class for representing causal graph structures.</p> <p>Features:</p> <ul> <li>Directed and undirected edges only</li> <li>Acyclicity validation</li> <li>Causal discovery algorithm support</li> <li>Conversion to/from other graph types</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import PDAG\n\n# Create a PDAG\nnodes = ['X', 'Y', 'Z']\nedges = [\n    ('X', '-&gt;', 'Y'),    # Directed edge (oriented)\n    ('Y', '--', 'Z'),    # Undirected edge (unoriented)\n]\npdag = PDAG(nodes, edges)\n</code></pre>"},{"location":"api/graph_pdag/#notpdagerror","title":"<code>NotPDAGError</code>","text":"<p>Exception raised when attempting to create an invalid PDAG.</p>"},{"location":"api/graph_pdag/#reference","title":"Reference","text":"<p>Classes:</p> <ul> <li> <code>NotPDAGError</code>           \u2013            <p>Indicate graph is not a PDAG when one is expected.</p> </li> <li> <code>PDAG</code>           \u2013            <p>Partially directed acyclic graph (PDAG).</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag-classes","title":"Classes","text":""},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.NotPDAGError","title":"NotPDAGError","text":"<p>Indicate graph is not a PDAG when one is expected.</p>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG","title":"PDAG","text":"<pre><code>PDAG(nodes: List[str], edges: List[Tuple[str, str, str]])\n</code></pre> <p>Partially directed acyclic graph (PDAG).</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>nodes</code>               (<code>List[str]</code>)           \u2013            <p>Graph nodes in alphabetical order.</p> </li> <li> <code>edges</code>               (<code>Dict[Tuple[str, str], EdgeType]</code>)           \u2013            <p>Graph edges {(node1, node2): EdgeType}.</p> </li> <li> <code>is_directed</code>               (<code>bool</code>)           \u2013            <p>Graph only has directed (causal) edges.</p> </li> <li> <code>parents</code>               (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of node {node: [parents]}.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If nodes and edges not both lists.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If node or edge invalid.</p> </li> <li> <code>NotPDAGError</code>             \u2013            <p>If graph is not a PDAG.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotPDAGError</code>             \u2013            <p>If graph is not a PDAG.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>edge_reversible</code>             \u2013              <p>Return whether specified edge is in CPDAG and is reversible.</p> </li> <li> <code>rename</code>             \u2013              <p>Rename nodes in place according to name map.</p> </li> <li> <code>partial_order</code>             \u2013              <p>Return partial topological ordering for the directed part of a</p> </li> <li> <code>is_DAG</code>             \u2013              <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> </li> <li> <code>is_PDAG</code>             \u2013              <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> </li> <li> <code>undirected_trees</code>             \u2013              <p>Return undirected trees present in graph.</p> </li> <li> <code>components</code>             \u2013              <p>Return components present in graph.</p> </li> <li> <code>number_components</code>             \u2013              <p>Return number of components (including unconnected nodes) in graph.</p> </li> <li> <code>to_adjmat</code>             \u2013              <p>Return an adjacency matrix representation of the graph.</p> </li> <li> <code>__str__</code>             \u2013              <p>Return a human-readable description of the graph.</p> </li> <li> <code>__eq__</code>             \u2013              <p>Test if graph is identical to this one.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes present in the graph.</p>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>Edges which define the graph connections as list of tuples: (node1, dependency symbol, node2).</p>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes present in the graph.</p>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>Edges which define the graph connections.</p>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG-functions","title":"Functions","text":""},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.edge_reversible","title":"edge_reversible","text":"<pre><code>edge_reversible(edge: Tuple[str, str]) -&gt; bool\n</code></pre> <p>Return whether specified edge is in CPDAG and is reversible.</p> <p>Parameters:</p> <ul> <li> <code>edge</code> \u00b6              (<code>Tuple[str, str]</code>)           \u2013            <p>Edge to examine, (node1, node2).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether present and reversible, or not.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If edge argument has bad type.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.rename","title":"rename","text":"<pre><code>rename(name_map: Dict[str, str]) -&gt; None\n</code></pre> <p>Rename nodes in place according to name map.</p> <p>Parameters:</p> <ul> <li> <code>name_map</code> \u00b6              (<code>Dict[str, str]</code>)           \u2013            <p>Name mapping {name: new name}. Must have mapping for every node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values e.g. unknown node names.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.partial_order","title":"partial_order  <code>classmethod</code>","text":"<pre><code>partial_order(\n    parents: Dict[str, List[str]],\n    nodes: Optional[Union[List[str], Set[str]]] = None,\n    new_arc: Optional[Tuple[str, str]] = None,\n) -&gt; Optional[List[Set[str]]]\n</code></pre> <p>Return partial topological ordering for the directed part of a graph.</p> <p>The graph is specified by list of parents for each node.</p> <p>Parameters:</p> <ul> <li> <code>parents</code> \u00b6              (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of each node {node: [parents]}.</p> </li> <li> <code>nodes</code> \u00b6              (<code>Optional[Union[List[str], Set[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional complete list of nodes including parentless ones for use if parents argument doesn't include them already.</p> </li> <li> <code>new_arc</code> \u00b6              (<code>Optional[Tuple[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A new arc (n1, n2) to be added before order is evaluated. If the opposing arc is implied in parents then it is removed so that arc reversal is also supported. This argument facilitates seeing whether an arc addition or reversal would create a cycle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>Nodes in a partial topological order as list of sets or None if</p> </li> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>there is no ordering which means the graph is cyclic.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.is_DAG","title":"is_DAG","text":"<pre><code>is_DAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a DAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.is_PDAG","title":"is_PDAG","text":"<pre><code>is_PDAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a PDAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.undirected_trees","title":"undirected_trees","text":"<pre><code>undirected_trees() -&gt; List[Set[Union[Tuple[str, str], Tuple[str, None]]]]\n</code></pre> <p>Return undirected trees present in graph.</p> <p>Returns:</p> <ul> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>List of trees, each tree a set of tuples representing edges in tree</p> </li> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>(n1, n2) or a single isolated node (n1, None).</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.components","title":"components","text":"<pre><code>components() -&gt; List[List[str]]\n</code></pre> <p>Return components present in graph.</p> <p>Uses tree search algorithm to span the undirected graph to identify nodes in individual trees which are the spanning tree of each component.</p> <p>Returns:</p> <ul> <li> <code>List[List[str]]</code>           \u2013            <p>List of lists, each a list of sorted nodes in component.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.number_components","title":"number_components","text":"<pre><code>number_components() -&gt; int\n</code></pre> <p>Return number of components (including unconnected nodes) in graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of components.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.to_adjmat","title":"to_adjmat","text":"<pre><code>to_adjmat() -&gt; DataFrame\n</code></pre> <p>Return an adjacency matrix representation of the graph.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Adjacency matrix as a pandas DataFrame.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a human-readable description of the graph.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String description of graph.</p> </li> </ul>"},{"location":"api/graph_pdag/#causaliq_core.graph.pdag.PDAG.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Test if graph is identical to this one.</p> <p>Parameters:</p> <ul> <li> <code>other</code> \u00b6              (<code>object</code>)           \u2013            <p>Graph to compare with self.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if other is identical to self.</p> </li> </ul>"},{"location":"api/graph_sdg/","title":"Graph SDG Module","text":"<p>This module supports Simple Dependency Graphs (SDGs) which are a general form of graph that has at most one edge between any pair of nodes.</p> <p>The two endpoints of each edge can be a head \"&gt;\", tail \"-\" or circle \"o\" (which means either head or tail).</p> <p>This format can represent most dependency graph types including:  - Markov Graphs  - Directed Acyclic Graphs (DAGs)  - Partially Directed Acyclic Graphs (PDAGs)  - Maximal Ancestral Graphs (MAGs)  - Partial Ancestral Graphs (PAGs)</p>"},{"location":"api/graph_sdg/#classes","title":"Classes","text":""},{"location":"api/graph_sdg/#sdg","title":"<code>SDG</code>","text":"<p>Simple Dependency Graph class that supports multiple edge types.</p> <p>Features:</p> <ul> <li>Mixed edge types (directed, undirected, bidirected)</li> <li>Node and edge validation</li> <li>Graph manipulation and traversal</li> <li>Adjacency matrix representation</li> </ul> <p>Usage:</p> <pre><code>from causaliq_core.graph import SDG, EdgeType\n\n# Create an SDG with mixed edges\nnodes = ['A', 'B', 'C']\nedges = [\n    ('A', '-&gt;', 'B'),    # Directed edge\n    ('B', '--', 'C'),    # Undirected edge\n]\nsdg = SDG(nodes, edges)\n</code></pre>"},{"location":"api/graph_sdg/#reference","title":"Reference","text":"<p>Simple Dependency Graph (SDG)</p> <p>This module supports Simple Dependency Graphs (SDGs) which are a general form of graph that has at most one edge between any pair of nodes.</p> <p>The two endpoints of each edge can be a head \"&gt;\", tail \"-\" or circle \"o\" (which means either head or tail).</p> This format can represent most dependency graph types including <ul> <li>Markov Graphs</li> <li>Directed Acyclic Graphs (DAGs)</li> <li>Partially Directed Acyclic Graphs (PDAGs)</li> <li>Maximal Ancestral Graphs (MAGs)</li> <li>Partial Ancestral Graphs (PAGs)</li> </ul> <p>Classes:</p> <ul> <li> <code>SDG</code>           \u2013            <p>Base class for simple dependency graphs (one edge between vertices).</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg-classes","title":"Classes","text":""},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG","title":"SDG","text":"<pre><code>SDG(nodes: List[str], edges: List[Tuple[str, str, str]])\n</code></pre> <p>Base class for simple dependency graphs (one edge between vertices).</p> <p>Simple Dependency Graphs (SDGs) are a general form of graph that has at most one edge between any pair of nodes. The two endpoints of each edge can be a     head \"&gt;\", tail \"-\" or circle \"o\" (which means either head or tail).</p> <p>This format can represent most dependency graph types including: - Markov Graphs - Directed Acyclic Graphs (DAGs) - Partially Directed Acyclic Graphs (PDAGs) - Maximal Ancestral Graphs (MAGs) - Partial Ancestral Graphs (PAGs)</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>nodes</code>               (<code>List[str]</code>)           \u2013            <p>Graph nodes in alphabetical order.</p> </li> <li> <code>edges</code>               (<code>Dict[Tuple[str, str], EdgeType]</code>)           \u2013            <p>Graph edges {(node1, node2): EdgeType}.</p> </li> <li> <code>is_directed</code>               (<code>bool</code>)           \u2013            <p>Graph only has directed (causal) edges.</p> </li> <li> <code>is_partially_directed</code>               (<code>bool</code>)           \u2013            <p>Graph is partially directed.</p> </li> <li> <code>parents</code>               (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of node {node: [parents]}.</p> </li> <li> <code>has_directed_cycles</code>               (<code>bool</code>)           \u2013            <p>Contains any directed cycles.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If nodes and edges are not both lists.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If node or edge is invalid.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> </ul> <p>Methods:</p> <ul> <li> <code>rename</code>             \u2013              <p>Rename nodes in place according to name map.</p> </li> <li> <code>partial_order</code>             \u2013              <p>Return partial topological ordering for the directed part of a</p> </li> <li> <code>is_DAG</code>             \u2013              <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> </li> <li> <code>is_PDAG</code>             \u2013              <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> </li> <li> <code>undirected_trees</code>             \u2013              <p>Return undirected trees present in graph.</p> </li> <li> <code>components</code>             \u2013              <p>Return components present in graph.</p> </li> <li> <code>number_components</code>             \u2013              <p>Return number of components (including unconnected nodes) in graph.</p> </li> <li> <code>to_adjmat</code>             \u2013              <p>Return an adjacency matrix representation of the graph.</p> </li> <li> <code>__str__</code>             \u2013              <p>Return a human-readable description of the graph.</p> </li> <li> <code>__eq__</code>             \u2013              <p>Test if graph is identical to this one.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>Nodes present in the graph.</p>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>Edges which define the graph connections as list of tuples: (node1, dependency symbol, node2).</p>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG(nodes)","title":"<code>nodes</code>","text":"(<code>List[str]</code>)           \u2013            <p>List of node names in the graph.</p>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG(edges)","title":"<code>edges</code>","text":"(<code>List[Tuple[str, str, str]]</code>)           \u2013            <p>List of edge tuples in format (node1, edge_type_symbol, node2).</p>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG-functions","title":"Functions","text":""},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.rename","title":"rename","text":"<pre><code>rename(name_map: Dict[str, str]) -&gt; None\n</code></pre> <p>Rename nodes in place according to name map.</p> <p>Parameters:</p> <ul> <li> <code>name_map</code> \u00b6              (<code>Dict[str, str]</code>)           \u2013            <p>Name mapping {name: new name}. Must have mapping for every node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>With bad arg type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>With bad arg values e.g. unknown node names.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.partial_order","title":"partial_order  <code>classmethod</code>","text":"<pre><code>partial_order(\n    parents: Dict[str, List[str]],\n    nodes: Optional[Union[List[str], Set[str]]] = None,\n    new_arc: Optional[Tuple[str, str]] = None,\n) -&gt; Optional[List[Set[str]]]\n</code></pre> <p>Return partial topological ordering for the directed part of a graph.</p> <p>The graph is specified by list of parents for each node.</p> <p>Parameters:</p> <ul> <li> <code>parents</code> \u00b6              (<code>Dict[str, List[str]]</code>)           \u2013            <p>Parents of each node {node: [parents]}.</p> </li> <li> <code>nodes</code> \u00b6              (<code>Optional[Union[List[str], Set[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional complete list of nodes including parentless ones for use if parents argument doesn't include them already.</p> </li> <li> <code>new_arc</code> \u00b6              (<code>Optional[Tuple[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A new arc (n1, n2) to be added before order is evaluated. If the opposing arc is implied in parents then it is removed so that arc reversal is also supported. This argument facilitates seeing whether an arc addition or reversal would create a cycle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>Nodes in a partial topological order as list of sets or None if</p> </li> <li> <code>Optional[List[Set[str]]]</code>           \u2013            <p>there is no ordering which means the graph is cyclic.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.is_DAG","title":"is_DAG","text":"<pre><code>is_DAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Directed Acyclic Graph (DAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a DAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.is_PDAG","title":"is_PDAG","text":"<pre><code>is_PDAG() -&gt; bool\n</code></pre> <p>Return whether graph is a Partially Directed Acyclic Graph (PDAG).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if graph is a PDAG, False otherwise.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.undirected_trees","title":"undirected_trees","text":"<pre><code>undirected_trees() -&gt; List[Set[Union[Tuple[str, str], Tuple[str, None]]]]\n</code></pre> <p>Return undirected trees present in graph.</p> <p>Returns:</p> <ul> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>List of trees, each tree a set of tuples representing edges in tree</p> </li> <li> <code>List[Set[Union[Tuple[str, str], Tuple[str, None]]]]</code>           \u2013            <p>(n1, n2) or a single isolated node (n1, None).</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.components","title":"components","text":"<pre><code>components() -&gt; List[List[str]]\n</code></pre> <p>Return components present in graph.</p> <p>Uses tree search algorithm to span the undirected graph to identify nodes in individual trees which are the spanning tree of each component.</p> <p>Returns:</p> <ul> <li> <code>List[List[str]]</code>           \u2013            <p>List of lists, each a list of sorted nodes in component.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.number_components","title":"number_components","text":"<pre><code>number_components() -&gt; int\n</code></pre> <p>Return number of components (including unconnected nodes) in graph.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of components.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.to_adjmat","title":"to_adjmat","text":"<pre><code>to_adjmat() -&gt; DataFrame\n</code></pre> <p>Return an adjacency matrix representation of the graph.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Adjacency matrix as a pandas DataFrame.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a human-readable description of the graph.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String description of graph.</p> </li> </ul>"},{"location":"api/graph_sdg/#causaliq_core.graph.sdg.SDG.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Test if graph is identical to this one.</p> <p>Parameters:</p> <ul> <li> <code>other</code> \u00b6              (<code>object</code>)           \u2013            <p>Graph to compare with self.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if other is identical to self.</p> </li> </ul>"},{"location":"api/main/","title":"Main Package","text":"<p>The main <code>causaliq_core</code> package provides core constants and metadata for the CausalIQ ecosystem.</p>"},{"location":"api/main/#constants","title":"Constants","text":""},{"location":"api/main/#software_version","title":"<code>SOFTWARE_VERSION</code>","text":"<p>Legacy software version constant for backward compatibility.</p> <p>Type: <code>int</code> Value: <code>229</code></p> <p>Usage:</p> <pre><code>from causaliq_core import SOFTWARE_VERSION\n\nprint(f\"Software version: {SOFTWARE_VERSION}\")\n</code></pre> <p>This constant was migrated from the legacy module and is maintained for compatibility with existing code.</p>"},{"location":"api/main/#package-metadata","title":"Package Metadata","text":"<p>The package also exports standard metadata:</p> <ul> <li><code>__version__</code>: Package version string (e.g., \"0.1.0\")</li> <li><code>VERSION</code>: Version as tuple for programmatic comparison</li> <li><code>__author__</code>, <code>__email__</code>: Author information</li> <li><code>__title__</code>, <code>__description__</code>: Package title and description</li> <li><code>__url__</code>, <code>__license__</code>: Repository URL and license</li> </ul> <p>Usage:</p> <pre><code>import causaliq_core\n\nprint(f\"Package version: {causaliq_core.__version__}\")\nprint(f\"Version tuple: {causaliq_core.VERSION}\")\n</code></pre>"},{"location":"api/overview/","title":"CausalIQ Core API Reference","text":"<p>This is the entry point for the API documentation. It is organised by module, with each module briefly described here to ease navigation of the API and avoid overlong pages.</p>"},{"location":"api/overview/#main-package","title":"Main Package","text":"<p>The main <code>causaliq_core</code> package exports: - <code>SOFTWARE_VERSION</code>: Legacy software version constant for compatibility - Package metadata (<code>__version__</code>, <code>VERSION</code>, etc.)</p>"},{"location":"api/overview/#modules","title":"Modules","text":""},{"location":"api/overview/#cli","title":"CLI","text":"<p>Command-line interface functionality for CausalIQ Core.</p>"},{"location":"api/overview/#graph","title":"Graph","text":"<p>Graph-related enumerations and utilities for edge types and marks used in causal discovery.</p>"},{"location":"api/overview/#utils","title":"Utils","text":"<p>Comprehensive utility module with specialized functional areas: - Mathematical Functions: Number formatting and logarithm calculations - Environment Detection: System information with caching - Random Numbers: Reproducible random number generation - Timing Utilities: Performance measurement and timeouts - Enhanced enumeration functionality</p>"},{"location":"api/utils/","title":"Utils Module Overview","text":"<p>The <code>causaliq_core.utils</code> module provides utility classes, enhanced enumeration functionality, mathematical utilities, random number utilities, and system utilities for common programming patterns used across the CausalIQ ecosystem.</p>"},{"location":"api/utils/#core-components","title":"Core Components","text":""},{"location":"api/utils/#mathematical-functions","title":"Mathematical Functions","text":"<p>Number formatting and logarithm calculations including:</p> <ul> <li><code>rndsf()</code> - Round to significant figures with precise formatting</li> <li><code>ln()</code> - Logarithm with configurable base (2, 10, or 'e')</li> </ul>"},{"location":"api/utils/#environment-detection","title":"Environment Detection","text":"<p>System environment detection with intelligent caching:</p> <ul> <li><code>environment()</code> - Hardware and software environment information</li> <li>Cross-platform compatibility with automatic caching</li> </ul>"},{"location":"api/utils/#random-number-generation","title":"Random Number Generation","text":"<p>Stable, reproducible random number sequences:</p> <ul> <li>Cross-platform reproducible sequences</li> <li>Stable random number generation for experiments</li> <li>Random integer iterators</li> <li>Experiment randomization enums</li> </ul>"},{"location":"api/utils/#timing-utilities","title":"Timing Utilities","text":"<p>Performance measurement and timeout functionality:</p> <ul> <li><code>Timing</code> class for performance measurement</li> <li><code>run_with_timeout()</code> and <code>@with_timeout</code> for algorithm timeouts  </li> <li>Thread-safe execution with configurable timeouts</li> </ul>"},{"location":"api/utils/#enhanced-enumerations","title":"Enhanced Enumerations","text":""},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs","title":"EnumWithAttrs","text":"<pre><code>EnumWithAttrs(_: str, label: str)\n</code></pre> <p>Base class for enumerations with additional read-only attributes.</p> <p>This class extends the standard Python Enum to support enums that carry additional attributes such as human-readable labels. Sub-classes can extend this pattern to include more attributes.</p> Example <p>class Status(EnumWithAttrs): ...     PENDING = 'pending', 'Pending Review' ...     APPROVED = 'approved', 'Approved for Use' ...     REJECTED = 'rejected', 'Rejected - Needs Changes'</p> <p>print(Status.PENDING)  # 'pending' print(Status.PENDING.label)  # 'Pending Review'</p> Note <p>Values should be set as tuples where the first element is the enum value and subsequent elements are the additional attributes. The base class provides a <code>label</code> attribute from the second tuple element.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__new__</code>             \u2013              <p>Create a new enum instance with additional attributes.</p> </li> <li> <code>__str__</code>             \u2013              <p>Return the string representation of the enum value.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>Get the human-readable label for this enum value.</p> </li> </ul>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs(_)","title":"<code>_</code>","text":"(<code>str</code>)           \u2013            <p>The enum value (already set in new)</p>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs(label)","title":"<code>label</code>","text":"(<code>str</code>)           \u2013            <p>Human-readable label for this enum value</p>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs.label","title":"label  <code>property</code>","text":"<pre><code>label: str\n</code></pre> <p>Get the human-readable label for this enum value.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The label string for this enum value</p> </li> </ul>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs.__new__","title":"__new__","text":"<pre><code>__new__(*args: Any, **kwargs: Any) -&gt; EnumWithAttrs\n</code></pre> <p>Create a new enum instance with additional attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EnumWithAttrs</code>           \u2013            <p>New enum instance with the value set to the first argument</p> </li> </ul>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs.__new__(*args)","title":"<code>*args</code>","text":"(<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>The enum value and additional attribute values</p>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs.__new__(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments (unused)</p>"},{"location":"api/utils/#causaliq_core.utils.EnumWithAttrs.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the string representation of the enum value.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The enum's value as a string</p> </li> </ul>"},{"location":"api/utils/#usage-pattern","title":"Usage Pattern","text":"<p>The utils module is designed as a consolidated toolkit for common programming patterns:</p> <pre><code># Mathematical operations\nfrom causaliq_core.utils import rndsf, ln\n\n# Environment detection  \nfrom causaliq_core.utils import environment\n\n# Enhanced enums\nfrom causaliq_core.utils import EnumWithAttrs\n\n# Timing and random numbers in submodules\nfrom causaliq_core.utils.timing import Timing\nfrom causaliq_core.utils.random import stable_random\n</code></pre>"},{"location":"api/utils/#module-structure","title":"Module Structure","text":"<ul> <li>Main Module (<code>causaliq_core.utils</code>): Core functions and enhanced enums</li> <li>Random Submodule (<code>causaliq_core.utils.random</code>): Random number utilities</li> <li>Timing Submodule (<code>causaliq_core.utils.timing</code>): Performance and timeout utilities</li> </ul> <p>For detailed API documentation, see the specialized pages linked above.</p>"},{"location":"api/utils_environment/","title":"Environment Functions","text":"<p>System environment detection with intelligent caching for performance optimization.</p>"},{"location":"api/utils_environment/#causaliq_core.utils.environment","title":"environment","text":"<p>Environment and system information utilities.</p> <p>Functions:</p> <ul> <li> <code>environment</code>             \u2013              <p>Obtain details of the hardware and software environment.</p> </li> </ul>"},{"location":"api/utils_environment/#causaliq_core.utils.environment.environment","title":"environment","text":"<pre><code>environment(cache_dir: Optional[str] = None) -&gt; Dict[str, Any]\n</code></pre> <p>Obtain details of the hardware and software environment.</p> <p>For efficiency, this is obtained from a cached file \"environment.json\" if one modified in the last 24 hours is available, otherwise the OS is queried and a new cache file created.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Environment information including os, cpu, python, ram.</p> </li> </ul>"},{"location":"api/utils_environment/#causaliq_core.utils.environment.environment(cache_dir)","title":"<code>cache_dir</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Optional cache directory. If None, uses standard user cache directory for the platform.</p>"},{"location":"api/utils_environment/#usage-examples","title":"Usage Examples","text":""},{"location":"api/utils_environment/#basic-environment-detection","title":"Basic Environment Detection","text":"<pre><code>from causaliq_core.utils import environment\n\n# Use default cache location\nenv = environment()\nprint(f\"Running on {env['os']} with {env['ram']}GB RAM\")\nprint(f\"CPU: {env['cpu']}\")\nprint(f\"Python: {env['python']}\")\n</code></pre>"},{"location":"api/utils_environment/#custom-cache-directory","title":"Custom Cache Directory","text":"<pre><code>from causaliq_core.utils import environment\n\n# Use custom cache directory\nenv = environment(cache_dir=\"/tmp/my_cache\")\nprint(f\"OS: {env['os']}\")\n</code></pre>"},{"location":"api/utils_environment/#returned-information","title":"Returned Information","text":"<p>The environment function returns a dictionary with the following keys:</p> <ul> <li><code>'os'</code>: Operating system name and version</li> <li><code>'cpu'</code>: CPU brand/model information  </li> <li><code>'python'</code>: Python version string</li> <li><code>'ram'</code>: Total system RAM in GB (rounded to nearest GB)</li> </ul>"},{"location":"api/utils_environment/#caching-behavior","title":"Caching Behavior","text":"<ul> <li>Cache files are stored as <code>environment.json</code> in the cache directory</li> <li>Cache is refreshed if older than 24 hours</li> <li>Uses platform-appropriate cache locations (e.g., <code>~/.cache</code> on Linux, <code>~/Library/Caches</code> on macOS)</li> <li>Gracefully handles cache corruption or permission errors</li> </ul>"},{"location":"api/utils_math/","title":"Mathematical Functions","text":"<p>Mathematical utility functions for number formatting and logarithm calculations.</p>"},{"location":"api/utils_math/#causaliq_core.utils.rndsf","title":"rndsf","text":"<pre><code>rndsf(x: Union[int, float], sf: int, zero: Optional[float] = None) -&gt; str\n</code></pre> <p>Round number to specified significant figures.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted string representation with specified significant figures.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have invalid types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid values.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rndsf(1.234567, 3)\n'1.23'\n&gt;&gt;&gt; rndsf(0.001234, 3)\n'0.00123'\n&gt;&gt;&gt; rndsf(1234567, 3)\n'1230000'\n</code></pre>"},{"location":"api/utils_math/#causaliq_core.utils.rndsf(x)","title":"<code>x</code>","text":"(<code>Union[int, float]</code>)           \u2013            <p>Number to round.</p>"},{"location":"api/utils_math/#causaliq_core.utils.rndsf(sf)","title":"<code>sf</code>","text":"(<code>int</code>)           \u2013            <p>Number of significant figures (2-10).</p>"},{"location":"api/utils_math/#causaliq_core.utils.rndsf(zero)","title":"<code>zero</code>","text":"(<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Optional zero threshold (default: 10^-sf).</p>"},{"location":"api/utils_math/#causaliq_core.utils.ln","title":"ln","text":"<pre><code>ln(x: float, base: Union[int, str] = 'e') -&gt; float\n</code></pre> <p>Return logarithm to specified base.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Logarithm of x to the specified base.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If arguments have invalid types.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If arguments have invalid values.</p> </li> </ul> Example <p>ln(10, 10) 1.0 ln(8, 2) 3.0 ln(2.718281828459045)  # e 1.0</p>"},{"location":"api/utils_math/#causaliq_core.utils.ln(x)","title":"<code>x</code>","text":"(<code>float</code>)           \u2013            <p>Number to obtain logarithm of.</p>"},{"location":"api/utils_math/#causaliq_core.utils.ln(base)","title":"<code>base</code>","text":"(<code>Union[int, str]</code>, default:                   <code>'e'</code> )           \u2013            <p>Base to use - 2, 10, or 'e' for natural logarithm.</p>"},{"location":"api/utils_math/#usage-examples","title":"Usage Examples","text":""},{"location":"api/utils_math/#significant-figure-rounding","title":"Significant Figure Rounding","text":"<pre><code>from causaliq_core.utils import rndsf\n\n# Basic rounding\nrndsf(1.23456789, 4)  # Returns '1.235'\n\n# Small numbers\nrndsf(0.000123, 3)    # Returns '0.000123'\n\n# Large numbers  \nrndsf(1234567, 3)     # Returns '1230000.0'\n\n# Custom zero threshold\nrndsf(0.0001, 3, zero=0.001)  # Returns '0.0'\n</code></pre>"},{"location":"api/utils_math/#logarithm-calculations","title":"Logarithm Calculations","text":"<pre><code>from causaliq_core.utils import ln\n\n# Base 10 logarithm\nln(10, 10)  # Returns 1.0\n\n# Base 2 logarithm\nln(8, 2)    # Returns 3.0\n\n# Natural logarithm (default)\nln(2.718281828459045)  # Returns 1.0\nln(2.718281828459045, 'e')  # Same as above\n</code></pre>"},{"location":"api/utils_random/","title":"Random Number Utilities","text":"<p>Stable, reproducible random number generation for scientific computing and experimental repeatability.</p>"},{"location":"api/utils_random/#core-functions","title":"Core Functions","text":""},{"location":"api/utils_random/#causaliq_core.utils.random.random_generator","title":"random_generator","text":"<pre><code>random_generator() -&gt; Generator\n</code></pre> <p>Get the current random number generator instance.</p> <p>Returns:</p> <ul> <li> <code>Generator</code>           \u2013            <p>numpy.random.Generator: The current random number generator</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.set_random_seed","title":"set_random_seed","text":"<pre><code>set_random_seed(seed: Optional[int] = None) -&gt; None\n</code></pre> <p>Set the seed of the random number generator.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If seed is not an int or None</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.set_random_seed(seed)","title":"<code>seed</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Seed for pseudo-random number generation, or None for truly random</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.stable_random","title":"stable_random","text":"<pre><code>stable_random(path: Optional[str] = None) -&gt; float\n</code></pre> <p>Return next random number in stable sequence.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Next random number from stable sequence</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>StopIteration</code>             \u2013            <p>When no more numbers available</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>For legacy compatibility when sequence unavailable</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.stable_random(path)","title":"<code>path</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Legacy compatibility parameter (ignored)</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.generate_stable_random","title":"generate_stable_random","text":"<pre><code>generate_stable_random(N: int, path: Optional[str] = None) -&gt; List[float]\n</code></pre> <p>Generate a sequence of random numbers for repeatability.</p> <p>This function returns N random numbers from the embedded stable sequence, maintaining compatibility with legacy code that expects file-based generation. For compatibility, the path parameter is accepted but ignored.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>List of N random numbers from the stable sequence</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If N is greater than available sequence length</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.generate_stable_random(N)","title":"<code>N</code>","text":"(<code>int</code>)           \u2013            <p>Number of random numbers to generate</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.generate_stable_random(path)","title":"<code>path</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Legacy compatibility parameter (ignored)</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.init_stable_random","title":"init_stable_random","text":"<pre><code>init_stable_random(offset: int = 0) -&gt; None\n</code></pre> <p>Set the stable random offset and clear cache.</p> <p>Sets the stable random offset so that different stable sequences can be generated from the same embedded data. Also clears the cache.</p> <p>Parameters:</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.init_stable_random(offset)","title":"<code>offset</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Offset which generates different sequences</p>"},{"location":"api/utils_random/#classes","title":"Classes","text":""},{"location":"api/utils_random/#causaliq_core.utils.random.Randomise","title":"Randomise","text":"<p>Supported experiment randomisations.</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers","title":"RandomIntegers","text":"<pre><code>RandomIntegers(n: int, subsample: int = 0, path: Optional[str] = None)\n</code></pre> <p>Iterable producing repeatable sequences of random integers.</p> <p>Produces repeatable sequences of random integers for all integers in a range from 0 to specified n.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If bad argument type</p> </li> <li> <code>ValueError</code>             \u2013            <p>If bad argument value</p> </li> <li> <code>FileNotFoundError</code>             \u2013            <p>If stable random sequence unavailable</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__iter__</code>             \u2013              <p>Initialize the iterator.</p> </li> <li> <code>__next__</code>             \u2013              <p>Return next integer in random sequence.</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers(n)","title":"<code>n</code>","text":"(<code>int</code>)           \u2013            <p>Maximum integer in sequence (exclusive upper bound)</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers(subsample)","title":"<code>subsample</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Unique integer id for each sequence</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers(path)","title":"<code>path</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Legacy compatibility parameter (ignored)</p>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; RandomIntegers\n</code></pre> <p>Initialize the iterator.</p> <p>Returns:</p> <ul> <li> <code>RandomIntegers</code>           \u2013            <p>The initialized iterator</p> </li> </ul>"},{"location":"api/utils_random/#causaliq_core.utils.random.RandomIntegers.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; int\n</code></pre> <p>Return next integer in random sequence.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Next integer in random sequence</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>StopIteration</code>             \u2013            <p>When all values have been returned</p> </li> </ul>"},{"location":"api/utils_random/#usage-examples","title":"Usage Examples","text":""},{"location":"api/utils_random/#basic-random-number-generation","title":"Basic Random Number Generation","text":"<pre><code>from causaliq_core.utils.random import random_generator, set_random_seed\n\n# Set seed for reproducibility\nset_random_seed(42)\n\n# Get generator instance\ngen = random_generator()\nvalue = gen.random()  # Generate random float [0.0, 1.0)\n</code></pre>"},{"location":"api/utils_random/#stable-random-sequences","title":"Stable Random Sequences","text":"<pre><code>from causaliq_core.utils.random import stable_random, init_stable_random\n\n# Initialize stable random sequence\ninit_stable_random()\n\n# Generate stable random numbers\nfor i in range(5):\n    print(stable_random())  # Same sequence every run\n</code></pre>"},{"location":"api/utils_random/#random-integer-sequences","title":"Random Integer Sequences","text":"<pre><code>from causaliq_core.utils.random import RandomIntegers\n\n# Create iterator for random integers 1-10\nrand_ints = RandomIntegers(1, 10)\nfor value in rand_ints:\n    print(value)  # Each integer appears exactly once\n</code></pre>"},{"location":"api/utils_random/#experiment-randomization-types","title":"Experiment Randomization Types","text":"<pre><code>from causaliq_core.utils.random import Randomise\n\n# Available randomization types for experiments\nprint(Randomise.ORDER)      # Randomize variable order\nprint(Randomise.NAMES)      # Randomize variable names  \nprint(Randomise.KNOWLEDGE)  # Randomize knowledge\nprint(Randomise.ROWS)       # Randomize row order\nprint(Randomise.SAMPLE)     # Randomize sample rows\n</code></pre>"},{"location":"api/utils_random/#features","title":"Features","text":"<ul> <li>Cross-platform reproducibility: Same sequences on all platforms</li> <li>Stable sequences: Pre-generated sequence for consistent results</li> <li>Configurable seeding: Support for both deterministic and random seeding</li> <li>Iterator patterns: Clean iteration over random integer sequences</li> <li>Experiment support: Built-in randomization types for scientific experiments</li> </ul>"},{"location":"api/utils_timing/","title":"Timing Utilities","text":"<p>Performance measurement and timeout functionality for algorithm execution.</p>"},{"location":"api/utils_timing/#timing-collection","title":"Timing Collection","text":""},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing","title":"Timing","text":"<p>Singleton class collects count, mean and max time for actions.</p> <p>:cvar bool active: whether timing collection is active :cvar times dict: times collected                   {action1: {scale1: {count, total, max}, ...}, ...} :cvar set/None filter: only these actions will be recorded</p> <p>Methods:</p> <ul> <li> <code>__repr__</code>             \u2013              <p>Print out all timings in nice format</p> </li> <li> <code>add</code>             \u2013              <p>Add an elapsed time without having called now() and record().</p> </li> <li> <code>now</code>             \u2013              <p>Returns current time, generally for the start of an action</p> </li> <li> <code>off</code>             \u2013              <p>Turn timing collection off, lose collected timings.</p> </li> <li> <code>on</code>             \u2013              <p>Switching timing on and off</p> </li> <li> <code>record</code>             \u2013              <p>Records time for specified action</p> </li> <li> <code>to_string</code>             \u2013              <p>Print out timings in nice format, optionally only for specified</p> </li> </ul>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.__repr__","title":"__repr__  <code>classmethod</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Print out all timings in nice format</p> <p>:return str: human friendly timing information</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.add","title":"add  <code>classmethod</code>","text":"<pre><code>add(action: str, elapsed: float, scale: int = 100) -&gt; None\n</code></pre> <p>Add an elapsed time without having called now() and record().</p> <p>Parameters:</p> <p>:raises TypeError: if bad arg type :raises ValueError: if bad arg value</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.add(action)","title":"<code>action</code>","text":"(<code>str</code>)           \u2013            <p>action being timed</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.add(elapsed)","title":"<code>elapsed</code>","text":"(<code>float</code>)           \u2013            <p>elapsed time to add</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.add(scale)","title":"<code>scale</code>","text":"(<code>int</code>, default:                   <code>100</code> )           \u2013            <p>indication of scale of action e.g. num of nodes</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.now","title":"now  <code>classmethod</code>","text":"<pre><code>now() -&gt; Optional[float]\n</code></pre> <p>Returns current time, generally for the start of an action</p> <p>:returns float: epoch time in seconds</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.off","title":"off  <code>classmethod</code>","text":"<pre><code>off() -&gt; None\n</code></pre> <p>Turn timing collection off, lose collected timings.</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.on","title":"on  <code>classmethod</code>","text":"<pre><code>on(active: bool, filter: Optional[set] = None) -&gt; None\n</code></pre> <p>Switching timing on and off</p> <p>:param bool active: whether timing should be on or off :param set/None filter: only these actions recorded</p> <p>:raises TypeError: if bad arg type</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.record","title":"record  <code>classmethod</code>","text":"<pre><code>record(action: str, scale: int, start: Optional[float]) -&gt; Optional[float]\n</code></pre> <p>Records time for specified action</p> <p>:param str action: action being timed :param int scale: indication of scale of action e.g. num of nodes :param int start: time at which action started</p> <p>:raises TypeError: if bad arg type :raises ValueError: if bad arg value</p> <p>:returns float: epoch time when this function called</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.Timing.to_string","title":"to_string  <code>classmethod</code>","text":"<pre><code>to_string(filter: Optional[set] = None) -&gt; str\n</code></pre> <p>Print out timings in nice format, optionally only for specified actions.</p> <p>:param set/None filter: only return info about these actions.</p> <p>:return str: human friendly timing information</p>"},{"location":"api/utils_timing/#timeout-functions","title":"Timeout Functions","text":""},{"location":"api/utils_timing/#causaliq_core.utils.timing.run_with_timeout","title":"run_with_timeout","text":"<pre><code>run_with_timeout(\n    func: Callable,\n    args: tuple = (),\n    kwargs: Optional[dict] = None,\n    timeout_seconds: Optional[int] = None,\n) -&gt; Any\n</code></pre> <p>Run a function with a timeout using threading approach.</p> <p>This is compatible with both subprocess-based (R, Java) and direct Python function calls (causal-learn). For subprocess calls, the timeout will terminate the subprocess if it exceeds the time limit.</p> <p>:param func: Function to execute :param args: Positional arguments for the function :param kwargs: Keyword arguments for the function :param timeout_seconds: Maximum execution time in seconds,                        None for no timeout</p> <p>:raises TimeoutError: if execution exceeds timeout_seconds :raises Exception: any exception raised by the wrapped function</p> <p>:returns: Result from the wrapped function</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.with_timeout","title":"with_timeout","text":"<pre><code>with_timeout(timeout_seconds: Optional[int] = None) -&gt; Callable\n</code></pre> <p>Decorator version of run_with_timeout.</p> <p>:param timeout_seconds: Maximum execution time in seconds,                        None for no timeout</p> Usage <p>@with_timeout(300)  # 5 minute timeout def my_algorithm(data):     # algorithm implementation     return result</p>"},{"location":"api/utils_timing/#causaliq_core.utils.timing.TimeoutError","title":"TimeoutError","text":"<p>Raised when an operation times out</p>"},{"location":"api/utils_timing/#usage-examples","title":"Usage Examples","text":""},{"location":"api/utils_timing/#basic-timing-collection","title":"Basic Timing Collection","text":"<pre><code>from causaliq_core.utils.timing import Timing\nfrom time import sleep\n\n# Enable timing collection\nTiming.on(True)\n\n# Time an operation\nstart = Timing.now()\nsleep(0.1)  # Simulate work\nTiming.record(\"sleep_test\", 1, start)\n\n# View timing summary\nprint(Timing.summary())\n\n# Turn off timing\nTiming.off()\n</code></pre>"},{"location":"api/utils_timing/#filtered-timing","title":"Filtered Timing","text":"<pre><code>from causaliq_core.utils.timing import Timing\n\n# Only collect timing for specific actions\nTiming.on(True, filter={\"critical_operation\", \"slow_function\"})\n\n# This will be recorded\nstart = Timing.now()\n# ... do critical operation ...\nTiming.record(\"critical_operation\", 100, start)\n\n# This will be ignored\nstart = Timing.now()\n# ... do normal operation ...\nTiming.record(\"normal_operation\", 50, start)\n</code></pre>"},{"location":"api/utils_timing/#function-timeout-decorator","title":"Function Timeout Decorator","text":"<pre><code>from causaliq_core.utils.timing import with_timeout, TimeoutError\n\n@with_timeout(5)  # 5 second timeout\ndef slow_function():\n    # This function will be interrupted if it takes &gt; 5 seconds\n    import time\n    time.sleep(10)  # Would normally take 10 seconds\n\ntry:\n    slow_function()\nexcept TimeoutError:\n    print(\"Function timed out!\")\n</code></pre>"},{"location":"api/utils_timing/#direct-timeout-execution","title":"Direct Timeout Execution","text":"<pre><code>from causaliq_core.utils.timing import run_with_timeout, TimeoutError\n\ndef potentially_slow_task(data):\n    # Process data...\n    return processed_data\n\ntry:\n    result = run_with_timeout(\n        potentially_slow_task,\n        args=(my_data,),\n        timeout_seconds=30\n    )\n    print(f\"Completed: {result}\")\nexcept TimeoutError:\n    print(\"Task took too long!\")\n</code></pre>"},{"location":"api/utils_timing/#adding-pre-calculated-times","title":"Adding Pre-calculated Times","text":"<pre><code>from causaliq_core.utils.timing import Timing\n\n# Enable timing\nTiming.on(True)\n\n# Add a timing measurement without calling now()/record()\nTiming.add(\"algorithm_run\", elapsed_time=1.234, scale=500)\n\n# View results\nprint(Timing.summary())\n</code></pre>"},{"location":"api/utils_timing/#features","title":"Features","text":"<ul> <li>Singleton pattern: Global timing collection across application</li> <li>Filtering: Collect timing only for specified actions</li> <li>Scale tracking: Record scale indicators (e.g., number of nodes)</li> <li>Statistical summary: Automatic count, mean, and max calculations</li> <li>Thread-safe timeouts: Reliable timeout functionality for long-running operations</li> <li>Decorator support: Clean timeout decoration for functions</li> <li>Flexible timeout: Support both function decoration and direct execution</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":""},{"location":"architecture/overview/#causaliq-ecosystem","title":"CausalIQ Ecosystem","text":"<p>causaliq-core is a foundational component of the overall CausalIQ ecosystem architecture, providing core utilities and patterns used across CausalIQ projects.</p>"},{"location":"architecture/overview/#design-philosophy","title":"Design Philosophy","text":"<p>The architecture emphasizes reproducibility, performance, and cross-platform compatibility through thoughtful design patterns and data management strategies.</p>"},{"location":"architecture/overview/#key-architectural-features","title":"Key Architectural Features","text":""},{"location":"architecture/overview/#deterministic-random-number-generation","title":"Deterministic Random Number Generation","text":"<p>Design Goal: Ensure reproducible results across platforms and Python versions.</p> <p>Implementation: - Uses an embedded list of pre-generated random numbers (<code>STABLE_RANDOM_SEQUENCE</code>)  - 10,000+ values generated from a fixed seed for cross-platform repeatability - Avoids platform-specific random number generator differences - Supports stable experiment randomization for scientific reproducibility</p> <pre><code># Stable across all platforms and Python versions\nfrom causaliq_core.utils.random import stable_random\nvalues = stable_random(seed=42, count=100)  # Always identical results\n</code></pre>"},{"location":"architecture/overview/#intelligent-environment-caching","title":"Intelligent Environment Caching","text":"<p>Design Goal: Minimize expensive system queries while maintaining fresh data.</p> <p>Implementation: - 24-hour cache expiration for hardware/software environment detection - Platform-appropriate cache directories (follows OS conventions) - Graceful fallback on cache corruption or permission errors - JSON-based cache storage for human readability and debugging</p> <pre><code># First call queries system, subsequent calls use cache\nenv = environment()  # May take 100ms+ on first call\nenv = environment()  # Returns cached data instantly\n</code></pre>"},{"location":"architecture/overview/#enhanced-enumeration-pattern","title":"Enhanced Enumeration Pattern","text":"<p>Design Goal: Extend Python enums with additional attributes while preserving enum semantics.</p> <p>Implementation:</p> <ul> <li><code>EnumWithAttrs</code> base class for enums with human-readable labels</li> <li>Maintains enum value integrity while adding metadata</li> <li>Supports extensible attribute patterns for domain-specific needs</li> </ul>"},{"location":"architecture/overview/#performance-aware-timing-infrastructure","title":"Performance-Aware Timing Infrastructure","text":"<p>Design Goal: Non-intrusive performance measurement for production use.</p> <p>Implementation:</p> <ul> <li>Singleton pattern for centralized timing collection</li> <li>Thread-safe timeout decorators and context managers</li> <li>Optional activation to eliminate overhead in production</li> <li>Hierarchical timing with action/scale categorization</li> </ul>"},{"location":"architecture/overview/#mathematical-precision-controls","title":"Mathematical Precision Controls","text":"<p>Design Goal: Consistent numerical formatting across scientific applications.</p> <p>Implementation:</p> <ul> <li>Significant figure rounding with exact legacy behavior preservation</li> <li>Configurable zero thresholds for scientific notation edge cases</li> <li>String-based output for precise display formatting control</li> </ul>"},{"location":"architecture/overview/#module-organization","title":"Module Organization","text":"<pre><code>causaliq_core/\n\u251c\u2500\u2500 __init__.py          # Package metadata and constants\n\u251c\u2500\u2500 cli.py              # Command-line interface\n\u251c\u2500\u2500 graph/              # Graph structures and enums\n\u251c\u2500\u2500 utils/              # Core utilities\n\u2502   \u251c\u2500\u2500 __init__.py     # Math functions, enums, environment\n\u2502   \u251c\u2500\u2500 random.py       # Stable random generation\n\u2502   \u2514\u2500\u2500 timing.py       # Performance measurement\n</code></pre>"},{"location":"architecture/overview/#package-reorganization-rationale","title":"Package Reorganization Rationale","text":"<p>The recent package structure balances functionality distribution:</p> <ul> <li>Main package: Constants and metadata (lightweight imports)</li> <li>Utils package: Mathematical functions and core utilities </li> <li>Specialized modules: Domain-specific functionality (graph, timing, random)</li> </ul> <p>This structure supports both convenience imports (<code>from causaliq_core.utils import rndsf</code>) and modular usage patterns while maintaining backward compatibility.</p>"}]}